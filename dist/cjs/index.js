'use strict';

var React = require('react');
var ReactDOM = require('react-dom');
var require$$1 = require('canvas');
var axios = require('axios');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);

var global$2 = (typeof global !== "undefined" ? global :
  typeof self !== "undefined" ? self :
  typeof window !== "undefined" ? window : {});

// shim for using process in browser
// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$2.setTimeout === 'function') {
    cachedSetTimeout = setTimeout;
}
if (typeof global$2.clearTimeout === 'function') {
    cachedClearTimeout = clearTimeout;
}

function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
}
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
var title = 'browser';
var platform = 'browser';
var browser = true;
var env$1 = {};
var argv = [];
var version = ''; // empty string to avoid regexp issues
var versions = {};
var release = {};
var config = {};

function noop$2() {}

var on = noop$2;
var addListener = noop$2;
var once = noop$2;
var off = noop$2;
var removeListener = noop$2;
var removeAllListeners = noop$2;
var emit = noop$2;

function binding(name) {
    throw new Error('process.binding is not supported');
}

function cwd () { return '/' }
function chdir (dir) {
    throw new Error('process.chdir is not supported');
}function umask() { return 0; }

// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
var performance = global$2.performance || {};
var performanceNow =
  performance.now        ||
  performance.mozNow     ||
  performance.msNow      ||
  performance.oNow       ||
  performance.webkitNow  ||
  function(){ return (new Date()).getTime() };

// generate timestamp or delta
// see http://nodejs.org/api/process.html#process_process_hrtime
function hrtime(previousTimestamp){
  var clocktime = performanceNow.call(performance)*1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor((clocktime%1)*1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds<0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds,nanoseconds]
}

var startTime = new Date();
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1000;
}

var browser$1 = {
  nextTick: nextTick,
  title: title,
  browser: browser,
  env: env$1,
  argv: argv,
  version: version,
  versions: versions,
  on: on,
  addListener: addListener,
  once: once,
  off: off,
  removeListener: removeListener,
  removeAllListeners: removeAllListeners,
  emit: emit,
  binding: binding,
  cwd: cwd,
  chdir: chdir,
  umask: umask,
  hrtime: hrtime,
  platform: platform,
  release: release,
  config: config,
  uptime: uptime
};

var process = browser$1;

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var jsxRuntime = {exports: {}};

var reactJsxRuntime_production_min = {};

/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactJsxRuntime_production_min;

function requireReactJsxRuntime_production_min () {
	if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
	hasRequiredReactJsxRuntime_production_min = 1;
var f=React,k=Symbol.for("react.element"),l=Symbol.for("react.fragment"),m=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p={key:!0,ref:!0,__self:!0,__source:!0};
	function q(c,a,g){var b,d={},e=null,h=null;void 0!==g&&(e=""+g);void 0!==a.key&&(e=""+a.key);void 0!==a.ref&&(h=a.ref);for(b in a)m.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return {$$typeof:k,type:c,key:e,ref:h,props:d,_owner:n.current}}reactJsxRuntime_production_min.Fragment=l;reactJsxRuntime_production_min.jsx=q;reactJsxRuntime_production_min.jsxs=q;
	return reactJsxRuntime_production_min;
}

var reactJsxRuntime_development = {};

var hasRequiredReactJsxRuntime_development;

function requireReactJsxRuntime_development () {
	if (hasRequiredReactJsxRuntime_development) return reactJsxRuntime_development;
	hasRequiredReactJsxRuntime_development = 1;

	if (process.env.NODE_ENV !== "production") {
	  (function() {

	var React$1 = React;

	// ATTENTION
	// When adding new symbols to this file,
	// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
	// The Symbol used to tag the ReactElement-like types.
	var REACT_ELEMENT_TYPE = Symbol.for('react.element');
	var REACT_PORTAL_TYPE = Symbol.for('react.portal');
	var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
	var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
	var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
	var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
	var REACT_CONTEXT_TYPE = Symbol.for('react.context');
	var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
	var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
	var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
	var REACT_MEMO_TYPE = Symbol.for('react.memo');
	var REACT_LAZY_TYPE = Symbol.for('react.lazy');
	var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
	var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator';
	function getIteratorFn(maybeIterable) {
	  if (maybeIterable === null || typeof maybeIterable !== 'object') {
	    return null;
	  }

	  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

	  if (typeof maybeIterator === 'function') {
	    return maybeIterator;
	  }

	  return null;
	}

	var ReactSharedInternals = React$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

	function error(format) {
	  {
	    {
	      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	        args[_key2 - 1] = arguments[_key2];
	      }

	      printWarning('error', format, args);
	    }
	  }
	}

	function printWarning(level, format, args) {
	  // When changing this logic, you might want to also
	  // update consoleWithStackDev.www.js as well.
	  {
	    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
	    var stack = ReactDebugCurrentFrame.getStackAddendum();

	    if (stack !== '') {
	      format += '%s';
	      args = args.concat([stack]);
	    } // eslint-disable-next-line react-internal/safe-string-coercion


	    var argsWithFormat = args.map(function (item) {
	      return String(item);
	    }); // Careful: RN currently depends on this prefix

	    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
	    // breaks IE9: https://github.com/facebook/react/issues/13610
	    // eslint-disable-next-line react-internal/no-production-logging

	    Function.prototype.apply.call(console[level], console, argsWithFormat);
	  }
	}

	// -----------------------------------------------------------------------------

	var enableScopeAPI = false; // Experimental Create Event Handle API.
	var enableCacheElement = false;
	var enableTransitionTracing = false; // No known bugs, but needs performance testing

	var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber
	// stuff. Intended to enable React core members to more easily debug scheduling
	// issues in DEV builds.

	var enableDebugTracing = false; // Track which Fiber(s) schedule render work.

	var REACT_MODULE_REFERENCE;

	{
	  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
	}

	function isValidElementType(type) {
	  if (typeof type === 'string' || typeof type === 'function') {
	    return true;
	  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


	  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {
	    return true;
	  }

	  if (typeof type === 'object' && type !== null) {
	    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
	    // types supported by any Flight configuration anywhere since
	    // we don't know which Flight build this will end up being used
	    // with.
	    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
	      return true;
	    }
	  }

	  return false;
	}

	function getWrappedName(outerType, innerType, wrapperName) {
	  var displayName = outerType.displayName;

	  if (displayName) {
	    return displayName;
	  }

	  var functionName = innerType.displayName || innerType.name || '';
	  return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
	} // Keep in sync with react-reconciler/getComponentNameFromFiber


	function getContextName(type) {
	  return type.displayName || 'Context';
	} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.


	function getComponentNameFromType(type) {
	  if (type == null) {
	    // Host root, text node or just invalid type.
	    return null;
	  }

	  {
	    if (typeof type.tag === 'number') {
	      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
	    }
	  }

	  if (typeof type === 'function') {
	    return type.displayName || type.name || null;
	  }

	  if (typeof type === 'string') {
	    return type;
	  }

	  switch (type) {
	    case REACT_FRAGMENT_TYPE:
	      return 'Fragment';

	    case REACT_PORTAL_TYPE:
	      return 'Portal';

	    case REACT_PROFILER_TYPE:
	      return 'Profiler';

	    case REACT_STRICT_MODE_TYPE:
	      return 'StrictMode';

	    case REACT_SUSPENSE_TYPE:
	      return 'Suspense';

	    case REACT_SUSPENSE_LIST_TYPE:
	      return 'SuspenseList';

	  }

	  if (typeof type === 'object') {
	    switch (type.$$typeof) {
	      case REACT_CONTEXT_TYPE:
	        var context = type;
	        return getContextName(context) + '.Consumer';

	      case REACT_PROVIDER_TYPE:
	        var provider = type;
	        return getContextName(provider._context) + '.Provider';

	      case REACT_FORWARD_REF_TYPE:
	        return getWrappedName(type, type.render, 'ForwardRef');

	      case REACT_MEMO_TYPE:
	        var outerName = type.displayName || null;

	        if (outerName !== null) {
	          return outerName;
	        }

	        return getComponentNameFromType(type.type) || 'Memo';

	      case REACT_LAZY_TYPE:
	        {
	          var lazyComponent = type;
	          var payload = lazyComponent._payload;
	          var init = lazyComponent._init;

	          try {
	            return getComponentNameFromType(init(payload));
	          } catch (x) {
	            return null;
	          }
	        }

	      // eslint-disable-next-line no-fallthrough
	    }
	  }

	  return null;
	}

	var assign = Object.assign;

	// Helpers to patch console.logs to avoid logging during side-effect free
	// replaying on render function. This currently only patches the object
	// lazily which won't cover if the log function was extracted eagerly.
	// We could also eagerly patch the method.
	var disabledDepth = 0;
	var prevLog;
	var prevInfo;
	var prevWarn;
	var prevError;
	var prevGroup;
	var prevGroupCollapsed;
	var prevGroupEnd;

	function disabledLog() {}

	disabledLog.__reactDisabledLog = true;
	function disableLogs() {
	  {
	    if (disabledDepth === 0) {
	      /* eslint-disable react-internal/no-production-logging */
	      prevLog = console.log;
	      prevInfo = console.info;
	      prevWarn = console.warn;
	      prevError = console.error;
	      prevGroup = console.group;
	      prevGroupCollapsed = console.groupCollapsed;
	      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

	      var props = {
	        configurable: true,
	        enumerable: true,
	        value: disabledLog,
	        writable: true
	      }; // $FlowFixMe Flow thinks console is immutable.

	      Object.defineProperties(console, {
	        info: props,
	        log: props,
	        warn: props,
	        error: props,
	        group: props,
	        groupCollapsed: props,
	        groupEnd: props
	      });
	      /* eslint-enable react-internal/no-production-logging */
	    }

	    disabledDepth++;
	  }
	}
	function reenableLogs() {
	  {
	    disabledDepth--;

	    if (disabledDepth === 0) {
	      /* eslint-disable react-internal/no-production-logging */
	      var props = {
	        configurable: true,
	        enumerable: true,
	        writable: true
	      }; // $FlowFixMe Flow thinks console is immutable.

	      Object.defineProperties(console, {
	        log: assign({}, props, {
	          value: prevLog
	        }),
	        info: assign({}, props, {
	          value: prevInfo
	        }),
	        warn: assign({}, props, {
	          value: prevWarn
	        }),
	        error: assign({}, props, {
	          value: prevError
	        }),
	        group: assign({}, props, {
	          value: prevGroup
	        }),
	        groupCollapsed: assign({}, props, {
	          value: prevGroupCollapsed
	        }),
	        groupEnd: assign({}, props, {
	          value: prevGroupEnd
	        })
	      });
	      /* eslint-enable react-internal/no-production-logging */
	    }

	    if (disabledDepth < 0) {
	      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
	    }
	  }
	}

	var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
	var prefix;
	function describeBuiltInComponentFrame(name, source, ownerFn) {
	  {
	    if (prefix === undefined) {
	      // Extract the VM specific prefix used by each line.
	      try {
	        throw Error();
	      } catch (x) {
	        var match = x.stack.trim().match(/\n( *(at )?)/);
	        prefix = match && match[1] || '';
	      }
	    } // We use the prefix to ensure our stacks line up with native stack frames.


	    return '\n' + prefix + name;
	  }
	}
	var reentry = false;
	var componentFrameCache;

	{
	  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
	  componentFrameCache = new PossiblyWeakMap();
	}

	function describeNativeComponentFrame(fn, construct) {
	  // If something asked for a stack inside a fake render, it should get ignored.
	  if ( !fn || reentry) {
	    return '';
	  }

	  {
	    var frame = componentFrameCache.get(fn);

	    if (frame !== undefined) {
	      return frame;
	    }
	  }

	  var control;
	  reentry = true;
	  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

	  Error.prepareStackTrace = undefined;
	  var previousDispatcher;

	  {
	    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
	    // for warnings.

	    ReactCurrentDispatcher.current = null;
	    disableLogs();
	  }

	  try {
	    // This should throw.
	    if (construct) {
	      // Something should be setting the props in the constructor.
	      var Fake = function () {
	        throw Error();
	      }; // $FlowFixMe


	      Object.defineProperty(Fake.prototype, 'props', {
	        set: function () {
	          // We use a throwing setter instead of frozen or non-writable props
	          // because that won't throw in a non-strict mode function.
	          throw Error();
	        }
	      });

	      if (typeof Reflect === 'object' && Reflect.construct) {
	        // We construct a different control for this case to include any extra
	        // frames added by the construct call.
	        try {
	          Reflect.construct(Fake, []);
	        } catch (x) {
	          control = x;
	        }

	        Reflect.construct(fn, [], Fake);
	      } else {
	        try {
	          Fake.call();
	        } catch (x) {
	          control = x;
	        }

	        fn.call(Fake.prototype);
	      }
	    } else {
	      try {
	        throw Error();
	      } catch (x) {
	        control = x;
	      }

	      fn();
	    }
	  } catch (sample) {
	    // This is inlined manually because closure doesn't do it for us.
	    if (sample && control && typeof sample.stack === 'string') {
	      // This extracts the first frame from the sample that isn't also in the control.
	      // Skipping one frame that we assume is the frame that calls the two.
	      var sampleLines = sample.stack.split('\n');
	      var controlLines = control.stack.split('\n');
	      var s = sampleLines.length - 1;
	      var c = controlLines.length - 1;

	      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
	        // We expect at least one stack frame to be shared.
	        // Typically this will be the root most one. However, stack frames may be
	        // cut off due to maximum stack limits. In this case, one maybe cut off
	        // earlier than the other. We assume that the sample is longer or the same
	        // and there for cut off earlier. So we should find the root most frame in
	        // the sample somewhere in the control.
	        c--;
	      }

	      for (; s >= 1 && c >= 0; s--, c--) {
	        // Next we find the first one that isn't the same which should be the
	        // frame that called our sample function and the control.
	        if (sampleLines[s] !== controlLines[c]) {
	          // In V8, the first line is describing the message but other VMs don't.
	          // If we're about to return the first line, and the control is also on the same
	          // line, that's a pretty good indicator that our sample threw at same line as
	          // the control. I.e. before we entered the sample frame. So we ignore this result.
	          // This can happen if you passed a class to function component, or non-function.
	          if (s !== 1 || c !== 1) {
	            do {
	              s--;
	              c--; // We may still have similar intermediate frames from the construct call.
	              // The next one that isn't the same should be our match though.

	              if (c < 0 || sampleLines[s] !== controlLines[c]) {
	                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
	                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled "<anonymous>"
	                // but we have a user-provided "displayName"
	                // splice it in to make the stack more readable.


	                if (fn.displayName && _frame.includes('<anonymous>')) {
	                  _frame = _frame.replace('<anonymous>', fn.displayName);
	                }

	                {
	                  if (typeof fn === 'function') {
	                    componentFrameCache.set(fn, _frame);
	                  }
	                } // Return the line we found.


	                return _frame;
	              }
	            } while (s >= 1 && c >= 0);
	          }

	          break;
	        }
	      }
	    }
	  } finally {
	    reentry = false;

	    {
	      ReactCurrentDispatcher.current = previousDispatcher;
	      reenableLogs();
	    }

	    Error.prepareStackTrace = previousPrepareStackTrace;
	  } // Fallback to just using the name if we couldn't make it throw.


	  var name = fn ? fn.displayName || fn.name : '';
	  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

	  {
	    if (typeof fn === 'function') {
	      componentFrameCache.set(fn, syntheticFrame);
	    }
	  }

	  return syntheticFrame;
	}
	function describeFunctionComponentFrame(fn, source, ownerFn) {
	  {
	    return describeNativeComponentFrame(fn, false);
	  }
	}

	function shouldConstruct(Component) {
	  var prototype = Component.prototype;
	  return !!(prototype && prototype.isReactComponent);
	}

	function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

	  if (type == null) {
	    return '';
	  }

	  if (typeof type === 'function') {
	    {
	      return describeNativeComponentFrame(type, shouldConstruct(type));
	    }
	  }

	  if (typeof type === 'string') {
	    return describeBuiltInComponentFrame(type);
	  }

	  switch (type) {
	    case REACT_SUSPENSE_TYPE:
	      return describeBuiltInComponentFrame('Suspense');

	    case REACT_SUSPENSE_LIST_TYPE:
	      return describeBuiltInComponentFrame('SuspenseList');
	  }

	  if (typeof type === 'object') {
	    switch (type.$$typeof) {
	      case REACT_FORWARD_REF_TYPE:
	        return describeFunctionComponentFrame(type.render);

	      case REACT_MEMO_TYPE:
	        // Memo may contain any component type so we recursively resolve it.
	        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

	      case REACT_LAZY_TYPE:
	        {
	          var lazyComponent = type;
	          var payload = lazyComponent._payload;
	          var init = lazyComponent._init;

	          try {
	            // Lazy may contain any component type so we recursively resolve it.
	            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
	          } catch (x) {}
	        }
	    }
	  }

	  return '';
	}

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	var loggedTypeFailures = {};
	var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

	function setCurrentlyValidatingElement(element) {
	  {
	    if (element) {
	      var owner = element._owner;
	      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
	      ReactDebugCurrentFrame.setExtraStackFrame(stack);
	    } else {
	      ReactDebugCurrentFrame.setExtraStackFrame(null);
	    }
	  }
	}

	function checkPropTypes(typeSpecs, values, location, componentName, element) {
	  {
	    // $FlowFixMe This is okay but Flow doesn't know it.
	    var has = Function.call.bind(hasOwnProperty);

	    for (var typeSpecName in typeSpecs) {
	      if (has(typeSpecs, typeSpecName)) {
	        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
	        // fail the render phase where it didn't fail before. So we log it.
	        // After these have been cleaned up, we'll let them throw.

	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          if (typeof typeSpecs[typeSpecName] !== 'function') {
	            // eslint-disable-next-line react-internal/prod-error-codes
	            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
	            err.name = 'Invariant Violation';
	            throw err;
	          }

	          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
	        } catch (ex) {
	          error$1 = ex;
	        }

	        if (error$1 && !(error$1 instanceof Error)) {
	          setCurrentlyValidatingElement(element);

	          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

	          setCurrentlyValidatingElement(null);
	        }

	        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
	          // Only monitor this failure once because there tends to be a lot of the
	          // same error.
	          loggedTypeFailures[error$1.message] = true;
	          setCurrentlyValidatingElement(element);

	          error('Failed %s type: %s', location, error$1.message);

	          setCurrentlyValidatingElement(null);
	        }
	      }
	    }
	  }
	}

	var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare

	function isArray(a) {
	  return isArrayImpl(a);
	}

	/*
	 * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol
	 * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
	 *
	 * The functions in this module will throw an easier-to-understand,
	 * easier-to-debug exception with a clear errors message message explaining the
	 * problem. (Instead of a confusing exception thrown inside the implementation
	 * of the `value` object).
	 */
	// $FlowFixMe only called in DEV, so void return is not possible.
	function typeName(value) {
	  {
	    // toStringTag is needed for namespaced types like Temporal.Instant
	    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
	    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
	    return type;
	  }
	} // $FlowFixMe only called in DEV, so void return is not possible.


	function willCoercionThrow(value) {
	  {
	    try {
	      testStringCoercion(value);
	      return false;
	    } catch (e) {
	      return true;
	    }
	  }
	}

	function testStringCoercion(value) {
	  // If you ended up here by following an exception call stack, here's what's
	  // happened: you supplied an object or symbol value to React (as a prop, key,
	  // DOM attribute, CSS property, string ref, etc.) and when React tried to
	  // coerce it to a string using `'' + value`, an exception was thrown.
	  //
	  // The most common types that will cause this exception are `Symbol` instances
	  // and Temporal objects like `Temporal.Instant`. But any object that has a
	  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
	  // exception. (Library authors do this to prevent users from using built-in
	  // numeric operators like `+` or comparison operators like `>=` because custom
	  // methods are needed to perform accurate arithmetic or comparison.)
	  //
	  // To fix the problem, coerce this object or symbol value to a string before
	  // passing it to React. The most reliable way is usually `String(value)`.
	  //
	  // To find which value is throwing, check the browser or debugger console.
	  // Before this exception was thrown, there should be `console.error` output
	  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
	  // problem and how that type was used: key, atrribute, input value prop, etc.
	  // In most cases, this console output also shows the component and its
	  // ancestor components where the exception happened.
	  //
	  // eslint-disable-next-line react-internal/safe-string-coercion
	  return '' + value;
	}
	function checkKeyStringCoercion(value) {
	  {
	    if (willCoercionThrow(value)) {
	      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));

	      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
	    }
	  }
	}

	var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
	var RESERVED_PROPS = {
	  key: true,
	  ref: true,
	  __self: true,
	  __source: true
	};
	var specialPropKeyWarningShown;
	var specialPropRefWarningShown;
	var didWarnAboutStringRefs;

	{
	  didWarnAboutStringRefs = {};
	}

	function hasValidRef(config) {
	  {
	    if (hasOwnProperty.call(config, 'ref')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }

	  return config.ref !== undefined;
	}

	function hasValidKey(config) {
	  {
	    if (hasOwnProperty.call(config, 'key')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }

	  return config.key !== undefined;
	}

	function warnIfStringRefCannotBeAutoConverted(config, self) {
	  {
	    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
	      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);

	      if (!didWarnAboutStringRefs[componentName]) {
	        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);

	        didWarnAboutStringRefs[componentName] = true;
	      }
	    }
	  }
	}

	function defineKeyPropWarningGetter(props, displayName) {
	  {
	    var warnAboutAccessingKey = function () {
	      if (!specialPropKeyWarningShown) {
	        specialPropKeyWarningShown = true;

	        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
	      }
	    };

	    warnAboutAccessingKey.isReactWarning = true;
	    Object.defineProperty(props, 'key', {
	      get: warnAboutAccessingKey,
	      configurable: true
	    });
	  }
	}

	function defineRefPropWarningGetter(props, displayName) {
	  {
	    var warnAboutAccessingRef = function () {
	      if (!specialPropRefWarningShown) {
	        specialPropRefWarningShown = true;

	        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
	      }
	    };

	    warnAboutAccessingRef.isReactWarning = true;
	    Object.defineProperty(props, 'ref', {
	      get: warnAboutAccessingRef,
	      configurable: true
	    });
	  }
	}
	/**
	 * Factory method to create a new React element. This no longer adheres to
	 * the class pattern, so do not use new to call it. Also, instanceof check
	 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
	 * if something is a React Element.
	 *
	 * @param {*} type
	 * @param {*} props
	 * @param {*} key
	 * @param {string|object} ref
	 * @param {*} owner
	 * @param {*} self A *temporary* helper to detect places where `this` is
	 * different from the `owner` when React.createElement is called, so that we
	 * can warn. We want to get rid of owner and replace string `ref`s with arrow
	 * functions, and as long as `this` and owner are the same, there will be no
	 * change in behavior.
	 * @param {*} source An annotation object (added by a transpiler or otherwise)
	 * indicating filename, line number, and/or other information.
	 * @internal
	 */


	var ReactElement = function (type, key, ref, self, source, owner, props) {
	  var element = {
	    // This tag allows us to uniquely identify this as a React Element
	    $$typeof: REACT_ELEMENT_TYPE,
	    // Built-in properties that belong on the element
	    type: type,
	    key: key,
	    ref: ref,
	    props: props,
	    // Record the component responsible for creating this element.
	    _owner: owner
	  };

	  {
	    // The validation flag is currently mutative. We put it on
	    // an external backing store so that we can freeze the whole object.
	    // This can be replaced with a WeakMap once they are implemented in
	    // commonly used development environments.
	    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
	    // the validation flag non-enumerable (where possible, which should
	    // include every environment we run tests in), so the test framework
	    // ignores it.

	    Object.defineProperty(element._store, 'validated', {
	      configurable: false,
	      enumerable: false,
	      writable: true,
	      value: false
	    }); // self and source are DEV only properties.

	    Object.defineProperty(element, '_self', {
	      configurable: false,
	      enumerable: false,
	      writable: false,
	      value: self
	    }); // Two elements created in two different places should be considered
	    // equal for testing purposes and therefore we hide it from enumeration.

	    Object.defineProperty(element, '_source', {
	      configurable: false,
	      enumerable: false,
	      writable: false,
	      value: source
	    });

	    if (Object.freeze) {
	      Object.freeze(element.props);
	      Object.freeze(element);
	    }
	  }

	  return element;
	};
	/**
	 * https://github.com/reactjs/rfcs/pull/107
	 * @param {*} type
	 * @param {object} props
	 * @param {string} key
	 */

	function jsxDEV(type, config, maybeKey, source, self) {
	  {
	    var propName; // Reserved names are extracted

	    var props = {};
	    var key = null;
	    var ref = null; // Currently, key can be spread in as a prop. This causes a potential
	    // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
	    // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
	    // but as an intermediary step, we will use jsxDEV for everything except
	    // <div {...props} key="Hi" />, because we aren't currently able to tell if
	    // key is explicitly declared to be undefined or not.

	    if (maybeKey !== undefined) {
	      {
	        checkKeyStringCoercion(maybeKey);
	      }

	      key = '' + maybeKey;
	    }

	    if (hasValidKey(config)) {
	      {
	        checkKeyStringCoercion(config.key);
	      }

	      key = '' + config.key;
	    }

	    if (hasValidRef(config)) {
	      ref = config.ref;
	      warnIfStringRefCannotBeAutoConverted(config, self);
	    } // Remaining properties are added to a new props object


	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    } // Resolve default props


	    if (type && type.defaultProps) {
	      var defaultProps = type.defaultProps;

	      for (propName in defaultProps) {
	        if (props[propName] === undefined) {
	          props[propName] = defaultProps[propName];
	        }
	      }
	    }

	    if (key || ref) {
	      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

	      if (key) {
	        defineKeyPropWarningGetter(props, displayName);
	      }

	      if (ref) {
	        defineRefPropWarningGetter(props, displayName);
	      }
	    }

	    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	  }
	}

	var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
	var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

	function setCurrentlyValidatingElement$1(element) {
	  {
	    if (element) {
	      var owner = element._owner;
	      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
	      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
	    } else {
	      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
	    }
	  }
	}

	var propTypesMisspellWarningShown;

	{
	  propTypesMisspellWarningShown = false;
	}
	/**
	 * Verifies the object is a ReactElement.
	 * See https://reactjs.org/docs/react-api.html#isvalidelement
	 * @param {?object} object
	 * @return {boolean} True if `object` is a ReactElement.
	 * @final
	 */


	function isValidElement(object) {
	  {
	    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	  }
	}

	function getDeclarationErrorAddendum() {
	  {
	    if (ReactCurrentOwner$1.current) {
	      var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);

	      if (name) {
	        return '\n\nCheck the render method of `' + name + '`.';
	      }
	    }

	    return '';
	  }
	}

	function getSourceInfoErrorAddendum(source) {
	  {
	    if (source !== undefined) {
	      var fileName = source.fileName.replace(/^.*[\\\/]/, '');
	      var lineNumber = source.lineNumber;
	      return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
	    }

	    return '';
	  }
	}
	/**
	 * Warn if there's no key explicitly set on dynamic arrays of children or
	 * object keys are not valid. This allows us to keep track of children between
	 * updates.
	 */


	var ownerHasKeyUseWarning = {};

	function getCurrentComponentErrorInfo(parentType) {
	  {
	    var info = getDeclarationErrorAddendum();

	    if (!info) {
	      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

	      if (parentName) {
	        info = "\n\nCheck the top-level render call using <" + parentName + ">.";
	      }
	    }

	    return info;
	  }
	}
	/**
	 * Warn if the element doesn't have an explicit key assigned to it.
	 * This element is in an array. The array could grow and shrink or be
	 * reordered. All children that haven't already been validated are required to
	 * have a "key" property assigned to it. Error statuses are cached so a warning
	 * will only be shown once.
	 *
	 * @internal
	 * @param {ReactElement} element Element that requires a key.
	 * @param {*} parentType element's parent's type.
	 */


	function validateExplicitKey(element, parentType) {
	  {
	    if (!element._store || element._store.validated || element.key != null) {
	      return;
	    }

	    element._store.validated = true;
	    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

	    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
	      return;
	    }

	    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
	    // property, it may be the creator of the child that's responsible for
	    // assigning it a key.

	    var childOwner = '';

	    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
	      // Give the component that originally created this child.
	      childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
	    }

	    setCurrentlyValidatingElement$1(element);

	    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

	    setCurrentlyValidatingElement$1(null);
	  }
	}
	/**
	 * Ensure that every element either is passed in a static location, in an
	 * array with an explicit keys property defined, or in an object literal
	 * with valid key property.
	 *
	 * @internal
	 * @param {ReactNode} node Statically passed child of any type.
	 * @param {*} parentType node's parent's type.
	 */


	function validateChildKeys(node, parentType) {
	  {
	    if (typeof node !== 'object') {
	      return;
	    }

	    if (isArray(node)) {
	      for (var i = 0; i < node.length; i++) {
	        var child = node[i];

	        if (isValidElement(child)) {
	          validateExplicitKey(child, parentType);
	        }
	      }
	    } else if (isValidElement(node)) {
	      // This element was passed in a valid location.
	      if (node._store) {
	        node._store.validated = true;
	      }
	    } else if (node) {
	      var iteratorFn = getIteratorFn(node);

	      if (typeof iteratorFn === 'function') {
	        // Entry iterators used to provide implicit keys,
	        // but now we print a separate warning for them later.
	        if (iteratorFn !== node.entries) {
	          var iterator = iteratorFn.call(node);
	          var step;

	          while (!(step = iterator.next()).done) {
	            if (isValidElement(step.value)) {
	              validateExplicitKey(step.value, parentType);
	            }
	          }
	        }
	      }
	    }
	  }
	}
	/**
	 * Given an element, validate that its props follow the propTypes definition,
	 * provided by the type.
	 *
	 * @param {ReactElement} element
	 */


	function validatePropTypes(element) {
	  {
	    var type = element.type;

	    if (type === null || type === undefined || typeof type === 'string') {
	      return;
	    }

	    var propTypes;

	    if (typeof type === 'function') {
	      propTypes = type.propTypes;
	    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
	    // Inner props are checked in the reconciler.
	    type.$$typeof === REACT_MEMO_TYPE)) {
	      propTypes = type.propTypes;
	    } else {
	      return;
	    }

	    if (propTypes) {
	      // Intentionally inside to avoid triggering lazy initializers:
	      var name = getComponentNameFromType(type);
	      checkPropTypes(propTypes, element.props, 'prop', name, element);
	    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
	      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

	      var _name = getComponentNameFromType(type);

	      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
	    }

	    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
	      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
	    }
	  }
	}
	/**
	 * Given a fragment, validate that it can only be provided with fragment props
	 * @param {ReactElement} fragment
	 */


	function validateFragmentProps(fragment) {
	  {
	    var keys = Object.keys(fragment.props);

	    for (var i = 0; i < keys.length; i++) {
	      var key = keys[i];

	      if (key !== 'children' && key !== 'key') {
	        setCurrentlyValidatingElement$1(fragment);

	        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

	        setCurrentlyValidatingElement$1(null);
	        break;
	      }
	    }

	    if (fragment.ref !== null) {
	      setCurrentlyValidatingElement$1(fragment);

	      error('Invalid attribute `ref` supplied to `React.Fragment`.');

	      setCurrentlyValidatingElement$1(null);
	    }
	  }
	}

	function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
	  {
	    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
	    // succeed and there will likely be errors in render.

	    if (!validType) {
	      var info = '';

	      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
	        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
	      }

	      var sourceInfo = getSourceInfoErrorAddendum(source);

	      if (sourceInfo) {
	        info += sourceInfo;
	      } else {
	        info += getDeclarationErrorAddendum();
	      }

	      var typeString;

	      if (type === null) {
	        typeString = 'null';
	      } else if (isArray(type)) {
	        typeString = 'array';
	      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
	        typeString = "<" + (getComponentNameFromType(type.type) || 'Unknown') + " />";
	        info = ' Did you accidentally export a JSX literal instead of a component?';
	      } else {
	        typeString = typeof type;
	      }

	      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
	    }

	    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
	    // TODO: Drop this when these are no longer allowed as the type argument.

	    if (element == null) {
	      return element;
	    } // Skip key warning if the type isn't valid since our key validation logic
	    // doesn't expect a non-string/function type and can throw confusing errors.
	    // We don't want exception behavior to differ between dev and prod.
	    // (Rendering will throw with a helpful message and as soon as the type is
	    // fixed, the key warnings will appear.)


	    if (validType) {
	      var children = props.children;

	      if (children !== undefined) {
	        if (isStaticChildren) {
	          if (isArray(children)) {
	            for (var i = 0; i < children.length; i++) {
	              validateChildKeys(children[i], type);
	            }

	            if (Object.freeze) {
	              Object.freeze(children);
	            }
	          } else {
	            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
	          }
	        } else {
	          validateChildKeys(children, type);
	        }
	      }
	    }

	    if (type === REACT_FRAGMENT_TYPE) {
	      validateFragmentProps(element);
	    } else {
	      validatePropTypes(element);
	    }

	    return element;
	  }
	} // These two functions exist to still get child warnings in dev
	// even with the prod transform. This means that jsxDEV is purely
	// opt-in behavior for better messages but that we won't stop
	// giving you warnings if you use production apis.

	function jsxWithValidationStatic(type, props, key) {
	  {
	    return jsxWithValidation(type, props, key, true);
	  }
	}
	function jsxWithValidationDynamic(type, props, key) {
	  {
	    return jsxWithValidation(type, props, key, false);
	  }
	}

	var jsx =  jsxWithValidationDynamic ; // we may want to special case jsxs internally to take advantage of static children.
	// for now we can ship identical prod functions

	var jsxs =  jsxWithValidationStatic ;

	reactJsxRuntime_development.Fragment = REACT_FRAGMENT_TYPE;
	reactJsxRuntime_development.jsx = jsx;
	reactJsxRuntime_development.jsxs = jsxs;
	  })();
	}
	return reactJsxRuntime_development;
}

if (process.env.NODE_ENV === 'production') {
  jsxRuntime.exports = requireReactJsxRuntime_production_min();
} else {
  jsxRuntime.exports = requireReactJsxRuntime_development();
}

var jsxRuntimeExports = jsxRuntime.exports;

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */

function err(message) {
  const error = new Error(message); // In V8, Error objects keep the closure scope chain alive until the
  // err.stack property is accessed.

  if (error.stack === undefined) {
    // IE sets the stack only if error is thrown
    try {
      throw error;
    } catch (_) {} // eslint-disable-line fb-www/no-unused-catch-bindings, no-empty

  }

  return error;
}

var err_1 = err;

// @oss-only


var Recoil_err = err_1;

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */

// Split declaration and implementation to allow this function to pretend to
// check for actual instance of Promise instead of something with a `then`
// method.
// eslint-disable-next-line no-redeclare
function isPromise(p) {
  return !!p && typeof p.then === 'function';
}

var Recoil_isPromise = isPromise;

function nullthrows(x, message) {
  if (x != null) {
    return x;
  }

  throw Recoil_err(message !== null && message !== void 0 ? message : 'Got unexpected null or undefined');
}

var Recoil_nullthrows = nullthrows;

function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

class BaseLoadable {
  getValue() {
    throw Recoil_err('BaseLoadable');
  }

  toPromise() {
    throw Recoil_err('BaseLoadable');
  }

  valueMaybe() {
    throw Recoil_err('BaseLoadable');
  }

  valueOrThrow() {
    // $FlowFixMe[prop-missing]
    throw Recoil_err(`Loadable expected value, but in "${this.state}" state`);
  }

  promiseMaybe() {
    throw Recoil_err('BaseLoadable');
  }

  promiseOrThrow() {
    // $FlowFixMe[prop-missing]
    throw Recoil_err(`Loadable expected promise, but in "${this.state}" state`);
  }

  errorMaybe() {
    throw Recoil_err('BaseLoadable');
  }

  errorOrThrow() {
    // $FlowFixMe[prop-missing]
    throw Recoil_err(`Loadable expected error, but in "${this.state}" state`);
  }

  is(other) {
    // $FlowFixMe[prop-missing]
    return other.state === this.state && other.contents === this.contents;
  }

  map(_map) {
    throw Recoil_err('BaseLoadable');
  }

}

class ValueLoadable extends BaseLoadable {
  constructor(value) {
    super();

    _defineProperty$2(this, "state", 'hasValue');

    _defineProperty$2(this, "contents", void 0);

    this.contents = value;
  }

  getValue() {
    return this.contents;
  }

  toPromise() {
    return Promise.resolve(this.contents);
  }

  valueMaybe() {
    return this.contents;
  }

  valueOrThrow() {
    return this.contents;
  }

  promiseMaybe() {
    return undefined;
  }

  errorMaybe() {
    return undefined;
  }

  map(map) {
    try {
      const next = map(this.contents);
      return Recoil_isPromise(next) ? loadableWithPromise(next) : isLoadable(next) ? next : loadableWithValue(next);
    } catch (e) {
      return Recoil_isPromise(e) ? // If we "suspended", then try again.
      // errors and subsequent retries will be handled in 'loading' case
      // $FlowFixMe[prop-missing]
      loadableWithPromise(e.next(() => this.map(map))) : loadableWithError(e);
    }
  }

}

class ErrorLoadable extends BaseLoadable {
  constructor(error) {
    super();

    _defineProperty$2(this, "state", 'hasError');

    _defineProperty$2(this, "contents", void 0);

    this.contents = error;
  }

  getValue() {
    throw this.contents;
  }

  toPromise() {
    return Promise.reject(this.contents);
  }

  valueMaybe() {
    return undefined;
  }

  promiseMaybe() {
    return undefined;
  }

  errorMaybe() {
    return this.contents;
  }

  errorOrThrow() {
    return this.contents;
  }

  map(_map) {
    // $FlowIssue[incompatible-return]
    return this;
  }

}

class LoadingLoadable extends BaseLoadable {
  constructor(promise) {
    super();

    _defineProperty$2(this, "state", 'loading');

    _defineProperty$2(this, "contents", void 0);

    this.contents = promise;
  }

  getValue() {
    throw this.contents;
  }

  toPromise() {
    return this.contents;
  }

  valueMaybe() {
    return undefined;
  }

  promiseMaybe() {
    return this.contents;
  }

  promiseOrThrow() {
    return this.contents;
  }

  errorMaybe() {
    return undefined;
  }

  map(map) {
    return loadableWithPromise(this.contents.then(value => {
      const next = map(value);

      if (isLoadable(next)) {
        const nextLoadable = next;

        switch (nextLoadable.state) {
          case 'hasValue':
            return nextLoadable.contents;

          case 'hasError':
            throw nextLoadable.contents;

          case 'loading':
            return nextLoadable.contents;
        }
      } // $FlowIssue[incompatible-return]


      return next;
    }) // $FlowFixMe[incompatible-call]
    .catch(e => {
      if (Recoil_isPromise(e)) {
        // we were "suspended," try again
        return e.then(() => this.map(map).contents);
      }

      throw e;
    }));
  }

}

function loadableWithValue(value) {
  return Object.freeze(new ValueLoadable(value));
}

function loadableWithError(error) {
  return Object.freeze(new ErrorLoadable(error));
}

function loadableWithPromise(promise) {
  return Object.freeze(new LoadingLoadable(promise));
}

function loadableLoading() {
  return Object.freeze(new LoadingLoadable(new Promise(() => {})));
}

function loadableAllArray(inputs) {
  return inputs.every(i => i.state === 'hasValue') ? loadableWithValue(inputs.map(i => i.contents)) : inputs.some(i => i.state === 'hasError') ? loadableWithError(Recoil_nullthrows(inputs.find(i => i.state === 'hasError'), 'Invalid loadable passed to loadableAll').contents) : loadableWithPromise(Promise.all(inputs.map(i => i.contents)));
}

function loadableAll(inputs) {
  const unwrapedInputs = Array.isArray(inputs) ? inputs : Object.getOwnPropertyNames(inputs).map(key => inputs[key]);
  const normalizedInputs = unwrapedInputs.map(x => isLoadable(x) ? x : Recoil_isPromise(x) ? loadableWithPromise(x) : loadableWithValue(x));
  const output = loadableAllArray(normalizedInputs);
  return Array.isArray(inputs) ? // $FlowIssue[incompatible-return]
  output : // Object.getOwnPropertyNames() has consistent key ordering with ES6
  // $FlowIssue[incompatible-call]
  output.map(outputs => Object.getOwnPropertyNames(inputs).reduce( // $FlowFixMe[invalid-computed-prop]
  (out, key, idx) => ({ ...out,
    [key]: outputs[idx]
  }), {}));
}

function isLoadable(x) {
  return x instanceof BaseLoadable;
}

const LoadableStaticInterface = {
  of: value => Recoil_isPromise(value) ? loadableWithPromise(value) : isLoadable(value) ? value : loadableWithValue(value),
  error: error => loadableWithError(error),
  // $FlowIssue[incompatible-return]
  loading: () => loadableLoading(),
  // $FlowIssue[unclear-type]
  all: loadableAll,
  isLoadable
};
var Recoil_Loadable = {
  loadableWithValue,
  loadableWithError,
  loadableWithPromise,
  loadableLoading,
  loadableAll,
  isLoadable,
  RecoilLoadable: LoadableStaticInterface
};

var Recoil_Loadable_1 = Recoil_Loadable.loadableWithValue;
var Recoil_Loadable_2 = Recoil_Loadable.loadableWithError;
var Recoil_Loadable_3 = Recoil_Loadable.loadableWithPromise;
var Recoil_Loadable_4 = Recoil_Loadable.loadableLoading;
var Recoil_Loadable_5 = Recoil_Loadable.loadableAll;
var Recoil_Loadable_6 = Recoil_Loadable.isLoadable;
var Recoil_Loadable_7 = Recoil_Loadable.RecoilLoadable;

var Recoil_Loadable$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  loadableWithValue: Recoil_Loadable_1,
  loadableWithError: Recoil_Loadable_2,
  loadableWithPromise: Recoil_Loadable_3,
  loadableLoading: Recoil_Loadable_4,
  loadableAll: Recoil_Loadable_5,
  isLoadable: Recoil_Loadable_6,
  RecoilLoadable: Recoil_Loadable_7
});

const env = {
  RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED: true,
  // Note: RECOIL_GKS_ENABLED settings will only be honored in OSS builds of Recoil
  RECOIL_GKS_ENABLED: new Set(['recoil_hamt_2020', 'recoil_sync_external_store', 'recoil_suppress_rerender_in_callback', 'recoil_memory_managament_2020'])
};

function readProcessEnvBooleanFlag(name, set) {
  var _process$env$name, _process$env$name$toL;

  const sanitizedValue = (_process$env$name = process.env[name]) === null || _process$env$name === void 0 ? void 0 : (_process$env$name$toL = _process$env$name.toLowerCase()) === null || _process$env$name$toL === void 0 ? void 0 : _process$env$name$toL.trim();

  if (sanitizedValue == null || sanitizedValue === '') {
    return;
  }

  const allowedValues = ['true', 'false'];

  if (!allowedValues.includes(sanitizedValue)) {
    throw Recoil_err(`process.env.${name} value must be 'true', 'false', or empty: ${sanitizedValue}`);
  }

  set(sanitizedValue === 'true');
}

function readProcessEnvStringArrayFlag(name, set) {
  var _process$env$name2;

  const sanitizedValue = (_process$env$name2 = process.env[name]) === null || _process$env$name2 === void 0 ? void 0 : _process$env$name2.trim();

  if (sanitizedValue == null || sanitizedValue === '') {
    return;
  }

  set(sanitizedValue.split(/\s*,\s*|\s+/));
}
/**
 * Allow NodeJS/NextJS/etc to set the initial state through process.env variable
 * Note:  we don't assume 'process' is available in all runtime environments
 *
 * @see https://github.com/facebookexperimental/Recoil/issues/733
 */


function applyProcessEnvFlagOverrides() {
  var _process;

  // note: this check is needed in addition to the check below, runtime error will occur without it!
  // eslint-disable-next-line fb-www/typeof-undefined
  if (typeof process === 'undefined') {
    return;
  }

  if (((_process = process) === null || _process === void 0 ? void 0 : _process.env) == null) {
    return;
  }

  readProcessEnvBooleanFlag('RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED', value => {
    env.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED = value;
  });
  readProcessEnvStringArrayFlag('RECOIL_GKS_ENABLED', value => {
    value.forEach(gk => {
      env.RECOIL_GKS_ENABLED.add(gk);
    });
  });
}

applyProcessEnvFlagOverrides();
var Recoil_RecoilEnv = env;

function Recoil_gkx_OSS(gk) {
  return Recoil_RecoilEnv.RECOIL_GKS_ENABLED.has(gk);
}

Recoil_gkx_OSS.setPass = gk => {
  Recoil_RecoilEnv.RECOIL_GKS_ENABLED.add(gk);
};

Recoil_gkx_OSS.setFail = gk => {
  Recoil_RecoilEnv.RECOIL_GKS_ENABLED.delete(gk);
};

Recoil_gkx_OSS.clear = () => {
  Recoil_RecoilEnv.RECOIL_GKS_ENABLED.clear();
};

var Recoil_gkx = Recoil_gkx_OSS; // @oss-only

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */

function recoverableViolation(message, _projectName, {
  error
} = {}) {
  if (process.env.NODE_ENV !== "production") {
    console.error(message, error);
  }

  return null;
}

var recoverableViolation_1 = recoverableViolation;

// @oss-only


var Recoil_recoverableViolation = recoverableViolation_1;

var _createMutableSource, _useMutableSource, _useSyncExternalStore;







const createMutableSource = // flowlint-next-line unclear-type:off
(_createMutableSource = React.createMutableSource) !== null && _createMutableSource !== void 0 ? _createMutableSource : React.unstable_createMutableSource;
const useMutableSource = // flowlint-next-line unclear-type:off
(_useMutableSource = React.useMutableSource) !== null && _useMutableSource !== void 0 ? _useMutableSource : React.unstable_useMutableSource; // https://github.com/reactwg/react-18/discussions/86

const useSyncExternalStore = // flowlint-next-line unclear-type:off
(_useSyncExternalStore = React.useSyncExternalStore) !== null && _useSyncExternalStore !== void 0 ? _useSyncExternalStore : // flowlint-next-line unclear-type:off
React.unstable_useSyncExternalStore;
let ReactRendererVersionMismatchWarnOnce = false; // Check if the current renderer supports `useSyncExternalStore()`.
// Since React goes through a proxy dispatcher and the current renderer can
// change we can't simply check if `React.useSyncExternalStore()` is defined.

function currentRendererSupportsUseSyncExternalStore() {
  var _ReactCurrentDispatch;

  // $FlowFixMe[incompatible-use]
  const {
    ReactCurrentDispatcher,
    ReactCurrentOwner
  } =
  /* $FlowFixMe[prop-missing] This workaround was approved as a safer mechanism
   * to detect if the current renderer supports useSyncExternalStore()
   * https://fb.workplace.com/groups/reactjs/posts/9558682330846963/ */
  React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  const dispatcher = (_ReactCurrentDispatch = ReactCurrentDispatcher === null || ReactCurrentDispatcher === void 0 ? void 0 : ReactCurrentDispatcher.current) !== null && _ReactCurrentDispatch !== void 0 ? _ReactCurrentDispatch : ReactCurrentOwner.currentDispatcher;
  const isUseSyncExternalStoreSupported = dispatcher.useSyncExternalStore != null;

  if (useSyncExternalStore && !isUseSyncExternalStoreSupported && !ReactRendererVersionMismatchWarnOnce) {
    ReactRendererVersionMismatchWarnOnce = true;
    Recoil_recoverableViolation('A React renderer without React 18+ API support is being used with React 18+.');
  }

  return isUseSyncExternalStoreSupported;
}

/**
 * mode: The React API and approach to use for syncing state with React
 * early: Re-renders from Recoil updates occur:
 *    1) earlier
 *    2) in sync with React updates in the same batch
 *    3) before transaction observers instead of after.
 * concurrent: Is the current mode compatible with Concurrent Mode and useTransition()
 */
function reactMode() {
  // NOTE: This mode is currently broken with some Suspense cases
  // see Recoil_selector-test.js
  if (Recoil_gkx('recoil_transition_support')) {
    return {
      mode: 'TRANSITION_SUPPORT',
      early: true,
      concurrent: true
    };
  }

  if (Recoil_gkx('recoil_sync_external_store') && useSyncExternalStore != null) {
    return {
      mode: 'SYNC_EXTERNAL_STORE',
      early: true,
      concurrent: false
    };
  }

  if (Recoil_gkx('recoil_mutable_source') && useMutableSource != null && typeof window !== 'undefined' && !window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE) {
    return Recoil_gkx('recoil_suppress_rerender_in_callback') ? {
      mode: 'MUTABLE_SOURCE',
      early: true,
      concurrent: true
    } : {
      mode: 'MUTABLE_SOURCE',
      early: false,
      concurrent: false
    };
  }

  return Recoil_gkx('recoil_suppress_rerender_in_callback') ? {
    mode: 'LEGACY',
    early: true,
    concurrent: false
  } : {
    mode: 'LEGACY',
    early: false,
    concurrent: false
  };
} // TODO Need to figure out if there is a standard/open-source equivalent to see if hot module replacement is happening:


function isFastRefreshEnabled() {
  // @fb-only: const {isAcceptingUpdate} = require('__debug');
  // @fb-only: return typeof isAcceptingUpdate === 'function' && isAcceptingUpdate();
  return false; // @oss-only
}

var Recoil_ReactMode = {
  createMutableSource,
  useMutableSource,
  useSyncExternalStore,
  currentRendererSupportsUseSyncExternalStore,
  reactMode,
  isFastRefreshEnabled
};

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */

// eslint-disable-next-line no-unused-vars
class AbstractRecoilValue {
  constructor(newKey) {
    _defineProperty$2(this, "key", void 0);

    this.key = newKey;
  }

  toJSON() {
    return {
      key: this.key
    };
  }

}

class RecoilState extends AbstractRecoilValue {}

class RecoilValueReadOnly extends AbstractRecoilValue {}

function isRecoilValue(x) {
  return x instanceof RecoilState || x instanceof RecoilValueReadOnly;
}

var Recoil_RecoilValue = {
  AbstractRecoilValue,
  RecoilState,
  RecoilValueReadOnly,
  isRecoilValue
};

var Recoil_RecoilValue_1 = Recoil_RecoilValue.AbstractRecoilValue;
var Recoil_RecoilValue_2 = Recoil_RecoilValue.RecoilState;
var Recoil_RecoilValue_3 = Recoil_RecoilValue.RecoilValueReadOnly;
var Recoil_RecoilValue_4 = Recoil_RecoilValue.isRecoilValue;

var Recoil_RecoilValue$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  AbstractRecoilValue: Recoil_RecoilValue_1,
  RecoilState: Recoil_RecoilValue_2,
  RecoilValueReadOnly: Recoil_RecoilValue_3,
  isRecoilValue: Recoil_RecoilValue_4
});

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */

function sprintf(format, ...args) {
  let index = 0;
  return format.replace(/%s/g, () => String(args[index++]));
}

var sprintf_1 = sprintf;

function expectationViolation(format, ...args) {
  if (process.env.NODE_ENV !== "production") {
    const message = sprintf_1.call(null, format, ...args);
    const error = new Error(message);
    error.name = 'Expectation Violation';
    console.error(error);
  }
}

var expectationViolation_1 = expectationViolation;

// @oss-only


var Recoil_expectationViolation = expectationViolation_1;

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */
/**
 * Creates a new iterable whose output is generated by passing the input
 * iterable's values through the mapper function.
 */

function mapIterable(iterable, callback) {
  // Use generator to create iterable/iterator
  return function* () {
    let index = 0;

    for (const value of iterable) {
      yield callback(value, index++);
    }
  }();
}

var Recoil_mapIterable = mapIterable;

const {
  isFastRefreshEnabled: isFastRefreshEnabled$1
} = Recoil_ReactMode;















class DefaultValue {}

const DEFAULT_VALUE = new DefaultValue();
// flowlint-next-line unclear-type:off
const nodes = new Map(); // flowlint-next-line unclear-type:off

const recoilValues = new Map();
/* eslint-disable no-redeclare */

function recoilValuesForKeys(keys) {
  return Recoil_mapIterable(keys, key => Recoil_nullthrows(recoilValues.get(key)));
}

function checkForDuplicateAtomKey(key) {
  if (nodes.has(key)) {
    const message = `Duplicate atom key "${key}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`;

    if (process.env.NODE_ENV !== "production") {
      // TODO Figure this out for open-source
      if (!isFastRefreshEnabled$1()) {
        Recoil_expectationViolation(message, 'recoil');
      }
    } else {
      // @fb-only: recoverableViolation(message, 'recoil');
      console.warn(message); // @oss-only
    }
  }
}

function registerNode(node) {
  if (Recoil_RecoilEnv.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED) {
    checkForDuplicateAtomKey(node.key);
  }

  nodes.set(node.key, node);
  const recoilValue = node.set == null ? new Recoil_RecoilValue$1.RecoilValueReadOnly(node.key) : new Recoil_RecoilValue$1.RecoilState(node.key);
  recoilValues.set(node.key, recoilValue);
  return recoilValue;
}
/* eslint-enable no-redeclare */


class NodeMissingError extends Error {} // flowlint-next-line unclear-type:off


function getNode(key) {
  const node = nodes.get(key);

  if (node == null) {
    throw new NodeMissingError(`Missing definition for RecoilValue: "${key}""`);
  }

  return node;
} // flowlint-next-line unclear-type:off


function getNodeMaybe(key) {
  return nodes.get(key);
}

const configDeletionHandlers = new Map();

function deleteNodeConfigIfPossible(key) {
  var _node$shouldDeleteCon;

  if (!Recoil_gkx('recoil_memory_managament_2020')) {
    return;
  }

  const node = nodes.get(key);

  if (node !== null && node !== void 0 && (_node$shouldDeleteCon = node.shouldDeleteConfigOnRelease) !== null && _node$shouldDeleteCon !== void 0 && _node$shouldDeleteCon.call(node)) {
    var _getConfigDeletionHan;

    nodes.delete(key);
    (_getConfigDeletionHan = getConfigDeletionHandler(key)) === null || _getConfigDeletionHan === void 0 ? void 0 : _getConfigDeletionHan();
    configDeletionHandlers.delete(key);
  }
}

function setConfigDeletionHandler(key, fn) {
  if (!Recoil_gkx('recoil_memory_managament_2020')) {
    return;
  }

  if (fn === undefined) {
    configDeletionHandlers.delete(key);
  } else {
    configDeletionHandlers.set(key, fn);
  }
}

function getConfigDeletionHandler(key) {
  return configDeletionHandlers.get(key);
}

var Recoil_Node = {
  nodes,
  recoilValues,
  registerNode,
  getNode,
  getNodeMaybe,
  deleteNodeConfigIfPossible,
  setConfigDeletionHandler,
  getConfigDeletionHandler,
  recoilValuesForKeys,
  NodeMissingError,
  DefaultValue,
  DEFAULT_VALUE
};

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */

function enqueueExecution(s, f) {
  f();
}

var Recoil_Queue = {
  enqueueExecution
};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var hamt_1 = createCommonjsModule(function (module) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
/**
    @fileOverview Hash Array Mapped Trie.

    Code based on: https://github.com/exclipy/pdata
*/


var hamt = {}; // export

/* Configuration
 ******************************************************************************/

var SIZE = 5;
var BUCKET_SIZE = Math.pow(2, SIZE);
var MASK = BUCKET_SIZE - 1;
var MAX_INDEX_NODE = BUCKET_SIZE / 2;
var MIN_ARRAY_NODE = BUCKET_SIZE / 4;
/*
 ******************************************************************************/

var nothing = {};

var constant = function constant(x) {
  return function () {
    return x;
  };
};
/**
    Get 32 bit hash of string.

    Based on:
    http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery
*/


var hash = hamt.hash = function (str) {
  var type = typeof str === 'undefined' ? 'undefined' : _typeof(str);
  if (type === 'number') return str;
  if (type !== 'string') str += '';
  var hash = 0;

  for (var i = 0, len = str.length; i < len; ++i) {
    var c = str.charCodeAt(i);
    hash = (hash << 5) - hash + c | 0;
  }

  return hash;
};
/* Bit Ops
 ******************************************************************************/

/**
    Hamming weight.

    Taken from: http://jsperf.com/hamming-weight
*/


var popcount = function popcount(x) {
  x -= x >> 1 & 0x55555555;
  x = (x & 0x33333333) + (x >> 2 & 0x33333333);
  x = x + (x >> 4) & 0x0f0f0f0f;
  x += x >> 8;
  x += x >> 16;
  return x & 0x7f;
};

var hashFragment = function hashFragment(shift, h) {
  return h >>> shift & MASK;
};

var toBitmap = function toBitmap(x) {
  return 1 << x;
};

var fromBitmap = function fromBitmap(bitmap, bit) {
  return popcount(bitmap & bit - 1);
};
/* Array Ops
 ******************************************************************************/

/**
    Set a value in an array.

    @param mutate Should the input array be mutated?
    @param at Index to change.
    @param v New value
    @param arr Array.
*/


var arrayUpdate = function arrayUpdate(mutate, at, v, arr) {
  var out = arr;

  if (!mutate) {
    var len = arr.length;
    out = new Array(len);

    for (var i = 0; i < len; ++i) {
      out[i] = arr[i];
    }
  }

  out[at] = v;
  return out;
};
/**
    Remove a value from an array.

    @param mutate Should the input array be mutated?
    @param at Index to remove.
    @param arr Array.
*/


var arraySpliceOut = function arraySpliceOut(mutate, at, arr) {
  var newLen = arr.length - 1;
  var i = 0;
  var g = 0;
  var out = arr;

  if (mutate) {
    i = g = at;
  } else {
    out = new Array(newLen);

    while (i < at) {
      out[g++] = arr[i++];
    }
  }

  ++i;

  while (i <= newLen) {
    out[g++] = arr[i++];
  }

  if (mutate) {
    out.length = newLen;
  }

  return out;
};
/**
    Insert a value into an array.

    @param mutate Should the input array be mutated?
    @param at Index to insert at.
    @param v Value to insert,
    @param arr Array.
*/


var arraySpliceIn = function arraySpliceIn(mutate, at, v, arr) {
  var len = arr.length;

  if (mutate) {
    var _i = len;

    while (_i >= at) {
      arr[_i--] = arr[_i];
    }

    arr[at] = v;
    return arr;
  }

  var i = 0,
      g = 0;
  var out = new Array(len + 1);

  while (i < at) {
    out[g++] = arr[i++];
  }

  out[at] = v;

  while (i < len) {
    out[++g] = arr[i++];
  }

  return out;
};
/* Node Structures
 ******************************************************************************/


var LEAF = 1;
var COLLISION = 2;
var INDEX = 3;
var ARRAY = 4;
/**
    Empty node.
*/

var empty = {
  __hamt_isEmpty: true
};

var isEmptyNode = function isEmptyNode(x) {
  return x === empty || x && x.__hamt_isEmpty;
};
/**
    Leaf holding a value.

    @member edit Edit of the node.
    @member hash Hash of key.
    @member key Key.
    @member value Value stored.
*/


var Leaf = function Leaf(edit, hash, key, value) {
  return {
    type: LEAF,
    edit: edit,
    hash: hash,
    key: key,
    value: value,
    _modify: Leaf__modify
  };
};
/**
    Leaf holding multiple values with the same hash but different keys.

    @member edit Edit of the node.
    @member hash Hash of key.
    @member children Array of collision children node.
*/


var Collision = function Collision(edit, hash, children) {
  return {
    type: COLLISION,
    edit: edit,
    hash: hash,
    children: children,
    _modify: Collision__modify
  };
};
/**
    Internal node with a sparse set of children.

    Uses a bitmap and array to pack children.

  @member edit Edit of the node.
    @member mask Bitmap that encode the positions of children in the array.
    @member children Array of child nodes.
*/


var IndexedNode = function IndexedNode(edit, mask, children) {
  return {
    type: INDEX,
    edit: edit,
    mask: mask,
    children: children,
    _modify: IndexedNode__modify
  };
};
/**
    Internal node with many children.

    @member edit Edit of the node.
    @member size Number of children.
    @member children Array of child nodes.
*/


var ArrayNode = function ArrayNode(edit, size, children) {
  return {
    type: ARRAY,
    edit: edit,
    size: size,
    children: children,
    _modify: ArrayNode__modify
  };
};
/**
    Is `node` a leaf node?
*/


var isLeaf = function isLeaf(node) {
  return node === empty || node.type === LEAF || node.type === COLLISION;
};
/* Internal node operations.
 ******************************************************************************/

/**
    Expand an indexed node into an array node.

  @param edit Current edit.
    @param frag Index of added child.
    @param child Added child.
    @param mask Index node mask before child added.
    @param subNodes Index node children before child added.
*/


var expand = function expand(edit, frag, child, bitmap, subNodes) {
  var arr = [];
  var bit = bitmap;
  var count = 0;

  for (var i = 0; bit; ++i) {
    if (bit & 1) arr[i] = subNodes[count++];
    bit >>>= 1;
  }

  arr[frag] = child;
  return ArrayNode(edit, count + 1, arr);
};
/**
    Collapse an array node into a indexed node.

  @param edit Current edit.
    @param count Number of elements in new array.
    @param removed Index of removed element.
    @param elements Array node children before remove.
*/


var pack = function pack(edit, count, removed, elements) {
  var children = new Array(count - 1);
  var g = 0;
  var bitmap = 0;

  for (var i = 0, len = elements.length; i < len; ++i) {
    if (i !== removed) {
      var elem = elements[i];

      if (elem && !isEmptyNode(elem)) {
        children[g++] = elem;
        bitmap |= 1 << i;
      }
    }
  }

  return IndexedNode(edit, bitmap, children);
};
/**
    Merge two leaf nodes.

    @param shift Current shift.
    @param h1 Node 1 hash.
    @param n1 Node 1.
    @param h2 Node 2 hash.
    @param n2 Node 2.
*/


var mergeLeaves = function mergeLeaves(edit, shift, h1, n1, h2, n2) {
  if (h1 === h2) return Collision(edit, h1, [n2, n1]);
  var subH1 = hashFragment(shift, h1);
  var subH2 = hashFragment(shift, h2);
  return IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), subH1 === subH2 ? [mergeLeaves(edit, shift + SIZE, h1, n1, h2, n2)] : subH1 < subH2 ? [n1, n2] : [n2, n1]);
};
/**
    Update an entry in a collision list.

    @param mutate Should mutation be used?
    @param edit Current edit.
    @param keyEq Key compare function.
    @param hash Hash of collision.
    @param list Collision list.
    @param f Update function.
    @param k Key to update.
    @param size Size ref.
*/


var updateCollisionList = function updateCollisionList(mutate, edit, keyEq, h, list, f, k, size) {
  var len = list.length;

  for (var i = 0; i < len; ++i) {
    var child = list[i];

    if (keyEq(k, child.key)) {
      var value = child.value;

      var _newValue = f(value);

      if (_newValue === value) return list;

      if (_newValue === nothing) {
        --size.value;
        return arraySpliceOut(mutate, i, list);
      }

      return arrayUpdate(mutate, i, Leaf(edit, h, k, _newValue), list);
    }
  }

  var newValue = f();
  if (newValue === nothing) return list;
  ++size.value;
  return arrayUpdate(mutate, len, Leaf(edit, h, k, newValue), list);
};

var canEditNode = function canEditNode(edit, node) {
  return edit === node.edit;
};
/* Editing
 ******************************************************************************/


var Leaf__modify = function Leaf__modify(edit, keyEq, shift, f, h, k, size) {
  if (keyEq(k, this.key)) {
    var _v = f(this.value);

    if (_v === this.value) return this;else if (_v === nothing) {
      --size.value;
      return empty;
    }

    if (canEditNode(edit, this)) {
      this.value = _v;
      return this;
    }

    return Leaf(edit, h, k, _v);
  }

  var v = f();
  if (v === nothing) return this;
  ++size.value;
  return mergeLeaves(edit, shift, this.hash, this, h, Leaf(edit, h, k, v));
};

var Collision__modify = function Collision__modify(edit, keyEq, shift, f, h, k, size) {
  if (h === this.hash) {
    var canEdit = canEditNode(edit, this);
    var list = updateCollisionList(canEdit, edit, keyEq, this.hash, this.children, f, k, size);
    if (list === this.children) return this;
    return list.length > 1 ? Collision(edit, this.hash, list) : list[0]; // collapse single element collision list
  }

  var v = f();
  if (v === nothing) return this;
  ++size.value;
  return mergeLeaves(edit, shift, this.hash, this, h, Leaf(edit, h, k, v));
};

var IndexedNode__modify = function IndexedNode__modify(edit, keyEq, shift, f, h, k, size) {
  var mask = this.mask;
  var children = this.children;
  var frag = hashFragment(shift, h);
  var bit = toBitmap(frag);
  var indx = fromBitmap(mask, bit);
  var exists = mask & bit;
  var current = exists ? children[indx] : empty;

  var child = current._modify(edit, keyEq, shift + SIZE, f, h, k, size);

  if (current === child) return this;
  var canEdit = canEditNode(edit, this);
  var bitmap = mask;
  var newChildren = void 0;

  if (exists && isEmptyNode(child)) {
    // remove
    bitmap &= ~bit;
    if (!bitmap) return empty;
    if (children.length <= 2 && isLeaf(children[indx ^ 1])) return children[indx ^ 1]; // collapse

    newChildren = arraySpliceOut(canEdit, indx, children);
  } else if (!exists && !isEmptyNode(child)) {
    // add
    if (children.length >= MAX_INDEX_NODE) return expand(edit, frag, child, mask, children);
    bitmap |= bit;
    newChildren = arraySpliceIn(canEdit, indx, child, children);
  } else {
    // modify
    newChildren = arrayUpdate(canEdit, indx, child, children);
  }

  if (canEdit) {
    this.mask = bitmap;
    this.children = newChildren;
    return this;
  }

  return IndexedNode(edit, bitmap, newChildren);
};

var ArrayNode__modify = function ArrayNode__modify(edit, keyEq, shift, f, h, k, size) {
  var count = this.size;
  var children = this.children;
  var frag = hashFragment(shift, h);
  var child = children[frag];

  var newChild = (child || empty)._modify(edit, keyEq, shift + SIZE, f, h, k, size);

  if (child === newChild) return this;
  var canEdit = canEditNode(edit, this);
  var newChildren = void 0;

  if (isEmptyNode(child) && !isEmptyNode(newChild)) {
    // add
    ++count;
    newChildren = arrayUpdate(canEdit, frag, newChild, children);
  } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
    // remove
    --count;
    if (count <= MIN_ARRAY_NODE) return pack(edit, count, frag, children);
    newChildren = arrayUpdate(canEdit, frag, empty, children);
  } else {
    // modify
    newChildren = arrayUpdate(canEdit, frag, newChild, children);
  }

  if (canEdit) {
    this.size = count;
    this.children = newChildren;
    return this;
  }

  return ArrayNode(edit, count, newChildren);
};

empty._modify = function (edit, keyEq, shift, f, h, k, size) {
  var v = f();
  if (v === nothing) return empty;
  ++size.value;
  return Leaf(edit, h, k, v);
};
/*
 ******************************************************************************/


function Map(editable, edit, config, root, size) {
  this._editable = editable;
  this._edit = edit;
  this._config = config;
  this._root = root;
  this._size = size;
}

Map.prototype.setTree = function (newRoot, newSize) {
  if (this._editable) {
    this._root = newRoot;
    this._size = newSize;
    return this;
  }

  return newRoot === this._root ? this : new Map(this._editable, this._edit, this._config, newRoot, newSize);
};
/* Queries
 ******************************************************************************/

/**
    Lookup the value for `key` in `map` using a custom `hash`.

    Returns the value or `alt` if none.
*/


var tryGetHash = hamt.tryGetHash = function (alt, hash, key, map) {
  var node = map._root;
  var shift = 0;
  var keyEq = map._config.keyEq;

  while (true) {
    switch (node.type) {
      case LEAF:
        {
          return keyEq(key, node.key) ? node.value : alt;
        }

      case COLLISION:
        {
          if (hash === node.hash) {
            var children = node.children;

            for (var i = 0, len = children.length; i < len; ++i) {
              var child = children[i];
              if (keyEq(key, child.key)) return child.value;
            }
          }

          return alt;
        }

      case INDEX:
        {
          var frag = hashFragment(shift, hash);
          var bit = toBitmap(frag);

          if (node.mask & bit) {
            node = node.children[fromBitmap(node.mask, bit)];
            shift += SIZE;
            break;
          }

          return alt;
        }

      case ARRAY:
        {
          node = node.children[hashFragment(shift, hash)];

          if (node) {
            shift += SIZE;
            break;
          }

          return alt;
        }

      default:
        return alt;
    }
  }
};

Map.prototype.tryGetHash = function (alt, hash, key) {
  return tryGetHash(alt, hash, key, this);
};
/**
    Lookup the value for `key` in `map` using internal hash function.

    @see `tryGetHash`
*/


var tryGet = hamt.tryGet = function (alt, key, map) {
  return tryGetHash(alt, map._config.hash(key), key, map);
};

Map.prototype.tryGet = function (alt, key) {
  return tryGet(alt, key, this);
};
/**
    Lookup the value for `key` in `map` using a custom `hash`.

    Returns the value or `undefined` if none.
*/


var getHash = hamt.getHash = function (hash, key, map) {
  return tryGetHash(undefined, hash, key, map);
};

Map.prototype.getHash = function (hash, key) {
  return getHash(hash, key, this);
};
/**
    Lookup the value for `key` in `map` using internal hash function.

    @see `get`
*/


hamt.get = function (key, map) {
  return tryGetHash(undefined, map._config.hash(key), key, map);
};

Map.prototype.get = function (key, alt) {
  return tryGet(alt, key, this);
};
/**
    Does an entry exist for `key` in `map`? Uses custom `hash`.
*/


var hasHash = hamt.has = function (hash, key, map) {
  return tryGetHash(nothing, hash, key, map) !== nothing;
};

Map.prototype.hasHash = function (hash, key) {
  return hasHash(hash, key, this);
};
/**
    Does an entry exist for `key` in `map`? Uses internal hash function.
*/


var has = hamt.has = function (key, map) {
  return hasHash(map._config.hash(key), key, map);
};

Map.prototype.has = function (key) {
  return has(key, this);
};

var defKeyCompare = function defKeyCompare(x, y) {
  return x === y;
};
/**
    Create an empty map.

    @param config Configuration.
*/


hamt.make = function (config) {
  return new Map(0, 0, {
    keyEq: config && config.keyEq || defKeyCompare,
    hash: config && config.hash || hash
  }, empty, 0);
};
/**
    Empty map.
*/


hamt.empty = hamt.make();
/**
    Does `map` contain any elements?
*/

var isEmpty = hamt.isEmpty = function (map) {
  return map && !!isEmptyNode(map._root);
};

Map.prototype.isEmpty = function () {
  return isEmpty(this);
};
/* Updates
 ******************************************************************************/

/**
    Alter the value stored for `key` in `map` using function `f` using
    custom hash.

    `f` is invoked with the current value for `k` if it exists,
    or no arguments if no such value exists. `modify` will always either
    update or insert a value into the map.

    Returns a map with the modified value. Does not alter `map`.
*/


var modifyHash = hamt.modifyHash = function (f, hash, key, map) {
  var size = {
    value: map._size
  };

  var newRoot = map._root._modify(map._editable ? map._edit : NaN, map._config.keyEq, 0, f, hash, key, size);

  return map.setTree(newRoot, size.value);
};

Map.prototype.modifyHash = function (hash, key, f) {
  return modifyHash(f, hash, key, this);
};
/**
    Alter the value stored for `key` in `map` using function `f` using
    internal hash function.

    @see `modifyHash`
*/


var modify = hamt.modify = function (f, key, map) {
  return modifyHash(f, map._config.hash(key), key, map);
};

Map.prototype.modify = function (key, f) {
  return modify(f, key, this);
};
/**
    Store `value` for `key` in `map` using custom `hash`.

    Returns a map with the modified value. Does not alter `map`.
*/


var setHash = hamt.setHash = function (hash, key, value, map) {
  return modifyHash(constant(value), hash, key, map);
};

Map.prototype.setHash = function (hash, key, value) {
  return setHash(hash, key, value, this);
};
/**
    Store `value` for `key` in `map` using internal hash function.

    @see `setHash`
*/


var set = hamt.set = function (key, value, map) {
  return setHash(map._config.hash(key), key, value, map);
};

Map.prototype.set = function (key, value) {
  return set(key, value, this);
};
/**
    Remove the entry for `key` in `map`.

    Returns a map with the value removed. Does not alter `map`.
*/


var del = constant(nothing);

var removeHash = hamt.removeHash = function (hash, key, map) {
  return modifyHash(del, hash, key, map);
};

Map.prototype.removeHash = Map.prototype.deleteHash = function (hash, key) {
  return removeHash(hash, key, this);
};
/**
    Remove the entry for `key` in `map` using internal hash function.

    @see `removeHash`
*/


var remove = hamt.remove = function (key, map) {
  return removeHash(map._config.hash(key), key, map);
};

Map.prototype.remove = Map.prototype.delete = function (key) {
  return remove(key, this);
};
/* Mutation
 ******************************************************************************/

/**
    Mark `map` as mutable.
 */


var beginMutation = hamt.beginMutation = function (map) {
  return new Map(map._editable + 1, map._edit + 1, map._config, map._root, map._size);
};

Map.prototype.beginMutation = function () {
  return beginMutation(this);
};
/**
    Mark `map` as immutable.
 */


var endMutation = hamt.endMutation = function (map) {
  map._editable = map._editable && map._editable - 1;
  return map;
};

Map.prototype.endMutation = function () {
  return endMutation(this);
};
/**
    Mutate `map` within the context of `f`.
    @param f
    @param map HAMT
*/


var mutate = hamt.mutate = function (f, map) {
  var transient = beginMutation(map);
  f(transient);
  return endMutation(transient);
};

Map.prototype.mutate = function (f) {
  return mutate(f, this);
};
/* Traversal
 ******************************************************************************/

/**
    Apply a continuation.
*/


var appk = function appk(k) {
  return k && lazyVisitChildren(k[0], k[1], k[2], k[3], k[4]);
};
/**
    Recursively visit all values stored in an array of nodes lazily.
*/


var lazyVisitChildren = function lazyVisitChildren(len, children, i, f, k) {
  while (i < len) {
    var child = children[i++];
    if (child && !isEmptyNode(child)) return lazyVisit(child, f, [len, children, i, f, k]);
  }

  return appk(k);
};
/**
    Recursively visit all values stored in `node` lazily.
*/


var lazyVisit = function lazyVisit(node, f, k) {
  switch (node.type) {
    case LEAF:
      return {
        value: f(node),
        rest: k
      };

    case COLLISION:
    case ARRAY:
    case INDEX:
      var children = node.children;
      return lazyVisitChildren(children.length, children, 0, f, k);

    default:
      return appk(k);
  }
};

var DONE = {
  done: true
};
/**
    Javascript iterator over a map.
*/

function MapIterator(v) {
  this.v = v;
}

MapIterator.prototype.next = function () {
  if (!this.v) return DONE;
  var v0 = this.v;
  this.v = appk(v0.rest);
  return v0;
};

MapIterator.prototype[Symbol.iterator] = function () {
  return this;
};
/**
    Lazily visit each value in map with function `f`.
*/


var visit = function visit(map, f) {
  return new MapIterator(lazyVisit(map._root, f));
};
/**
    Get a Javascsript iterator of `map`.

    Iterates over `[key, value]` arrays.
*/


var buildPairs = function buildPairs(x) {
  return [x.key, x.value];
};

var entries = hamt.entries = function (map) {
  return visit(map, buildPairs);
};

Map.prototype.entries = Map.prototype[Symbol.iterator] = function () {
  return entries(this);
};
/**
    Get array of all keys in `map`.

    Order is not guaranteed.
*/


var buildKeys = function buildKeys(x) {
  return x.key;
};

var keys = hamt.keys = function (map) {
  return visit(map, buildKeys);
};

Map.prototype.keys = function () {
  return keys(this);
};
/**
    Get array of all values in `map`.

    Order is not guaranteed, duplicates are preserved.
*/


var buildValues = function buildValues(x) {
  return x.value;
};

var values = hamt.values = Map.prototype.values = function (map) {
  return visit(map, buildValues);
};

Map.prototype.values = function () {
  return values(this);
};
/* Fold
 ******************************************************************************/

/**
    Visit every entry in the map, aggregating data.

    Order of nodes is not guaranteed.

    @param f Function mapping accumulated value, value, and key to new value.
    @param z Starting value.
    @param m HAMT
*/


var fold = hamt.fold = function (f, z, m) {
  var root = m._root;
  if (root.type === LEAF) return f(z, root.value, root.key);
  var toVisit = [root.children];
  var children = void 0;

  while (children = toVisit.pop()) {
    for (var i = 0, len = children.length; i < len;) {
      var child = children[i++];

      if (child && child.type) {
        if (child.type === LEAF) z = f(z, child.value, child.key);else toVisit.push(child.children);
      }
    }
  }

  return z;
};

Map.prototype.fold = function (f, z) {
  return fold(f, z, this);
};
/**
    Visit every entry in the map, aggregating data.

    Order of nodes is not guaranteed.

    @param f Function invoked with value and key
    @param map HAMT
*/


var forEach = hamt.forEach = function (f, map) {
  return fold(function (_, value, key) {
    return f(value, key, map);
  }, null, map);
};

Map.prototype.forEach = function (f) {
  return forEach(f, this);
};
/* Aggregate
 ******************************************************************************/

/**
    Get the number of entries in `map`.
*/


var count = hamt.count = function (map) {
  return map._size;
};

Map.prototype.count = function () {
  return count(this);
};

Object.defineProperty(Map.prototype, 'size', {
  get: Map.prototype.count
});
/* Export
 ******************************************************************************/

if ( module.exports) {
  module.exports = hamt;
} else {
  undefined.hamt = hamt;
}
});

class BuiltInMap {
  constructor(existing) {
    _defineProperty$2(this, "_map", void 0);

    this._map = new Map(existing === null || existing === void 0 ? void 0 : existing.entries());
  }

  keys() {
    return this._map.keys();
  }

  entries() {
    return this._map.entries();
  }

  get(k) {
    return this._map.get(k);
  }

  has(k) {
    return this._map.has(k);
  }

  set(k, v) {
    this._map.set(k, v);

    return this;
  }

  delete(k) {
    this._map.delete(k);

    return this;
  }

  clone() {
    return persistentMap(this);
  }

  toMap() {
    return new Map(this._map);
  }

}

class HashArrayMappedTrieMap {
  // Because hamt.empty is not a function there is no way to introduce type
  // parameters on it, so empty is typed as HAMTPlusMap<string, mixed>.
  // $FlowIssue
  constructor(existing) {
    _defineProperty$2(this, "_hamt", hamt_1.empty.beginMutation());

    if (existing instanceof HashArrayMappedTrieMap) {
      const h = existing._hamt.endMutation();

      existing._hamt = h.beginMutation();
      this._hamt = h.beginMutation();
    } else if (existing) {
      for (const [k, v] of existing.entries()) {
        this._hamt.set(k, v);
      }
    }
  }

  keys() {
    return this._hamt.keys();
  }

  entries() {
    return this._hamt.entries();
  }

  get(k) {
    return this._hamt.get(k);
  }

  has(k) {
    return this._hamt.has(k);
  }

  set(k, v) {
    this._hamt.set(k, v);

    return this;
  }

  delete(k) {
    this._hamt.delete(k);

    return this;
  }

  clone() {
    return persistentMap(this);
  }

  toMap() {
    return new Map(this._hamt);
  }

}

function persistentMap(existing) {
  if (Recoil_gkx('recoil_hamt_2020')) {
    return new HashArrayMappedTrieMap(existing);
  } else {
    return new BuiltInMap(existing);
  }
}

var Recoil_PersistentMap = {
  persistentMap
};

var Recoil_PersistentMap_1 = Recoil_PersistentMap.persistentMap;

var Recoil_PersistentMap$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  persistentMap: Recoil_PersistentMap_1
});

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */
/**
 * Returns a set containing all of the values from the first set that are not
 * present in any of the subsequent sets.
 *
 * Note: this is written procedurally (i.e., without filterSet) for performant
 * use in tight loops.
 */

function differenceSets(set, ...setsWithValuesToRemove) {
  const ret = new Set();

  FIRST: for (const value of set) {
    for (const otherSet of setsWithValuesToRemove) {
      if (otherSet.has(value)) {
        continue FIRST;
      }
    }

    ret.add(value);
  }

  return ret;
}

var Recoil_differenceSets = differenceSets;

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */
/**
 * Returns a new Map object with the same keys as the original, but with the
 * values replaced with the output of the given callback function.
 */

function mapMap(map, callback) {
  const result = new Map();
  map.forEach((value, key) => {
    result.set(key, callback(value, key));
  });
  return result;
}

var Recoil_mapMap = mapMap;

function makeGraph() {
  return {
    nodeDeps: new Map(),
    nodeToNodeSubscriptions: new Map()
  };
}

function cloneGraph(graph) {
  return {
    nodeDeps: Recoil_mapMap(graph.nodeDeps, s => new Set(s)),
    nodeToNodeSubscriptions: Recoil_mapMap(graph.nodeToNodeSubscriptions, s => new Set(s))
  };
} // Note that this overwrites the deps of existing nodes, rather than unioning
// the new deps with the old deps.


function mergeDepsIntoGraph(key, newDeps, graph, // If olderGraph is given then we will not overwrite changes made to the given
// graph compared with olderGraph:
olderGraph) {
  const {
    nodeDeps,
    nodeToNodeSubscriptions
  } = graph;
  const oldDeps = nodeDeps.get(key);

  if (oldDeps && olderGraph && oldDeps !== olderGraph.nodeDeps.get(key)) {
    return;
  } // Update nodeDeps:


  nodeDeps.set(key, newDeps); // Add new deps to nodeToNodeSubscriptions:

  const addedDeps = oldDeps == null ? newDeps : Recoil_differenceSets(newDeps, oldDeps);

  for (const dep of addedDeps) {
    if (!nodeToNodeSubscriptions.has(dep)) {
      nodeToNodeSubscriptions.set(dep, new Set());
    }

    const existing = Recoil_nullthrows(nodeToNodeSubscriptions.get(dep));
    existing.add(key);
  } // Remove removed deps from nodeToNodeSubscriptions:


  if (oldDeps) {
    const removedDeps = Recoil_differenceSets(oldDeps, newDeps);

    for (const dep of removedDeps) {
      if (!nodeToNodeSubscriptions.has(dep)) {
        return;
      }

      const existing = Recoil_nullthrows(nodeToNodeSubscriptions.get(dep));
      existing.delete(key);

      if (existing.size === 0) {
        nodeToNodeSubscriptions.delete(dep);
      }
    }
  }
}

function saveDepsToStore(key, deps, store, version) {
  var _storeState$nextTree, _storeState$previousT, _storeState$previousT2, _storeState$previousT3;

  const storeState = store.getState();

  if (!(version === storeState.currentTree.version || version === ((_storeState$nextTree = storeState.nextTree) === null || _storeState$nextTree === void 0 ? void 0 : _storeState$nextTree.version) || version === ((_storeState$previousT = storeState.previousTree) === null || _storeState$previousT === void 0 ? void 0 : _storeState$previousT.version))) {
    Recoil_recoverableViolation('Tried to save dependencies to a discarded tree');
  } // Merge the dependencies discovered into the store's dependency map
  // for the version that was read:


  const graph = store.getGraph(version);
  mergeDepsIntoGraph(key, deps, graph); // If this version is not the latest version, also write these dependencies
  // into later versions if they don't already have their own:

  if (version === ((_storeState$previousT2 = storeState.previousTree) === null || _storeState$previousT2 === void 0 ? void 0 : _storeState$previousT2.version)) {
    const currentGraph = store.getGraph(storeState.currentTree.version);
    mergeDepsIntoGraph(key, deps, currentGraph, graph);
  }

  if (version === ((_storeState$previousT3 = storeState.previousTree) === null || _storeState$previousT3 === void 0 ? void 0 : _storeState$previousT3.version) || version === storeState.currentTree.version) {
    var _storeState$nextTree2;

    const nextVersion = (_storeState$nextTree2 = storeState.nextTree) === null || _storeState$nextTree2 === void 0 ? void 0 : _storeState$nextTree2.version;

    if (nextVersion !== undefined) {
      const nextGraph = store.getGraph(nextVersion);
      mergeDepsIntoGraph(key, deps, nextGraph, graph);
    }
  }
}

var Recoil_Graph = {
  cloneGraph,
  graph: makeGraph,
  saveDepsToStore
};

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */

let nextTreeStateVersion = 0;

const getNextTreeStateVersion = () => nextTreeStateVersion++;

let nextStoreID = 0;

const getNextStoreID = () => nextStoreID++;

let nextComponentID = 0;

const getNextComponentID = () => nextComponentID++;

var Recoil_Keys = {
  getNextTreeStateVersion,
  getNextStoreID,
  getNextComponentID
};

const {
  persistentMap: persistentMap$1
} = Recoil_PersistentMap$1;

const {
  graph
} = Recoil_Graph;

const {
  getNextTreeStateVersion: getNextTreeStateVersion$1
} = Recoil_Keys;

function makeEmptyTreeState() {
  const version = getNextTreeStateVersion$1();
  return {
    version,
    stateID: version,
    transactionMetadata: {},
    dirtyAtoms: new Set(),
    atomValues: persistentMap$1(),
    nonvalidatedAtoms: persistentMap$1()
  };
}

function makeEmptyStoreState() {
  const currentTree = makeEmptyTreeState();
  return {
    currentTree,
    nextTree: null,
    previousTree: null,
    commitDepth: 0,
    knownAtoms: new Set(),
    knownSelectors: new Set(),
    transactionSubscriptions: new Map(),
    nodeTransactionSubscriptions: new Map(),
    nodeToComponentSubscriptions: new Map(),
    queuedComponentCallbacks_DEPRECATED: [],
    suspendedComponentResolvers: new Set(),
    graphsByVersion: new Map().set(currentTree.version, graph()),
    retention: {
      referenceCounts: new Map(),
      nodesRetainedByZone: new Map(),
      retainablesToCheckForRelease: new Set()
    },
    nodeCleanupFunctions: new Map()
  };
}

var Recoil_State = {
  makeEmptyTreeState,
  makeEmptyStoreState,
  getNextTreeStateVersion: getNextTreeStateVersion$1
};

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */

class RetentionZone {}

function retentionZone() {
  return new RetentionZone();
}

var Recoil_RetentionZone = {
  RetentionZone,
  retentionZone
};

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Utilities for working with built-in Maps and Sets without mutating them.
 *
 * 
 * @format
 * @oncall recoil
 */

function setByAddingToSet(set, v) {
  const next = new Set(set);
  next.add(v);
  return next;
}

function setByDeletingFromSet(set, v) {
  const next = new Set(set);
  next.delete(v);
  return next;
}

function mapBySettingInMap(map, k, v) {
  const next = new Map(map);
  next.set(k, v);
  return next;
}

function mapByUpdatingInMap(map, k, updater) {
  const next = new Map(map);
  next.set(k, updater(next.get(k)));
  return next;
}

function mapByDeletingFromMap(map, k) {
  const next = new Map(map);
  next.delete(k);
  return next;
}

function mapByDeletingMultipleFromMap(map, ks) {
  const next = new Map(map);
  ks.forEach(k => next.delete(k));
  return next;
}

var Recoil_CopyOnWrite = {
  setByAddingToSet,
  setByDeletingFromSet,
  mapBySettingInMap,
  mapByUpdatingInMap,
  mapByDeletingFromMap,
  mapByDeletingMultipleFromMap
};

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */
/**
 * Creates a new iterable whose output is generated by passing the input
 * iterable's values through the filter function.
 */

function* filterIterable(iterable, predicate) {
  // Use generator to create iterable/iterator
  let index = 0;

  for (const value of iterable) {
    if (predicate(value, index++)) {
      yield value;
    }
  }
}

var Recoil_filterIterable = filterIterable;

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */
/**
 * Return a proxy object based on the provided base and factories objects.
 * The proxy will include all properties of the base object as-is.
 * The factories object contains callbacks to obtain the values of the properies
 * for its keys.
 *
 * This is useful for providing users an object where some properties may be
 * lazily computed only on first access.
 */
// $FlowIssue[unclear-type]

function lazyProxy(base, factories) {
  const proxy = new Proxy(base, {
    // Compute and cache lazy property if not already done.
    get: (target, prop) => {
      if (!(prop in target) && prop in factories) {
        target[prop] = factories[prop]();
      }

      return target[prop];
    },
    // This method allows user to iterate keys as normal
    ownKeys: target => {

      return Object.keys(target);
    }
  }); // $FlowIssue[incompatible-return]

  return proxy;
}

var Recoil_lazyProxy = lazyProxy;

const {
  getNode: getNode$1,
  getNodeMaybe: getNodeMaybe$1,
  recoilValuesForKeys: recoilValuesForKeys$1
} = Recoil_Node;

const {
  RetentionZone: RetentionZone$1
} = Recoil_RetentionZone;

const {
  setByAddingToSet: setByAddingToSet$1
} = Recoil_CopyOnWrite;







 // flowlint-next-line unclear-type:off


const emptySet = Object.freeze(new Set());

class ReadOnlyRecoilValueError extends Error {}

function initializeRetentionForNode(store, nodeKey, retainedBy) {
  if (!Recoil_gkx('recoil_memory_managament_2020')) {
    return () => undefined;
  }

  const {
    nodesRetainedByZone
  } = store.getState().retention;

  function addToZone(zone) {
    let set = nodesRetainedByZone.get(zone);

    if (!set) {
      nodesRetainedByZone.set(zone, set = new Set());
    }

    set.add(nodeKey);
  }

  if (retainedBy instanceof RetentionZone$1) {
    addToZone(retainedBy);
  } else if (Array.isArray(retainedBy)) {
    for (const zone of retainedBy) {
      addToZone(zone);
    }
  }

  return () => {
    if (!Recoil_gkx('recoil_memory_managament_2020')) {
      return;
    }

    const {
      retention
    } = store.getState();

    function deleteFromZone(zone) {
      const set = retention.nodesRetainedByZone.get(zone);
      set === null || set === void 0 ? void 0 : set.delete(nodeKey);

      if (set && set.size === 0) {
        retention.nodesRetainedByZone.delete(zone);
      }
    }

    if (retainedBy instanceof RetentionZone$1) {
      deleteFromZone(retainedBy);
    } else if (Array.isArray(retainedBy)) {
      for (const zone of retainedBy) {
        deleteFromZone(zone);
      }
    }
  };
}

function initializeNodeIfNewToStore(store, treeState, key, trigger) {
  const storeState = store.getState();

  if (storeState.nodeCleanupFunctions.has(key)) {
    return;
  }

  const node = getNode$1(key);
  const retentionCleanup = initializeRetentionForNode(store, key, node.retainedBy);
  const nodeCleanup = node.init(store, treeState, trigger);
  storeState.nodeCleanupFunctions.set(key, () => {
    nodeCleanup();
    retentionCleanup();
  });
}

function initializeNode(store, key, trigger) {
  initializeNodeIfNewToStore(store, store.getState().currentTree, key, trigger);
}

function cleanUpNode(store, key) {
  var _state$nodeCleanupFun;

  const state = store.getState();
  (_state$nodeCleanupFun = state.nodeCleanupFunctions.get(key)) === null || _state$nodeCleanupFun === void 0 ? void 0 : _state$nodeCleanupFun();
  state.nodeCleanupFunctions.delete(key);
} // Get the current value loadable of a node and update the state.
// Update dependencies and subscriptions for selectors.
// Update saved value validation for atoms.


function getNodeLoadable(store, state, key) {
  initializeNodeIfNewToStore(store, state, key, 'get');
  return getNode$1(key).get(store, state);
} // Peek at the current value loadable for a node without any evaluation or state change


function peekNodeLoadable(store, state, key) {
  return getNode$1(key).peek(store, state);
} // Write value directly to state bypassing the Node interface as the node
// definitions may not have been loaded yet when processing the initial snapshot.


function setUnvalidatedAtomValue_DEPRECATED(state, key, newValue) {
  var _node$invalidate;

  const node = getNodeMaybe$1(key);
  node === null || node === void 0 ? void 0 : (_node$invalidate = node.invalidate) === null || _node$invalidate === void 0 ? void 0 : _node$invalidate.call(node, state);
  return { ...state,
    atomValues: state.atomValues.clone().delete(key),
    nonvalidatedAtoms: state.nonvalidatedAtoms.clone().set(key, newValue),
    dirtyAtoms: setByAddingToSet$1(state.dirtyAtoms, key)
  };
} // Return the discovered dependencies and values to be written by setting
// a node value. (Multiple values may be written due to selectors getting to
// set upstreams; deps may be discovered because of reads in updater functions.)


function setNodeValue(store, state, key, newValue) {
  const node = getNode$1(key);

  if (node.set == null) {
    throw new ReadOnlyRecoilValueError(`Attempt to set read-only RecoilValue: ${key}`);
  }

  const set = node.set; // so flow doesn't lose the above refinement.

  initializeNodeIfNewToStore(store, state, key, 'set');
  return set(store, state, newValue);
}

function peekNodeInfo(store, state, key) {
  const storeState = store.getState();
  const graph = store.getGraph(state.version);
  const type = getNode$1(key).nodeType;
  return Recoil_lazyProxy({
    type
  }, {
    // $FlowFixMe[underconstrained-implicit-instantiation]
    loadable: () => peekNodeLoadable(store, state, key),
    isActive: () => storeState.knownAtoms.has(key) || storeState.knownSelectors.has(key),
    isSet: () => type === 'selector' ? false : state.atomValues.has(key),
    isModified: () => state.dirtyAtoms.has(key),
    // Report current dependencies.  If the node hasn't been evaluated, then
    // dependencies may be missing based on the current state.
    deps: () => {
      var _graph$nodeDeps$get;

      return recoilValuesForKeys$1((_graph$nodeDeps$get = graph.nodeDeps.get(key)) !== null && _graph$nodeDeps$get !== void 0 ? _graph$nodeDeps$get : []);
    },
    // Reports all "current" subscribers.  Evaluating other nodes or
    // previous in-progress async evaluations may introduce new subscribers.
    subscribers: () => {
      var _storeState$nodeToCom, _storeState$nodeToCom2;

      return {
        nodes: recoilValuesForKeys$1(Recoil_filterIterable(getDownstreamNodes(store, state, new Set([key])), nodeKey => nodeKey !== key)),
        components: Recoil_mapIterable((_storeState$nodeToCom = (_storeState$nodeToCom2 = storeState.nodeToComponentSubscriptions.get(key)) === null || _storeState$nodeToCom2 === void 0 ? void 0 : _storeState$nodeToCom2.values()) !== null && _storeState$nodeToCom !== void 0 ? _storeState$nodeToCom : [], ([name]) => ({
          name
        }))
      };
    }
  });
} // Find all of the recursively dependent nodes


function getDownstreamNodes(store, state, keys) {
  const visitedNodes = new Set();
  const visitingNodes = Array.from(keys);
  const graph = store.getGraph(state.version);

  for (let key = visitingNodes.pop(); key; key = visitingNodes.pop()) {
    var _graph$nodeToNodeSubs;

    visitedNodes.add(key);
    const subscribedNodes = (_graph$nodeToNodeSubs = graph.nodeToNodeSubscriptions.get(key)) !== null && _graph$nodeToNodeSubs !== void 0 ? _graph$nodeToNodeSubs : emptySet;

    for (const downstreamNode of subscribedNodes) {
      if (!visitedNodes.has(downstreamNode)) {
        visitingNodes.push(downstreamNode);
      }
    }
  }

  return visitedNodes;
}

var Recoil_FunctionalCore = {
  getNodeLoadable,
  peekNodeLoadable,
  setNodeValue,
  initializeNode,
  cleanUpNode,
  setUnvalidatedAtomValue_DEPRECATED,
  peekNodeInfo,
  getDownstreamNodes
};

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */

let _invalidateMemoizedSnapshot = null;

function setInvalidateMemoizedSnapshot(invalidate) {
  _invalidateMemoizedSnapshot = invalidate;
}

function invalidateMemoizedSnapshot() {
  var _invalidateMemoizedSn;

  (_invalidateMemoizedSn = _invalidateMemoizedSnapshot) === null || _invalidateMemoizedSn === void 0 ? void 0 : _invalidateMemoizedSn();
}

var Recoil_SnapshotCache = {
  setInvalidateMemoizedSnapshot,
  invalidateMemoizedSnapshot
};

const {
  getDownstreamNodes: getDownstreamNodes$1,
  getNodeLoadable: getNodeLoadable$1,
  setNodeValue: setNodeValue$1
} = Recoil_FunctionalCore;

const {
  getNextComponentID: getNextComponentID$1
} = Recoil_Keys;

const {
  getNode: getNode$2,
  getNodeMaybe: getNodeMaybe$2
} = Recoil_Node;

const {
  DefaultValue: DefaultValue$1
} = Recoil_Node;

const {
  reactMode: reactMode$1
} = Recoil_ReactMode;

const {
  AbstractRecoilValue: AbstractRecoilValue$1,
  RecoilState: RecoilState$1,
  RecoilValueReadOnly: RecoilValueReadOnly$1,
  isRecoilValue: isRecoilValue$1
} = Recoil_RecoilValue$1;

const {
  invalidateMemoizedSnapshot: invalidateMemoizedSnapshot$1
} = Recoil_SnapshotCache;







function getRecoilValueAsLoadable(store, {
  key
}, treeState = store.getState().currentTree) {
  var _storeState$nextTree, _storeState$previousT;

  // Reading from an older tree can cause bugs because the dependencies that we
  // discover during the read are lost.
  const storeState = store.getState();

  if (!(treeState.version === storeState.currentTree.version || treeState.version === ((_storeState$nextTree = storeState.nextTree) === null || _storeState$nextTree === void 0 ? void 0 : _storeState$nextTree.version) || treeState.version === ((_storeState$previousT = storeState.previousTree) === null || _storeState$previousT === void 0 ? void 0 : _storeState$previousT.version))) {
    Recoil_recoverableViolation('Tried to read from a discarded tree');
  }

  const loadable = getNodeLoadable$1(store, treeState, key);

  if (loadable.state === 'loading') {
    loadable.contents.catch(() => {
      /**
       * HACK: intercept thrown error here to prevent an uncaught promise exception. Ideally this would happen closer to selector
       * execution (perhaps introducing a new ERROR class to be resolved by async selectors that are in an error state)
       */
      return;
    });
  }

  return loadable;
}

function applyAtomValueWrites(atomValues, writes) {
  const result = atomValues.clone();
  writes.forEach((v, k) => {
    if (v.state === 'hasValue' && v.contents instanceof DefaultValue$1) {
      result.delete(k);
    } else {
      result.set(k, v);
    }
  });
  return result;
}

function valueFromValueOrUpdater(store, state, {
  key
}, valueOrUpdater) {
  if (typeof valueOrUpdater === 'function') {
    // Updater form: pass in the current value. Throw if the current value
    // is unavailable (namely when updating an async selector that's
    // pending or errored):
    const current = getNodeLoadable$1(store, state, key);

    if (current.state === 'loading') {
      const msg = `Tried to set atom or selector "${key}" using an updater function while the current state is pending, this is not currently supported.`;
      Recoil_recoverableViolation(msg);
      throw Recoil_err(msg);
    } else if (current.state === 'hasError') {
      throw current.contents;
    } // T itself may be a function, so our refinement is not sufficient:


    return valueOrUpdater(current.contents); // flowlint-line unclear-type:off
  } else {
    return valueOrUpdater;
  }
}

function applyAction(store, state, action) {
  if (action.type === 'set') {
    const {
      recoilValue,
      valueOrUpdater
    } = action;
    const newValue = valueFromValueOrUpdater(store, state, recoilValue, valueOrUpdater);
    const writes = setNodeValue$1(store, state, recoilValue.key, newValue);

    for (const [key, loadable] of writes.entries()) {
      writeLoadableToTreeState(state, key, loadable);
    }
  } else if (action.type === 'setLoadable') {
    const {
      recoilValue: {
        key
      },
      loadable
    } = action;
    writeLoadableToTreeState(state, key, loadable);
  } else if (action.type === 'markModified') {
    const {
      recoilValue: {
        key
      }
    } = action;
    state.dirtyAtoms.add(key);
  } else if (action.type === 'setUnvalidated') {
    var _node$invalidate;

    // Write value directly to state bypassing the Node interface as the node
    // definitions may not have been loaded yet when processing the initial snapshot.
    const {
      recoilValue: {
        key
      },
      unvalidatedValue
    } = action;
    const node = getNodeMaybe$2(key);
    node === null || node === void 0 ? void 0 : (_node$invalidate = node.invalidate) === null || _node$invalidate === void 0 ? void 0 : _node$invalidate.call(node, state);
    state.atomValues.delete(key);
    state.nonvalidatedAtoms.set(key, unvalidatedValue);
    state.dirtyAtoms.add(key);
  } else {
    Recoil_recoverableViolation(`Unknown action ${action.type}`);
  }
}

function writeLoadableToTreeState(state, key, loadable) {
  if (loadable.state === 'hasValue' && loadable.contents instanceof DefaultValue$1) {
    state.atomValues.delete(key);
  } else {
    state.atomValues.set(key, loadable);
  }

  state.dirtyAtoms.add(key);
  state.nonvalidatedAtoms.delete(key);
}

function applyActionsToStore(store, actions) {
  store.replaceState(state => {
    const newState = copyTreeState(state);

    for (const action of actions) {
      applyAction(store, newState, action);
    }

    invalidateDownstreams(store, newState);
    invalidateMemoizedSnapshot$1();
    return newState;
  });
}

function queueOrPerformStateUpdate(store, action) {
  if (batchStack.length) {
    const actionsByStore = batchStack[batchStack.length - 1];
    let actions = actionsByStore.get(store);

    if (!actions) {
      actionsByStore.set(store, actions = []);
    }

    actions.push(action);
  } else {
    applyActionsToStore(store, [action]);
  }
}

const batchStack = [];

function batchStart() {
  const actionsByStore = new Map();
  batchStack.push(actionsByStore);
  return () => {
    for (const [store, actions] of actionsByStore) {
      applyActionsToStore(store, actions);
    }

    const popped = batchStack.pop();

    if (popped !== actionsByStore) {
      Recoil_recoverableViolation('Incorrect order of batch popping');
    }
  };
}

function copyTreeState(state) {
  return { ...state,
    atomValues: state.atomValues.clone(),
    nonvalidatedAtoms: state.nonvalidatedAtoms.clone(),
    dirtyAtoms: new Set(state.dirtyAtoms)
  };
}

function invalidateDownstreams(store, state) {
  // Inform any nodes that were changed or downstream of changes so that they
  // can clear out any caches as needed due to the update:
  const downstreams = getDownstreamNodes$1(store, state, state.dirtyAtoms);

  for (const key of downstreams) {
    var _getNodeMaybe, _getNodeMaybe$invalid;

    (_getNodeMaybe = getNodeMaybe$2(key)) === null || _getNodeMaybe === void 0 ? void 0 : (_getNodeMaybe$invalid = _getNodeMaybe.invalidate) === null || _getNodeMaybe$invalid === void 0 ? void 0 : _getNodeMaybe$invalid.call(_getNodeMaybe, state);
  }
}

function setRecoilValue(store, recoilValue, valueOrUpdater) {
  queueOrPerformStateUpdate(store, {
    type: 'set',
    recoilValue,
    valueOrUpdater
  });
}

function setRecoilValueLoadable(store, recoilValue, loadable) {
  if (loadable instanceof DefaultValue$1) {
    return setRecoilValue(store, recoilValue, loadable);
  }

  queueOrPerformStateUpdate(store, {
    type: 'setLoadable',
    recoilValue,
    loadable: loadable
  });
}

function markRecoilValueModified(store, recoilValue) {
  queueOrPerformStateUpdate(store, {
    type: 'markModified',
    recoilValue
  });
}

function setUnvalidatedRecoilValue(store, recoilValue, unvalidatedValue) {
  queueOrPerformStateUpdate(store, {
    type: 'setUnvalidated',
    recoilValue,
    unvalidatedValue
  });
}

function subscribeToRecoilValue(store, {
  key
}, callback, componentDebugName = null) {
  const subID = getNextComponentID$1();
  const storeState = store.getState();

  if (!storeState.nodeToComponentSubscriptions.has(key)) {
    storeState.nodeToComponentSubscriptions.set(key, new Map());
  }

  Recoil_nullthrows(storeState.nodeToComponentSubscriptions.get(key)).set(subID, [componentDebugName !== null && componentDebugName !== void 0 ? componentDebugName : '<not captured>', callback]); // Handle the case that, during the same tick that we are subscribing, an atom
  // has been updated by some effect handler. Otherwise we will miss the update.

  const mode = reactMode$1();

  if (mode.early && (mode.mode === 'LEGACY' || mode.mode === 'MUTABLE_SOURCE')) {
    const nextTree = store.getState().nextTree;

    if (nextTree && nextTree.dirtyAtoms.has(key)) {
      callback(nextTree);
    }
  }

  return {
    release: () => {
      const releaseStoreState = store.getState();
      const subs = releaseStoreState.nodeToComponentSubscriptions.get(key);

      if (subs === undefined || !subs.has(subID)) {
        Recoil_recoverableViolation(`Subscription missing at release time for atom ${key}. This is a bug in Recoil.`);
        return;
      }

      subs.delete(subID);

      if (subs.size === 0) {
        releaseStoreState.nodeToComponentSubscriptions.delete(key);
      }
    }
  };
}

function refreshRecoilValue(store, recoilValue) {
  var _node$clearCache;

  const {
    currentTree
  } = store.getState();
  const node = getNode$2(recoilValue.key);
  (_node$clearCache = node.clearCache) === null || _node$clearCache === void 0 ? void 0 : _node$clearCache.call(node, store, currentTree);
}

var Recoil_RecoilValueInterface = {
  RecoilValueReadOnly: RecoilValueReadOnly$1,
  AbstractRecoilValue: AbstractRecoilValue$1,
  RecoilState: RecoilState$1,
  getRecoilValueAsLoadable,
  setRecoilValue,
  setRecoilValueLoadable,
  markRecoilValueModified,
  setUnvalidatedRecoilValue,
  subscribeToRecoilValue,
  isRecoilValue: isRecoilValue$1,
  applyAtomValueWrites,
  // TODO Remove export when deprecating initialStoreState_DEPRECATED in RecoilRoot
  batchStart,
  writeLoadableToTreeState,
  invalidateDownstreams,
  copyTreeState,
  refreshRecoilValue
};

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */
/**
 * The someSet() method tests whether some elements in the given Set pass the
 * test implemented by the provided function.
 */

function someSet(set, callback, context) {
  const iterator = set.entries();
  let current = iterator.next();

  while (!current.done) {
    const entry = current.value;

    if (callback.call(context, entry[1], entry[0], set)) {
      return true;
    }

    current = iterator.next();
  }

  return false;
}

var Recoil_someSet = someSet;

const {
  cleanUpNode: cleanUpNode$1
} = Recoil_FunctionalCore;

const {
  deleteNodeConfigIfPossible: deleteNodeConfigIfPossible$1,
  getNode: getNode$3
} = Recoil_Node;

const {
  RetentionZone: RetentionZone$2
} = Recoil_RetentionZone;







 // Components that aren't mounted after suspending for this long will be assumed
// to be discarded and their resources released.


const SUSPENSE_TIMEOUT_MS = 120000;
const emptySet$1 = new Set();

function releaseRetainablesNowOnCurrentTree(store, retainables) {
  const storeState = store.getState();
  const treeState = storeState.currentTree;

  if (storeState.nextTree) {
    Recoil_recoverableViolation('releaseNodesNowOnCurrentTree should only be called at the end of a batch');
    return; // leak memory rather than erase something that's about to be used.
  }

  const nodes = new Set();

  for (const r of retainables) {
    if (r instanceof RetentionZone$2) {
      for (const n of nodesRetainedByZone(storeState, r)) {
        nodes.add(n);
      }
    } else {
      nodes.add(r);
    }
  }

  const releasableNodes = findReleasableNodes(store, nodes);

  for (const node of releasableNodes) {
    releaseNode(store, treeState, node);
  }
}

function findReleasableNodes(store, searchFromNodes) {
  const storeState = store.getState();
  const treeState = storeState.currentTree;
  const graph = store.getGraph(treeState.version);
  const releasableNodes = new Set(); // mutated to collect answer

  const nonReleasableNodes = new Set();
  findReleasableNodesInner(searchFromNodes);
  return releasableNodes;

  function findReleasableNodesInner(searchFromNodes) {
    const releasableNodesFoundThisIteration = new Set();
    const downstreams = getDownstreamNodesInTopologicalOrder(store, treeState, searchFromNodes, releasableNodes, // don't descend into these
    nonReleasableNodes // don't descend into these
    ); // Find which of the downstream nodes are releasable and which are not:

    for (const node of downstreams) {
      var _storeState$retention;

      // Not releasable if configured to be retained forever:
      if (getNode$3(node).retainedBy === 'recoilRoot') {
        nonReleasableNodes.add(node);
        continue;
      } // Not releasable if retained directly by a component:


      if (((_storeState$retention = storeState.retention.referenceCounts.get(node)) !== null && _storeState$retention !== void 0 ? _storeState$retention : 0) > 0) {
        nonReleasableNodes.add(node);
        continue;
      } // Not releasable if retained by a zone:


      if (zonesThatCouldRetainNode(node).some(z => storeState.retention.referenceCounts.get(z))) {
        nonReleasableNodes.add(node);
        continue;
      } // Not releasable if it has a non-releasable child (which will already be in
      // nonReleasableNodes because we are going in topological order):


      const nodeChildren = graph.nodeToNodeSubscriptions.get(node);

      if (nodeChildren && Recoil_someSet(nodeChildren, child => nonReleasableNodes.has(child))) {
        nonReleasableNodes.add(node);
        continue;
      }

      releasableNodes.add(node);
      releasableNodesFoundThisIteration.add(node);
    } // If we found any releasable nodes, we need to walk UP from those nodes to
    // find whether their parents can now be released as well:


    const parents = new Set();

    for (const node of releasableNodesFoundThisIteration) {
      for (const parent of (_graph$nodeDeps$get = graph.nodeDeps.get(node)) !== null && _graph$nodeDeps$get !== void 0 ? _graph$nodeDeps$get : emptySet$1) {
        var _graph$nodeDeps$get;

        if (!releasableNodes.has(parent)) {
          parents.add(parent);
        }
      }
    }

    if (parents.size) {
      findReleasableNodesInner(parents);
    }
  }
} // Children before parents


function getDownstreamNodesInTopologicalOrder(store, treeState, nodes, // Mutable set is destroyed in place
doNotDescendInto1, doNotDescendInto2) {
  const graph = store.getGraph(treeState.version);
  const answer = [];
  const visited = new Set();

  while (nodes.size > 0) {
    visit(Recoil_nullthrows(nodes.values().next().value));
  }

  return answer;

  function visit(node) {
    if (doNotDescendInto1.has(node) || doNotDescendInto2.has(node)) {
      nodes.delete(node);
      return;
    }

    if (visited.has(node)) {
      return;
    }

    const children = graph.nodeToNodeSubscriptions.get(node);

    if (children) {
      for (const child of children) {
        visit(child);
      }
    }

    visited.add(node);
    nodes.delete(node);
    answer.push(node);
  }
}

function releaseNode(store, treeState, node) {
  if (!Recoil_gkx('recoil_memory_managament_2020')) {
    return;
  } // Atom effects, in-closure caches, etc.:


  cleanUpNode$1(store, node); // Delete from store state:

  const storeState = store.getState();
  storeState.knownAtoms.delete(node);
  storeState.knownSelectors.delete(node);
  storeState.nodeTransactionSubscriptions.delete(node);
  storeState.retention.referenceCounts.delete(node);
  const zones = zonesThatCouldRetainNode(node);

  for (const zone of zones) {
    var _storeState$retention2;

    (_storeState$retention2 = storeState.retention.nodesRetainedByZone.get(zone)) === null || _storeState$retention2 === void 0 ? void 0 : _storeState$retention2.delete(node);
  } // Note that we DO NOT delete from nodeToComponentSubscriptions because this
  // already happens when the last component that was retaining the node unmounts,
  // and this could happen either before or after that.
  // Delete from TreeState and dep graph:


  treeState.atomValues.delete(node);
  treeState.dirtyAtoms.delete(node);
  treeState.nonvalidatedAtoms.delete(node);
  const graph = storeState.graphsByVersion.get(treeState.version);

  if (graph) {
    const deps = graph.nodeDeps.get(node);

    if (deps !== undefined) {
      graph.nodeDeps.delete(node);

      for (const dep of deps) {
        var _graph$nodeToNodeSubs;

        (_graph$nodeToNodeSubs = graph.nodeToNodeSubscriptions.get(dep)) === null || _graph$nodeToNodeSubs === void 0 ? void 0 : _graph$nodeToNodeSubs.delete(node);
      }
    } // No need to delete sub's deps as there should be no subs at this point.
    // But an invariant would require deleting nodes in topological order.


    graph.nodeToNodeSubscriptions.delete(node);
  } // Node config (for family members only as their configs can be recreated, and
  // only if they are not retained within any other Stores):


  deleteNodeConfigIfPossible$1(node);
}

function nodesRetainedByZone(storeState, zone) {
  var _storeState$retention3;

  return (_storeState$retention3 = storeState.retention.nodesRetainedByZone.get(zone)) !== null && _storeState$retention3 !== void 0 ? _storeState$retention3 : emptySet$1;
}

function zonesThatCouldRetainNode(node) {
  const retainedBy = getNode$3(node).retainedBy;

  if (retainedBy === undefined || retainedBy === 'components' || retainedBy === 'recoilRoot') {
    return [];
  } else if (retainedBy instanceof RetentionZone$2) {
    return [retainedBy];
  } else {
    return retainedBy; // it's an array of zones
  }
}

function scheduleOrPerformPossibleReleaseOfRetainable(store, retainable) {
  const state = store.getState();

  if (state.nextTree) {
    state.retention.retainablesToCheckForRelease.add(retainable);
  } else {
    releaseRetainablesNowOnCurrentTree(store, new Set([retainable]));
  }
}

function updateRetainCount(store, retainable, delta) {
  var _map$get;

  if (!Recoil_gkx('recoil_memory_managament_2020')) {
    return;
  }

  const map = store.getState().retention.referenceCounts;
  const newCount = ((_map$get = map.get(retainable)) !== null && _map$get !== void 0 ? _map$get : 0) + delta;

  if (newCount === 0) {
    updateRetainCountToZero(store, retainable);
  } else {
    map.set(retainable, newCount);
  }
}

function updateRetainCountToZero(store, retainable) {
  if (!Recoil_gkx('recoil_memory_managament_2020')) {
    return;
  }

  const map = store.getState().retention.referenceCounts;
  map.delete(retainable);
  scheduleOrPerformPossibleReleaseOfRetainable(store, retainable);
}

function releaseScheduledRetainablesNow(store) {
  if (!Recoil_gkx('recoil_memory_managament_2020')) {
    return;
  }

  const state = store.getState();
  releaseRetainablesNowOnCurrentTree(store, state.retention.retainablesToCheckForRelease);
  state.retention.retainablesToCheckForRelease.clear();
}

function retainedByOptionWithDefault(r) {
  // The default will change from 'recoilRoot' to 'components' in the future.
  return r === undefined ? 'recoilRoot' : r;
}

var Recoil_Retention = {
  SUSPENSE_TIMEOUT_MS,
  updateRetainCount,
  updateRetainCountToZero,
  releaseScheduledRetainablesNow,
  retainedByOptionWithDefault
};

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * This is to export esstiential functions from react-dom
 * for our web build
 *
 * 
 * @format
 * @oncall recoil
 */
const {
  unstable_batchedUpdates
} = ReactDOM;

var ReactBatchedUpdates = {
  unstable_batchedUpdates
};

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * This is to export esstiential functions from react-dom
 * for our web build
 *
 * 
 * @format
 * @oncall recoil
 */
// @fb-only: const {unstable_batchedUpdates} = require('ReactDOMComet');
// prettier-ignore
const {
  unstable_batchedUpdates: unstable_batchedUpdates$1
} = ReactBatchedUpdates; // @oss-only


var Recoil_ReactBatchedUpdates = {
  unstable_batchedUpdates: unstable_batchedUpdates$1
};

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */
const {
  batchStart: batchStart$1
} = Recoil_RecoilValueInterface;

const {
  unstable_batchedUpdates: unstable_batchedUpdates$2
} = Recoil_ReactBatchedUpdates; // flowlint-next-line unclear-type:off


/*
 * During SSR, unstable_batchedUpdates may be undefined so this
 * falls back to a basic function that executes the batch
 */
let batcher = unstable_batchedUpdates$2 || (batchFn => batchFn());
/**
 * Sets the provided batcher function as the batcher function used by Recoil.
 *
 * Set the batcher to a custom batcher for your renderer,
 * if you use a renderer other than React DOM or React Native.
 */


const setBatcher = newBatcher => {
  batcher = newBatcher;
};
/**
 * Returns the current batcher function.
 */


const getBatcher = () => batcher;
/**
 * Calls the current batcher function and passes the
 * provided callback function.
 */


const batchUpdates = callback => {
  batcher(() => {
    let batchEnd = () => undefined;

    try {
      batchEnd = batchStart$1();
      callback();
    } finally {
      batchEnd();
    }
  });
};

var Recoil_Batching = {
  getBatcher,
  setBatcher,
  batchUpdates
};

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */
/**
 * Combines multiple Iterables into a single Iterable.
 * Traverses the input Iterables in the order provided and maintains the order
 * of their elements.
 *
 * Example:
 * ```
 * const r = Array.from(concatIterables(['a', 'b'], ['c'], ['d', 'e', 'f']));
 * r == ['a', 'b', 'c', 'd', 'e', 'f'];
 * ```
 */

function* concatIterables(iters) {
  for (const iter of iters) {
    for (const val of iter) {
      yield val;
    }
  }
}

var Recoil_concatIterables = concatIterables;

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */
/* eslint-disable fb-www/typeof-undefined */

const isSSR = // $FlowFixMe(site=recoil) Window does not have a FlowType definition https://github.com/facebook/flow/issues/6709
typeof Window === 'undefined' || typeof window === 'undefined';
/* eslint-enable fb-www/typeof-undefined */

const isWindow$1 = value => !isSSR && ( // $FlowFixMe(site=recoil) Window does not have a FlowType definition https://github.com/facebook/flow/issues/6709
value === window || value instanceof Window);

const isReactNative = typeof navigator !== 'undefined' && navigator.product === 'ReactNative'; // eslint-disable-line fb-www/typeof-undefined

var Recoil_Environment = {
  isSSR,
  isReactNative,
  isWindow: isWindow$1
};

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */
/**
 * Caches a function's results based on the key returned by the passed
 * hashFunction.
 */

function memoizeWithArgsHash(fn, hashFunction) {
  let cache;
  return (...args) => {
    if (!cache) {
      cache = {};
    }

    const key = hashFunction(...args);

    if (!Object.hasOwnProperty.call(cache, key)) {
      cache[key] = fn(...args);
    }

    return cache[key];
  };
}
/**
 * Caches a function's results based on a comparison of the arguments.
 * Only caches the last return of the function.
 * Defaults to reference equality
 */


function memoizeOneWithArgsHash(fn, hashFunction) {
  let lastKey;
  let lastResult; // breaking cache when arguments change

  return (...args) => {
    const key = hashFunction(...args);

    if (lastKey === key) {
      return lastResult;
    }

    lastKey = key;
    lastResult = fn(...args);
    return lastResult;
  };
}
/**
 * Caches a function's results based on a comparison of the arguments.
 * Only caches the last return of the function.
 * Defaults to reference equality
 */


function memoizeOneWithArgsHashAndInvalidation(fn, hashFunction) {
  let lastKey;
  let lastResult; // breaking cache when arguments change

  const memoizedFn = (...args) => {
    const key = hashFunction(...args);

    if (lastKey === key) {
      return lastResult;
    }

    lastKey = key;
    lastResult = fn(...args);
    return lastResult;
  };

  const invalidate = () => {
    lastKey = null;
  };

  return [memoizedFn, invalidate];
}

var Recoil_Memoize = {
  memoizeWithArgsHash,
  memoizeOneWithArgsHash,
  memoizeOneWithArgsHashAndInvalidation
};

const {
  batchUpdates: batchUpdates$1
} = Recoil_Batching;

const {
  initializeNode: initializeNode$1,
  peekNodeInfo: peekNodeInfo$1
} = Recoil_FunctionalCore;

const {
  graph: graph$1
} = Recoil_Graph;

const {
  getNextStoreID: getNextStoreID$1
} = Recoil_Keys;

const {
  DEFAULT_VALUE: DEFAULT_VALUE$1,
  recoilValues: recoilValues$1,
  recoilValuesForKeys: recoilValuesForKeys$2
} = Recoil_Node;

const {
  AbstractRecoilValue: AbstractRecoilValue$2,
  getRecoilValueAsLoadable: getRecoilValueAsLoadable$1,
  setRecoilValue: setRecoilValue$1,
  setUnvalidatedRecoilValue: setUnvalidatedRecoilValue$1
} = Recoil_RecoilValueInterface;

const {
  updateRetainCount: updateRetainCount$1
} = Recoil_Retention;

const {
  setInvalidateMemoizedSnapshot: setInvalidateMemoizedSnapshot$1
} = Recoil_SnapshotCache;

const {
  getNextTreeStateVersion: getNextTreeStateVersion$2,
  makeEmptyStoreState: makeEmptyStoreState$1
} = Recoil_State;



const {
  isSSR: isSSR$1
} = Recoil_Environment;









const {
  memoizeOneWithArgsHashAndInvalidation: memoizeOneWithArgsHashAndInvalidation$1
} = Recoil_Memoize;



 // Opaque at this surface because it's part of the public API from here.


const retainWarning = `
Recoil Snapshots only last for the duration of the callback they are provided to. To keep a Snapshot longer, do this:

  const release = snapshot.retain();
  try {
    await doSomethingWithSnapshot(snapshot);
  } finally {
    release();
  }

This is currently a DEV-only warning but will become a thrown exception in the next release of Recoil.
`; // A "Snapshot" is "read-only" and captures a specific set of values of atoms.
// However, the data-flow-graph and selector values may evolve as selector
// evaluation functions are executed and async selectors resolve.

class Snapshot {
  // eslint-disable-next-line fb-www/no-uninitialized-properties
  constructor(storeState, parentStoreID) {
    _defineProperty$2(this, "_store", void 0);

    _defineProperty$2(this, "_refCount", 1);

    _defineProperty$2(this, "getLoadable", recoilValue => {
      this.checkRefCount_INTERNAL();
      return getRecoilValueAsLoadable$1(this._store, recoilValue);
    });

    _defineProperty$2(this, "getPromise", recoilValue => {
      this.checkRefCount_INTERNAL();
      return this.getLoadable(recoilValue).toPromise();
    });

    _defineProperty$2(this, "getNodes_UNSTABLE", opt => {
      this.checkRefCount_INTERNAL(); // TODO Deal with modified selectors

      if ((opt === null || opt === void 0 ? void 0 : opt.isModified) === true) {
        if ((opt === null || opt === void 0 ? void 0 : opt.isInitialized) === false) {
          return [];
        }

        const state = this._store.getState().currentTree;

        return recoilValuesForKeys$2(state.dirtyAtoms);
      }

      const knownAtoms = this._store.getState().knownAtoms;

      const knownSelectors = this._store.getState().knownSelectors;

      return (opt === null || opt === void 0 ? void 0 : opt.isInitialized) == null ? recoilValues$1.values() : opt.isInitialized === true ? recoilValuesForKeys$2(Recoil_concatIterables([knownAtoms, knownSelectors])) : Recoil_filterIterable(recoilValues$1.values(), ({
        key
      }) => !knownAtoms.has(key) && !knownSelectors.has(key));
    });

    _defineProperty$2(this, "getInfo_UNSTABLE", ({
      key
    }) => {
      this.checkRefCount_INTERNAL();
      return peekNodeInfo$1(this._store, this._store.getState().currentTree, key);
    });

    _defineProperty$2(this, "map", mapper => {
      this.checkRefCount_INTERNAL();
      const mutableSnapshot = new MutableSnapshot(this, batchUpdates$1);
      mapper(mutableSnapshot); // if removing batchUpdates from `set` add it here

      return mutableSnapshot;
    });

    _defineProperty$2(this, "asyncMap", async mapper => {
      this.checkRefCount_INTERNAL();
      const mutableSnapshot = new MutableSnapshot(this, batchUpdates$1);
      mutableSnapshot.retain(); // Retain new snapshot during async mapper

      await mapper(mutableSnapshot); // Continue to retain the new snapshot for the user, but auto-release it
      // after the next tick, the same as a new synchronous snapshot.

      mutableSnapshot.autoRelease_INTERNAL();
      return mutableSnapshot;
    });

    this._store = {
      storeID: getNextStoreID$1(),
      parentStoreID,
      getState: () => storeState,
      replaceState: replacer => {
        // no batching, so nextTree is never active
        storeState.currentTree = replacer(storeState.currentTree);
      },
      getGraph: version => {
        const graphs = storeState.graphsByVersion;

        if (graphs.has(version)) {
          return Recoil_nullthrows(graphs.get(version));
        }

        const newGraph = graph$1();
        graphs.set(version, newGraph);
        return newGraph;
      },
      subscribeToTransactions: () => ({
        release: () => {}
      }),
      addTransactionMetadata: () => {
        throw Recoil_err('Cannot subscribe to Snapshots');
      }
    }; // Initialize any nodes that are live in the parent store (primarily so that
    // this snapshot gets counted towards the node's live stores count).
    // TODO Optimize this when cloning snapshots for callbacks

    for (const nodeKey of this._store.getState().knownAtoms) {
      initializeNode$1(this._store, nodeKey, 'get');
      updateRetainCount$1(this._store, nodeKey, 1);
    }

    this.autoRelease_INTERNAL();
  }

  retain() {
    if (this._refCount <= 0) {
      if (process.env.NODE_ENV !== "production") {
        throw Recoil_err('Snapshot has already been released.');
      } else {
        Recoil_recoverableViolation('Attempt to retain() Snapshot that was already released.');
      }
    }

    this._refCount++;
    let released = false;
    return () => {
      if (!released) {
        released = true;

        this._release();
      }
    };
  }
  /**
   * Release the snapshot on the next tick.  This means the snapshot is retained
   * during the execution of the current function using it.
   */


  autoRelease_INTERNAL() {
    if (!isSSR$1) {
      // Use timeout of 10 to workaround Firefox issue: https://github.com/facebookexperimental/Recoil/issues/1936
      window.setTimeout(() => this._release(), 10);
    }
  }

  _release() {
    this._refCount--;

    if (this._refCount === 0) {
      this._store.getState().nodeCleanupFunctions.forEach(cleanup => cleanup());

      this._store.getState().nodeCleanupFunctions.clear();

      if (!Recoil_gkx('recoil_memory_managament_2020')) {
        return;
      } // Temporarily nerfing this to allow us to find broken call sites without
      // actually breaking anybody yet.
      // for (const k of this._store.getState().knownAtoms) {
      //   updateRetainCountToZero(this._store, k);
      // }

    } else if (this._refCount < 0) {
      if (process.env.NODE_ENV !== "production") {
        Recoil_recoverableViolation('Snapshot released an extra time.');
      }
    }
  }

  isRetained() {
    return this._refCount > 0;
  }

  checkRefCount_INTERNAL() {
    if (Recoil_gkx('recoil_memory_managament_2020') && this._refCount <= 0) {
      if (process.env.NODE_ENV !== "production") {
        Recoil_recoverableViolation(retainWarning);
      } // What we will ship later:
      // throw err(retainWarning);

    }
  }

  getStore_INTERNAL() {
    this.checkRefCount_INTERNAL();
    return this._store;
  }

  getID() {
    this.checkRefCount_INTERNAL();
    return this._store.getState().currentTree.stateID;
  }

  getStoreID() {
    this.checkRefCount_INTERNAL();
    return this._store.storeID;
  } // We want to allow the methods to be destructured and used as accessors

  /* eslint-disable fb-www/extra-arrow-initializer */

  /* eslint-enable fb-www/extra-arrow-initializer */


}

function cloneStoreState(store, treeState, bumpVersion = false) {
  const storeState = store.getState();
  const version = bumpVersion ? getNextTreeStateVersion$2() : treeState.version;
  return {
    // Always clone the TreeState to isolate stores from accidental mutations.
    // For example, reading a selector from a cloned snapshot shouldn't cache
    // in the original treestate which may cause the original to skip
    // initialization of upstream atoms.
    currentTree: {
      // TODO snapshots shouldn't really have versions because a new version number
      // is always assigned when the snapshot is gone to.
      version: bumpVersion ? version : treeState.version,
      stateID: bumpVersion ? version : treeState.stateID,
      transactionMetadata: { ...treeState.transactionMetadata
      },
      dirtyAtoms: new Set(treeState.dirtyAtoms),
      atomValues: treeState.atomValues.clone(),
      nonvalidatedAtoms: treeState.nonvalidatedAtoms.clone()
    },
    commitDepth: 0,
    nextTree: null,
    previousTree: null,
    knownAtoms: new Set(storeState.knownAtoms),
    // FIXME here's a copy
    knownSelectors: new Set(storeState.knownSelectors),
    // FIXME here's a copy
    transactionSubscriptions: new Map(),
    nodeTransactionSubscriptions: new Map(),
    nodeToComponentSubscriptions: new Map(),
    queuedComponentCallbacks_DEPRECATED: [],
    suspendedComponentResolvers: new Set(),
    graphsByVersion: new Map().set(version, store.getGraph(treeState.version)),
    retention: {
      referenceCounts: new Map(),
      nodesRetainedByZone: new Map(),
      retainablesToCheckForRelease: new Set()
    },
    // FIXME here's a copy
    // Create blank cleanup handlers for atoms so snapshots don't re-run
    // atom effects.
    nodeCleanupFunctions: new Map(Recoil_mapIterable(storeState.nodeCleanupFunctions.entries(), ([key]) => [key, () => {}]))
  };
} // Factory to build a fresh snapshot


function freshSnapshot(initializeState) {
  const snapshot = new Snapshot(makeEmptyStoreState$1());
  return initializeState != null ? snapshot.map(initializeState) : snapshot;
} // Factory to clone a snapshot state


const [memoizedCloneSnapshot, invalidateMemoizedSnapshot$2] = memoizeOneWithArgsHashAndInvalidation$1( // $FlowFixMe[missing-local-annot]
(store, version) => {
  var _storeState$nextTree;

  const storeState = store.getState();
  const treeState = version === 'latest' ? (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree : Recoil_nullthrows(storeState.previousTree);
  return new Snapshot(cloneStoreState(store, treeState), store.storeID);
}, (store, version) => {
  var _store$getState$nextT, _store$getState$previ;

  return String(version) + String(store.storeID) + String((_store$getState$nextT = store.getState().nextTree) === null || _store$getState$nextT === void 0 ? void 0 : _store$getState$nextT.version) + String(store.getState().currentTree.version) + String((_store$getState$previ = store.getState().previousTree) === null || _store$getState$previ === void 0 ? void 0 : _store$getState$previ.version);
}); // Avoid circular dependencies

setInvalidateMemoizedSnapshot$1(invalidateMemoizedSnapshot$2);

function cloneSnapshot(store, version = 'latest') {
  const snapshot = memoizedCloneSnapshot(store, version);

  if (!snapshot.isRetained()) {
    invalidateMemoizedSnapshot$2();
    return memoizedCloneSnapshot(store, version);
  }

  return snapshot;
}

class MutableSnapshot extends Snapshot {
  constructor(snapshot, batch) {
    super(cloneStoreState(snapshot.getStore_INTERNAL(), snapshot.getStore_INTERNAL().getState().currentTree, true), snapshot.getStoreID());

    _defineProperty$2(this, "_batch", void 0);

    _defineProperty$2(this, "set", (recoilState, newValueOrUpdater) => {
      this.checkRefCount_INTERNAL();
      const store = this.getStore_INTERNAL(); // This batchUpdates ensures this `set` is applied immediately and you can
      // read the written value after calling `set`. I would like to remove this
      // behavior and only batch in `Snapshot.map`, but this would be a breaking
      // change potentially.

      this._batch(() => {
        updateRetainCount$1(store, recoilState.key, 1);
        setRecoilValue$1(this.getStore_INTERNAL(), recoilState, newValueOrUpdater);
      });
    });

    _defineProperty$2(this, "reset", recoilState => {
      this.checkRefCount_INTERNAL();
      const store = this.getStore_INTERNAL(); // See note at `set` about batched updates.

      this._batch(() => {
        updateRetainCount$1(store, recoilState.key, 1);
        setRecoilValue$1(this.getStore_INTERNAL(), recoilState, DEFAULT_VALUE$1);
      });
    });

    _defineProperty$2(this, "setUnvalidatedAtomValues_DEPRECATED", values => {
      this.checkRefCount_INTERNAL();
      const store = this.getStore_INTERNAL(); // See note at `set` about batched updates.

      batchUpdates$1(() => {
        for (const [k, v] of values.entries()) {
          updateRetainCount$1(store, k, 1);
          setUnvalidatedRecoilValue$1(store, new AbstractRecoilValue$2(k), v);
        }
      });
    });

    this._batch = batch;
  }

}

var Recoil_Snapshot = {
  Snapshot,
  MutableSnapshot,
  freshSnapshot,
  cloneSnapshot
};

var Recoil_Snapshot_1 = Recoil_Snapshot.Snapshot;
var Recoil_Snapshot_2 = Recoil_Snapshot.MutableSnapshot;
var Recoil_Snapshot_3 = Recoil_Snapshot.freshSnapshot;
var Recoil_Snapshot_4 = Recoil_Snapshot.cloneSnapshot;

var Recoil_Snapshot$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Snapshot: Recoil_Snapshot_1,
  MutableSnapshot: Recoil_Snapshot_2,
  freshSnapshot: Recoil_Snapshot_3,
  cloneSnapshot: Recoil_Snapshot_4
});

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */

function unionSets(...sets) {
  const result = new Set();

  for (const set of sets) {
    for (const value of set) {
      result.add(value);
    }
  }

  return result;
}

var Recoil_unionSets = unionSets;

const {
  useRef
} = React;
/**
 * The same as `useRef()` except that if a function is specified then it will
 * call that function to get the value to initialize the reference with.
 * This is similar to how `useState()` behaves when given a function.  It allows
 * the user to avoid generating the initial value for subsequent renders.
 * The tradeoff is that to set the reference to a function itself you need to
 * nest it: useRefInitOnce(() => () => {...});
 */


function useRefInitOnce(initialValue) {
  // $FlowExpectedError[incompatible-call]
  const ref = useRef(initialValue);

  if (ref.current === initialValue && typeof initialValue === 'function') {
    // $FlowExpectedError[incompatible-use]
    ref.current = initialValue();
  }

  return ref;
}

var Recoil_useRefInitOnce = useRefInitOnce;

// @fb-only: const RecoilusagelogEvent = require('RecoilusagelogEvent');
// @fb-only: const RecoilUsageLogFalcoEvent = require('RecoilUsageLogFalcoEvent');
// @fb-only: const URI = require('URI');


const {
  getNextTreeStateVersion: getNextTreeStateVersion$3,
  makeEmptyStoreState: makeEmptyStoreState$2
} = Recoil_State;

const {
  cleanUpNode: cleanUpNode$2,
  getDownstreamNodes: getDownstreamNodes$2,
  initializeNode: initializeNode$2,
  setNodeValue: setNodeValue$2,
  setUnvalidatedAtomValue_DEPRECATED: setUnvalidatedAtomValue_DEPRECATED$1
} = Recoil_FunctionalCore;

const {
  graph: graph$2
} = Recoil_Graph;

const {
  cloneGraph: cloneGraph$1
} = Recoil_Graph;

const {
  getNextStoreID: getNextStoreID$2
} = Recoil_Keys;

const {
  createMutableSource: createMutableSource$1,
  reactMode: reactMode$2
} = Recoil_ReactMode;

const {
  applyAtomValueWrites: applyAtomValueWrites$1
} = Recoil_RecoilValueInterface;

const {
  releaseScheduledRetainablesNow: releaseScheduledRetainablesNow$1
} = Recoil_Retention;

const {
  freshSnapshot: freshSnapshot$1
} = Recoil_Snapshot$1;



const {
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef: useRef$1,
  useState
} = React;















function notInAContext() {
  throw Recoil_err('This component must be used inside a <RecoilRoot> component.');
}

const defaultStore = Object.freeze({
  storeID: getNextStoreID$2(),
  getState: notInAContext,
  replaceState: notInAContext,
  getGraph: notInAContext,
  subscribeToTransactions: notInAContext,
  addTransactionMetadata: notInAContext
});
let stateReplacerIsBeingExecuted = false;

function startNextTreeIfNeeded(store) {
  if (stateReplacerIsBeingExecuted) {
    throw Recoil_err('An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.');
  }

  const storeState = store.getState();

  if (storeState.nextTree === null) {
    if (Recoil_gkx('recoil_memory_managament_2020') && Recoil_gkx('recoil_release_on_cascading_update_killswitch_2021')) {
      // If this is a cascading update (that is, rendering due to one state change
      // invokes a second state change), we won't have cleaned up retainables yet
      // because this normally happens after notifying components. Do it before
      // proceeding with the cascading update so that it remains predictable:
      if (storeState.commitDepth > 0) {
        releaseScheduledRetainablesNow$1(store);
      }
    }

    const version = storeState.currentTree.version;
    const nextVersion = getNextTreeStateVersion$3();
    storeState.nextTree = { ...storeState.currentTree,
      version: nextVersion,
      stateID: nextVersion,
      dirtyAtoms: new Set(),
      transactionMetadata: {}
    };
    storeState.graphsByVersion.set(nextVersion, cloneGraph$1(Recoil_nullthrows(storeState.graphsByVersion.get(version))));
  }
}

const AppContext = React.createContext({
  current: defaultStore
});

const useStoreRef = () => useContext(AppContext); // $FlowExpectedError[incompatible-call]


const MutableSourceContext = React.createContext(null);

function useRecoilMutableSource() {
  const mutableSource = useContext(MutableSourceContext);

  if (mutableSource == null) {
    Recoil_expectationViolation('Attempted to use a Recoil hook outside of a <RecoilRoot>. ' + '<RecoilRoot> must be an ancestor of any component that uses ' + 'Recoil hooks.');
  }

  return mutableSource;
}

function notifyComponents(store, storeState, treeState) {
  const dependentNodes = getDownstreamNodes$2(store, treeState, treeState.dirtyAtoms);

  for (const key of dependentNodes) {
    const comps = storeState.nodeToComponentSubscriptions.get(key);

    if (comps) {
      for (const [_subID, [_debugName, callback]] of comps) {
        callback(treeState);
      }
    }
  }
}

function sendEndOfBatchNotifications(store) {
  const storeState = store.getState();
  const treeState = storeState.currentTree; // Inform transaction subscribers of the transaction:

  const dirtyAtoms = treeState.dirtyAtoms;

  if (dirtyAtoms.size) {
    // Execute Node-specific subscribers before global subscribers
    for (const [key, subscriptions] of storeState.nodeTransactionSubscriptions) {
      if (dirtyAtoms.has(key)) {
        for (const [_, subscription] of subscriptions) {
          subscription(store);
        }
      }
    }

    for (const [_, subscription] of storeState.transactionSubscriptions) {
      subscription(store);
    }

    if (!reactMode$2().early || storeState.suspendedComponentResolvers.size > 0) {
      // Notifying components is needed to wake from suspense, even when using
      // early rendering.
      notifyComponents(store, storeState, treeState); // Wake all suspended components so the right one(s) can try to re-render.
      // We need to wake up components not just when some asynchronous selector
      // resolved, but also when changing synchronous values because this may cause
      // a selector to change from asynchronous to synchronous, in which case there
      // would be no follow-up asynchronous resolution to wake us up.
      // TODO OPTIMIZATION Only wake up related downstream components

      storeState.suspendedComponentResolvers.forEach(cb => cb());
      storeState.suspendedComponentResolvers.clear();
    }
  } // Special behavior ONLY invoked by useInterface.
  // FIXME delete queuedComponentCallbacks_DEPRECATED when deleting useInterface.


  storeState.queuedComponentCallbacks_DEPRECATED.forEach(cb => cb(treeState));
  storeState.queuedComponentCallbacks_DEPRECATED.splice(0, storeState.queuedComponentCallbacks_DEPRECATED.length);
}

function endBatch(store) {
  const storeState = store.getState();
  storeState.commitDepth++;

  try {
    const {
      nextTree
    } = storeState; // Ignore commits that are not because of Recoil transactions -- namely,
    // because something above RecoilRoot re-rendered:

    if (nextTree == null) {
      return;
    } // nextTree is now committed -- note that copying and reset occurs when
    // a transaction begins, in startNextTreeIfNeeded:


    storeState.previousTree = storeState.currentTree;
    storeState.currentTree = nextTree;
    storeState.nextTree = null;
    sendEndOfBatchNotifications(store);

    if (storeState.previousTree != null) {
      storeState.graphsByVersion.delete(storeState.previousTree.version);
    } else {
      Recoil_recoverableViolation('Ended batch with no previous state, which is unexpected', 'recoil');
    }

    storeState.previousTree = null;

    if (Recoil_gkx('recoil_memory_managament_2020')) {
      // Only release retainables if there were no writes during the end of the
      // batch.  This avoids releasing something we might be about to use.
      if (nextTree == null) {
        releaseScheduledRetainablesNow$1(store);
      }
    }
  } finally {
    storeState.commitDepth--;
  }
}
/*
 * The purpose of the Batcher is to observe when React batches end so that
 * Recoil state changes can be batched. Whenever Recoil state changes, we call
 * setState on the batcher. Then we wait for that change to be committed, which
 * signifies the end of the batch. That's when we respond to the Recoil change.
 */


function Batcher({
  setNotifyBatcherOfChange
}) {
  const storeRef = useStoreRef();
  const [, setState] = useState([]); // $FlowFixMe[incompatible-call]

  setNotifyBatcherOfChange(() => setState({}));
  useEffect(() => {
    // $FlowFixMe[incompatible-call]
    setNotifyBatcherOfChange(() => setState({})); // If an asynchronous selector resolves after the Batcher is unmounted,
    // notifyBatcherOfChange will still be called. An error gets thrown whenever
    // setState is called after a component is already unmounted, so this sets
    // notifyBatcherOfChange to be a no-op.

    return () => {
      setNotifyBatcherOfChange(() => {});
    };
  }, [setNotifyBatcherOfChange]);
  useEffect(() => {
    // enqueueExecution runs this function immediately; it is only used to
    // manipulate the order of useEffects during tests, since React seems to
    // call useEffect in an unpredictable order sometimes.
    Recoil_Queue.enqueueExecution('Batcher', () => {
      endBatch(storeRef.current);
    });
  });
  return null;
}

if (process.env.NODE_ENV !== "production") {
  if (typeof window !== 'undefined' && !window.$recoilDebugStates) {
    window.$recoilDebugStates = [];
  }
} // When removing this deprecated function, remove stateBySettingRecoilValue
// which will no longer be needed.


function initialStoreState_DEPRECATED(store, initializeState) {
  const initial = makeEmptyStoreState$2();
  initializeState({
    set: (atom, value) => {
      const state = initial.currentTree;
      const writes = setNodeValue$2(store, state, atom.key, value);
      const writtenNodes = new Set(writes.keys());
      const nonvalidatedAtoms = state.nonvalidatedAtoms.clone();

      for (const n of writtenNodes) {
        nonvalidatedAtoms.delete(n);
      }

      initial.currentTree = { ...state,
        dirtyAtoms: Recoil_unionSets(state.dirtyAtoms, writtenNodes),
        atomValues: applyAtomValueWrites$1(state.atomValues, writes),
        // NB: PLEASE un-export applyAtomValueWrites when deleting this code
        nonvalidatedAtoms
      };
    },
    setUnvalidatedAtomValues: atomValues => {
      // FIXME replace this with a mutative loop
      atomValues.forEach((v, k) => {
        initial.currentTree = setUnvalidatedAtomValue_DEPRECATED$1(initial.currentTree, k, v);
      });
    }
  });
  return initial;
} // Initialize state snapshot for <RecoilRoot> for the initializeState prop.
// Atom effect initialization takes precedence over this prop.
// Any atom effects will be run before initialization, but then cleaned up,
// they are then re-run when used as part of rendering.  These semantics are
// compatible with React StrictMode where effects may be re-run multiple times
// but state initialization only happens once the first time.


function initialStoreState(initializeState) {
  // Initialize a snapshot and get its store
  const snapshot = freshSnapshot$1(initializeState);
  const storeState = snapshot.getStore_INTERNAL().getState(); // Counteract the snapshot auto-release

  snapshot.retain(); // Cleanup any effects run during initialization and clear the handlers so
  // they will re-initialize if used during rendering.  This allows atom effect
  // initialization to take precedence over initializeState and be compatible
  // with StrictMode semantics.

  storeState.nodeCleanupFunctions.forEach(cleanup => cleanup());
  storeState.nodeCleanupFunctions.clear();
  return storeState;
}

let nextID = 0;

function RecoilRoot_INTERNAL({
  initializeState_DEPRECATED,
  initializeState,
  store_INTERNAL: storeProp,
  // For use with React "context bridging"
  children
}) {
  // prettier-ignore
  // @fb-only: useEffect(() => {
  // @fb-only: if (gkx('recoil_usage_logging')) {
  // @fb-only: try {
  // @fb-only: RecoilUsageLogFalcoEvent.log(() => ({
  // @fb-only: type: RecoilusagelogEvent.RECOIL_ROOT_MOUNTED,
  // @fb-only: path: URI.getRequestURI().getPath(),
  // @fb-only: }));
  // @fb-only: } catch {
  // @fb-only: recoverableViolation(
  // @fb-only: 'Error when logging Recoil Usage event',
  // @fb-only: 'recoil',
  // @fb-only: );
  // @fb-only: }
  // @fb-only: }
  // @fb-only: }, []);
  let storeStateRef; // eslint-disable-line prefer-const

  const getGraph = version => {
    const graphs = storeStateRef.current.graphsByVersion;

    if (graphs.has(version)) {
      return Recoil_nullthrows(graphs.get(version));
    }

    const newGraph = graph$2();
    graphs.set(version, newGraph);
    return newGraph;
  };

  const subscribeToTransactions = (callback, key) => {
    if (key == null) {
      // Global transaction subscriptions
      const {
        transactionSubscriptions
      } = storeRef.current.getState();
      const id = nextID++;
      transactionSubscriptions.set(id, callback);
      return {
        release: () => {
          transactionSubscriptions.delete(id);
        }
      };
    } else {
      // Node-specific transaction subscriptions:
      const {
        nodeTransactionSubscriptions
      } = storeRef.current.getState();

      if (!nodeTransactionSubscriptions.has(key)) {
        nodeTransactionSubscriptions.set(key, new Map());
      }

      const id = nextID++;
      Recoil_nullthrows(nodeTransactionSubscriptions.get(key)).set(id, callback);
      return {
        release: () => {
          const subs = nodeTransactionSubscriptions.get(key);

          if (subs) {
            subs.delete(id);

            if (subs.size === 0) {
              nodeTransactionSubscriptions.delete(key);
            }
          }
        }
      };
    }
  };

  const addTransactionMetadata = metadata => {
    startNextTreeIfNeeded(storeRef.current);

    for (const k of Object.keys(metadata)) {
      Recoil_nullthrows(storeRef.current.getState().nextTree).transactionMetadata[k] = metadata[k];
    }
  };

  const replaceState = replacer => {
    startNextTreeIfNeeded(storeRef.current); // Use replacer to get the next state:

    const nextTree = Recoil_nullthrows(storeStateRef.current.nextTree);
    let replaced;

    try {
      stateReplacerIsBeingExecuted = true;
      replaced = replacer(nextTree);
    } finally {
      stateReplacerIsBeingExecuted = false;
    }

    if (replaced === nextTree) {
      return;
    }

    if (process.env.NODE_ENV !== "production") {
      if (typeof window !== 'undefined') {
        window.$recoilDebugStates.push(replaced); // TODO this shouldn't happen here because it's not batched
      }
    } // Save changes to nextTree and schedule a React update:


    storeStateRef.current.nextTree = replaced;

    if (reactMode$2().early) {
      notifyComponents(storeRef.current, storeStateRef.current, replaced);
    }

    Recoil_nullthrows(notifyBatcherOfChange.current)();
  };

  const notifyBatcherOfChange = useRef$1(null);
  const setNotifyBatcherOfChange = useCallback(x => {
    notifyBatcherOfChange.current = x;
  }, [notifyBatcherOfChange]);
  const storeRef = Recoil_useRefInitOnce(() => storeProp !== null && storeProp !== void 0 ? storeProp : {
    storeID: getNextStoreID$2(),
    getState: () => storeStateRef.current,
    replaceState,
    getGraph,
    subscribeToTransactions,
    addTransactionMetadata
  });

  if (storeProp != null) {
    storeRef.current = storeProp;
  }

  storeStateRef = Recoil_useRefInitOnce(() => initializeState_DEPRECATED != null ? initialStoreState_DEPRECATED(storeRef.current, initializeState_DEPRECATED) : initializeState != null ? initialStoreState(initializeState) : makeEmptyStoreState$2());
  const mutableSource = useMemo(() => createMutableSource$1 === null || createMutableSource$1 === void 0 ? void 0 : createMutableSource$1(storeStateRef, () => storeStateRef.current.currentTree.version), [storeStateRef]); // Cleanup when the <RecoilRoot> is unmounted

  useEffect(() => {
    // React is free to call effect cleanup handlers and effects at will, the
    // deps array is only an optimization.  For example, React strict mode
    // will execute each effect twice for testing.  Therefore, we need symmetry
    // to re-initialize all known atoms after they were cleaned up.
    const store = storeRef.current;

    for (const atomKey of new Set(store.getState().knownAtoms)) {
      initializeNode$2(store, atomKey, 'get');
    }

    return () => {
      for (const atomKey of store.getState().knownAtoms) {
        cleanUpNode$2(store, atomKey);
      }
    };
  }, [storeRef]);
  return /*#__PURE__*/React.createElement(AppContext.Provider, {
    value: storeRef
  }, /*#__PURE__*/React.createElement(MutableSourceContext.Provider, {
    value: mutableSource
  }, /*#__PURE__*/React.createElement(Batcher, {
    setNotifyBatcherOfChange: setNotifyBatcherOfChange
  }), children));
}

function RecoilRoot(props) {
  const {
    override,
    ...propsExceptOverride
  } = props;
  const ancestorStoreRef = useStoreRef();

  if (override === false && ancestorStoreRef.current !== defaultStore) {
    // If ancestorStoreRef.current !== defaultStore, it means that this
    // RecoilRoot is not nested within another.
    return props.children;
  }

  return /*#__PURE__*/React.createElement(RecoilRoot_INTERNAL, propsExceptOverride);
}

function useRecoilStoreID() {
  return useStoreRef().current.storeID;
}

var Recoil_RecoilRoot = {
  RecoilRoot,
  useStoreRef,
  useRecoilMutableSource,
  useRecoilStoreID,
  notifyComponents_FOR_TESTING: notifyComponents,
  sendEndOfBatchNotifications_FOR_TESTING: sendEndOfBatchNotifications
};

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */

function shallowArrayEqual(a, b) {
  if (a === b) {
    return true;
  }

  if (a.length !== b.length) {
    return false;
  }

  for (let i = 0, l = a.length; i < l; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }

  return true;
}

var Recoil_shallowArrayEqual = shallowArrayEqual;

const {
  useEffect: useEffect$1,
  useRef: useRef$2
} = React;

function usePrevious(value) {
  const ref = useRef$2();
  useEffect$1(() => {
    // $FlowFixMe[incompatible-type]
    ref.current = value;
  });
  return ref.current;
}

var Recoil_usePrevious = usePrevious;

const {
  useStoreRef: useStoreRef$1
} = Recoil_RecoilRoot;

const {
  SUSPENSE_TIMEOUT_MS: SUSPENSE_TIMEOUT_MS$1
} = Recoil_Retention;

const {
  updateRetainCount: updateRetainCount$2
} = Recoil_Retention;

const {
  RetentionZone: RetentionZone$3
} = Recoil_RetentionZone;

const {
  useEffect: useEffect$2,
  useRef: useRef$3
} = React;

const {
  isSSR: isSSR$2
} = Recoil_Environment;





 // I don't see a way to avoid the any type here because we want to accept readable
// and writable values with any type parameter, but normally with writable ones
// RecoilState<SomeT> is not a subtype of RecoilState<mixed>.


// flowlint-line unclear-type:off
function useRetain(toRetain) {
  if (!Recoil_gkx('recoil_memory_managament_2020')) {
    return;
  } // eslint-disable-next-line fb-www/react-hooks


  return useRetain_ACTUAL(toRetain);
}

function useRetain_ACTUAL(toRetain) {
  const array = Array.isArray(toRetain) ? toRetain : [toRetain];
  const retainables = array.map(a => a instanceof RetentionZone$3 ? a : a.key);
  const storeRef = useStoreRef$1();
  useEffect$2(() => {
    if (!Recoil_gkx('recoil_memory_managament_2020')) {
      return;
    }

    const store = storeRef.current;

    if (timeoutID.current && !isSSR$2) {
      // Already performed a temporary retain on render, simply cancel the release
      // of that temporary retain.
      window.clearTimeout(timeoutID.current);
      timeoutID.current = null;
    } else {
      for (const r of retainables) {
        updateRetainCount$2(store, r, 1);
      }
    }

    return () => {
      for (const r of retainables) {
        updateRetainCount$2(store, r, -1);
      }
    }; // eslint-disable-next-line fb-www/react-hooks-deps
  }, [storeRef, ...retainables]); // We want to retain if the component suspends. This is terrible but the Suspense
  // API affords us no better option. If we suspend and never commit after some
  // seconds, then release. The 'actual' retain/release in the effect above
  // cancels this.

  const timeoutID = useRef$3();
  const previousRetainables = Recoil_usePrevious(retainables);

  if (!isSSR$2 && (previousRetainables === undefined || !Recoil_shallowArrayEqual(previousRetainables, retainables))) {
    const store = storeRef.current;

    for (const r of retainables) {
      updateRetainCount$2(store, r, 1);
    }

    if (previousRetainables) {
      for (const r of previousRetainables) {
        updateRetainCount$2(store, r, -1);
      }
    }

    if (timeoutID.current) {
      window.clearTimeout(timeoutID.current);
    }

    timeoutID.current = window.setTimeout(() => {
      timeoutID.current = null;

      for (const r of retainables) {
        updateRetainCount$2(store, r, -1);
      }
    }, SUSPENSE_TIMEOUT_MS$1);
  }
}

var Recoil_useRetain = useRetain;

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */
/**
 * THIS CODE HAS BEEN COMMENTED OUT INTENTIONALLY
 *
 * This technique of getting the component name is imperfect, since it both only
 * works in a non-minified code base, and more importantly introduces performance
 * problems since it relies in throwing errors which is an expensive operation.
 *
 * At some point we may want to reevaluate this technique hence why we have commented
 * this code out, rather than delete it all together.
 */
// const {useRef} = require('react');
// const gkx = require('recoil-shared/util/Recoil_gkx');
// const stackTraceParser = require('recoil-shared/util/Recoil_stackTraceParser');

function useComponentName() {
  // const nameRef = useRef();
  // if (__DEV__) {
  //   if (gkx('recoil_infer_component_names')) {
  //     if (nameRef.current === undefined) {
  //       // There is no blessed way to determine the calling React component from
  //       // within a hook. This hack uses the fact that hooks must start with 'use'
  //       // and that hooks are either called by React Components or other hooks. It
  //       // follows therefore, that to find the calling component, you simply need
  //       // to look down the stack and find the first function which doesn't start
  //       // with 'use'. We are only enabling this in dev for now, since once the
  //       // codebase is minified, the naming assumptions no longer hold true.
  //       // eslint-disable-next-line fb-www/no-new-error
  //       const frames = stackTraceParser(new Error().stack);
  //       for (const {methodName} of frames) {
  //         // I observed cases where the frame was of the form 'Object.useXXX'
  //         // hence why I'm searching for hooks following a word boundary
  //         if (!methodName.match(/\buse[^\b]+$/)) {
  //           return (nameRef.current = methodName);
  //         }
  //       }
  //       nameRef.current = null;
  //     }
  //     return nameRef.current ?? '<unable to determine component name>';
  //   }
  // }
  // @fb-only: return "<component name only available when both in dev mode and when passing GK 'recoil_infer_component_names'>";
  return '<component name not available>'; // @oss-only
}

var Recoil_useComponentName = useComponentName;

const {
  batchUpdates: batchUpdates$2
} = Recoil_Batching;

const {
  DEFAULT_VALUE: DEFAULT_VALUE$2
} = Recoil_Node;

const {
  currentRendererSupportsUseSyncExternalStore: currentRendererSupportsUseSyncExternalStore$1,
  reactMode: reactMode$3,
  useMutableSource: useMutableSource$1,
  useSyncExternalStore: useSyncExternalStore$1
} = Recoil_ReactMode;

const {
  useRecoilMutableSource: useRecoilMutableSource$1,
  useStoreRef: useStoreRef$2
} = Recoil_RecoilRoot;

const {
  isRecoilValue: isRecoilValue$2
} = Recoil_RecoilValue$1;

const {
  AbstractRecoilValue: AbstractRecoilValue$3,
  getRecoilValueAsLoadable: getRecoilValueAsLoadable$2,
  setRecoilValue: setRecoilValue$2,
  setUnvalidatedRecoilValue: setUnvalidatedRecoilValue$2,
  subscribeToRecoilValue: subscribeToRecoilValue$1
} = Recoil_RecoilValueInterface;



const {
  useCallback: useCallback$1,
  useEffect: useEffect$3,
  useMemo: useMemo$1,
  useRef: useRef$4,
  useState: useState$1
} = React;

const {
  setByAddingToSet: setByAddingToSet$2
} = Recoil_CopyOnWrite;



const {
  isSSR: isSSR$3
} = Recoil_Environment;













function handleLoadable(loadable, recoilValue, storeRef) {
  // We can't just throw the promise we are waiting on to Suspense.  If the
  // upstream dependencies change it may produce a state in which the component
  // can render, but it would still be suspended on a Promise that may never resolve.
  if (loadable.state === 'hasValue') {
    return loadable.contents;
  } else if (loadable.state === 'loading') {
    const promise = new Promise(resolve => {
      const suspendedComponentResolvers = storeRef.current.getState().suspendedComponentResolvers;
      suspendedComponentResolvers.add(resolve); // SSR should clear out the wake-up resolver if the Promise is resolved
      // to avoid infinite loops.  (See https://github.com/facebookexperimental/Recoil/pull/2073)

      if (isSSR$3 && Recoil_isPromise(loadable.contents)) {
        loadable.contents.finally(() => {
          suspendedComponentResolvers.delete(resolve);
        });
      }
    }); // $FlowExpectedError Flow(prop-missing) for integrating with tools that inspect thrown promises @fb-only
    // @fb-only: promise.displayName = `Recoil State: ${recoilValue.key}`;

    throw promise;
  } else if (loadable.state === 'hasError') {
    throw loadable.contents;
  } else {
    throw Recoil_err(`Invalid value of loadable atom "${recoilValue.key}"`);
  }
}

function validateRecoilValue(recoilValue, hookName // $FlowFixMe[missing-local-annot]
) {
  if (!isRecoilValue$2(recoilValue)) {
    throw Recoil_err(`Invalid argument to ${hookName}: expected an atom or selector but got ${String(recoilValue)}`);
  }
}

/**
 * Various things are broken with useRecoilInterface, particularly concurrent
 * mode, React strict mode, and memory management. They will not be fixed.
 * */
function useRecoilInterface_DEPRECATED() {
  const componentName = Recoil_useComponentName();
  const storeRef = useStoreRef$2(); // eslint-disable-next-line fb-www/react-no-unused-state-hook

  const [, forceUpdate] = useState$1([]);
  const recoilValuesUsed = useRef$4(new Set());
  recoilValuesUsed.current = new Set(); // Track the RecoilValues used just during this render

  const previousSubscriptions = useRef$4(new Set());
  const subscriptions = useRef$4(new Map());
  const unsubscribeFrom = useCallback$1(key => {
    const sub = subscriptions.current.get(key);

    if (sub) {
      sub.release();
      subscriptions.current.delete(key);
    }
  }, [subscriptions]);
  const updateState = useCallback$1((_state, key) => {
    if (subscriptions.current.has(key)) {
      forceUpdate([]);
    }
  }, []); // Effect to add/remove subscriptions as nodes are used

  useEffect$3(() => {
    const store = storeRef.current;
    Recoil_differenceSets(recoilValuesUsed.current, previousSubscriptions.current).forEach(key => {
      if (subscriptions.current.has(key)) {
        Recoil_expectationViolation(`Double subscription to RecoilValue "${key}"`);
        return;
      }

      const sub = subscribeToRecoilValue$1(store, new AbstractRecoilValue$3(key), state => updateState(state, key), componentName);
      subscriptions.current.set(key, sub);
      /**
       * Since we're subscribing in an effect we need to update to the latest
       * value of the atom since it may have changed since we rendered. We can
       * go ahead and do that now, unless we're in the middle of a batch --
       * in which case we should do it at the end of the batch, due to the
       * following edge case: Suppose an atom is updated in another useEffect
       * of this same component. Then the following sequence of events occur:
       * 1. Atom is updated and subs fired (but we may not be subscribed
       *    yet depending on order of effects, so we miss this) Updated value
       *    is now in nextTree, but not currentTree.
       * 2. This effect happens. We subscribe and update.
       * 3. From the update we re-render and read currentTree, with old value.
       * 4. Batcher's effect sets currentTree to nextTree.
       * In this sequence we miss the update. To avoid that, add the update
       * to queuedComponentCallback if a batch is in progress.
       */
      // FIXME delete queuedComponentCallbacks_DEPRECATED when deleting useInterface.

      const state = store.getState();

      if (state.nextTree) {
        store.getState().queuedComponentCallbacks_DEPRECATED.push(() => {
          updateState(store.getState(), key);
        });
      } else {
        updateState(store.getState(), key);
      }
    });
    Recoil_differenceSets(previousSubscriptions.current, recoilValuesUsed.current).forEach(key => {
      unsubscribeFrom(key);
    });
    previousSubscriptions.current = recoilValuesUsed.current;
  }); // Effect to unsubscribe from all when unmounting

  useEffect$3(() => {
    const currentSubscriptions = subscriptions.current; // Restore subscriptions that were cleared due to StrictMode running this effect twice

    Recoil_differenceSets(recoilValuesUsed.current, new Set(currentSubscriptions.keys())).forEach(key => {
      const sub = subscribeToRecoilValue$1(storeRef.current, new AbstractRecoilValue$3(key), state => updateState(state, key), componentName);
      currentSubscriptions.set(key, sub);
    });
    return () => currentSubscriptions.forEach((_, key) => unsubscribeFrom(key));
  }, [componentName, storeRef, unsubscribeFrom, updateState]);
  return useMemo$1(() => {
    // eslint-disable-next-line no-shadow
    function useSetRecoilState(recoilState) {
      if (process.env.NODE_ENV !== "production") {
        validateRecoilValue(recoilState, 'useSetRecoilState');
      }

      return newValueOrUpdater => {
        setRecoilValue$2(storeRef.current, recoilState, newValueOrUpdater);
      };
    } // eslint-disable-next-line no-shadow


    function useResetRecoilState(recoilState) {
      if (process.env.NODE_ENV !== "production") {
        validateRecoilValue(recoilState, 'useResetRecoilState');
      }

      return () => setRecoilValue$2(storeRef.current, recoilState, DEFAULT_VALUE$2);
    } // eslint-disable-next-line no-shadow


    function useRecoilValueLoadable(recoilValue) {
      var _storeState$nextTree;

      if (process.env.NODE_ENV !== "production") {
        validateRecoilValue(recoilValue, 'useRecoilValueLoadable');
      }

      if (!recoilValuesUsed.current.has(recoilValue.key)) {
        recoilValuesUsed.current = setByAddingToSet$2(recoilValuesUsed.current, recoilValue.key);
      } // TODO Restore optimization to memoize lookup


      const storeState = storeRef.current.getState();
      return getRecoilValueAsLoadable$2(storeRef.current, recoilValue, reactMode$3().early ? (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree : storeState.currentTree);
    } // eslint-disable-next-line no-shadow


    function useRecoilValue(recoilValue) {
      if (process.env.NODE_ENV !== "production") {
        validateRecoilValue(recoilValue, 'useRecoilValue');
      }

      const loadable = useRecoilValueLoadable(recoilValue);
      return handleLoadable(loadable, recoilValue, storeRef);
    } // eslint-disable-next-line no-shadow


    function useRecoilState(recoilState) {
      if (process.env.NODE_ENV !== "production") {
        validateRecoilValue(recoilState, 'useRecoilState');
      }

      return [useRecoilValue(recoilState), useSetRecoilState(recoilState)];
    } // eslint-disable-next-line no-shadow


    function useRecoilStateLoadable(recoilState) {
      if (process.env.NODE_ENV !== "production") {
        validateRecoilValue(recoilState, 'useRecoilStateLoadable');
      }

      return [useRecoilValueLoadable(recoilState), useSetRecoilState(recoilState)];
    }

    return {
      getRecoilValue: useRecoilValue,
      getRecoilValueLoadable: useRecoilValueLoadable,
      getRecoilState: useRecoilState,
      getRecoilStateLoadable: useRecoilStateLoadable,
      getSetRecoilState: useSetRecoilState,
      getResetRecoilState: useResetRecoilState
    };
  }, [recoilValuesUsed, storeRef]);
}

const recoilComponentGetRecoilValueCount_FOR_TESTING = {
  current: 0
};

function useRecoilValueLoadable_SYNC_EXTERNAL_STORE(recoilValue) {
  const storeRef = useStoreRef$2();
  const componentName = Recoil_useComponentName();
  const getSnapshot = useCallback$1(() => {
    var _storeState$nextTree2;

    if (process.env.NODE_ENV !== "production") {
      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;
    }

    const store = storeRef.current;
    const storeState = store.getState();
    const treeState = reactMode$3().early ? (_storeState$nextTree2 = storeState.nextTree) !== null && _storeState$nextTree2 !== void 0 ? _storeState$nextTree2 : storeState.currentTree : storeState.currentTree;
    const loadable = getRecoilValueAsLoadable$2(store, recoilValue, treeState);
    return {
      loadable,
      key: recoilValue.key
    };
  }, [storeRef, recoilValue]); // Memoize the state to avoid unnecessary rerenders

  const memoizePreviousSnapshot = useCallback$1(getState => {
    let prevState;
    return () => {
      var _prevState, _prevState2;

      const nextState = getState();

      if ((_prevState = prevState) !== null && _prevState !== void 0 && _prevState.loadable.is(nextState.loadable) && ((_prevState2 = prevState) === null || _prevState2 === void 0 ? void 0 : _prevState2.key) === nextState.key) {
        return prevState;
      }

      prevState = nextState;
      return nextState;
    };
  }, []);
  const getMemoizedSnapshot = useMemo$1(() => memoizePreviousSnapshot(getSnapshot), [getSnapshot, memoizePreviousSnapshot]);
  const subscribe = useCallback$1(notify => {
    const store = storeRef.current;
    const subscription = subscribeToRecoilValue$1(store, recoilValue, notify, componentName);
    return subscription.release;
  }, [storeRef, recoilValue, componentName]);
  return useSyncExternalStore$1(subscribe, getMemoizedSnapshot, // getSnapshot()
  getMemoizedSnapshot // getServerSnapshot() for SSR support
  ).loadable;
}

function useRecoilValueLoadable_MUTABLE_SOURCE(recoilValue) {
  const storeRef = useStoreRef$2();
  const getLoadable = useCallback$1(() => {
    var _storeState$nextTree3;

    const store = storeRef.current;
    const storeState = store.getState();
    const treeState = reactMode$3().early ? (_storeState$nextTree3 = storeState.nextTree) !== null && _storeState$nextTree3 !== void 0 ? _storeState$nextTree3 : storeState.currentTree : storeState.currentTree;
    return getRecoilValueAsLoadable$2(store, recoilValue, treeState);
  }, [storeRef, recoilValue]);
  const getLoadableWithTesting = useCallback$1(() => {
    if (process.env.NODE_ENV !== "production") {
      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;
    }

    return getLoadable();
  }, [getLoadable]);
  const componentName = Recoil_useComponentName();
  const subscribe = useCallback$1((_storeState, notify) => {
    const store = storeRef.current;
    const subscription = subscribeToRecoilValue$1(store, recoilValue, () => {
      if (!Recoil_gkx('recoil_suppress_rerender_in_callback')) {
        return notify();
      } // Only re-render if the value has changed.
      // This will evaluate the atom/selector now as well as when the
      // component renders, but that may help with prefetching.


      const newLoadable = getLoadable();

      if (!prevLoadableRef.current.is(newLoadable)) {
        notify();
      } // If the component is suspended then the effect setting prevLoadableRef
      // will not run.  So, set the previous value here when its subscription
      // is fired to wake it up.  We can't just rely on this, though, because
      // this only executes when an atom/selector is dirty and the atom/selector
      // passed to the hook can dynamically change.


      prevLoadableRef.current = newLoadable;
    }, componentName);
    return subscription.release;
  }, [storeRef, recoilValue, componentName, getLoadable]);
  const source = useRecoilMutableSource$1();

  if (source == null) {
    throw Recoil_err('Recoil hooks must be used in components contained within a <RecoilRoot> component.');
  }

  const loadable = useMutableSource$1(source, getLoadableWithTesting, subscribe);
  const prevLoadableRef = useRef$4(loadable);
  useEffect$3(() => {
    prevLoadableRef.current = loadable;
  });
  return loadable;
}

function useRecoilValueLoadable_TRANSITION_SUPPORT(recoilValue) {
  const storeRef = useStoreRef$2();
  const componentName = Recoil_useComponentName(); // Accessors to get the current state

  const getLoadable = useCallback$1(() => {
    var _storeState$nextTree4;

    if (process.env.NODE_ENV !== "production") {
      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;
    }

    const store = storeRef.current;
    const storeState = store.getState();
    const treeState = reactMode$3().early ? (_storeState$nextTree4 = storeState.nextTree) !== null && _storeState$nextTree4 !== void 0 ? _storeState$nextTree4 : storeState.currentTree : storeState.currentTree;
    return getRecoilValueAsLoadable$2(store, recoilValue, treeState);
  }, [storeRef, recoilValue]);
  const getState = useCallback$1(() => ({
    loadable: getLoadable(),
    key: recoilValue.key
  }), [getLoadable, recoilValue.key]); // Memoize state snapshots

  const updateState = useCallback$1(prevState => {
    const nextState = getState();
    return prevState.loadable.is(nextState.loadable) && prevState.key === nextState.key ? prevState : nextState;
  }, [getState]); // Subscribe to Recoil state changes

  useEffect$3(() => {
    const subscription = subscribeToRecoilValue$1(storeRef.current, recoilValue, _state => {
      setState(updateState);
    }, componentName); // Update state in case we are using a different key

    setState(updateState);
    return subscription.release;
  }, [componentName, recoilValue, storeRef, updateState]); // Get the current state

  const [state, setState] = useState$1(getState); // If we changed keys, then return the state for the new key.
  // This is important in case the old key would cause the component to suspend.
  // We don't have to set the new state here since the subscribing effect above
  // will do that.

  return state.key !== recoilValue.key ? getState().loadable : state.loadable;
}

function useRecoilValueLoadable_LEGACY(recoilValue) {
  const storeRef = useStoreRef$2(); // eslint-disable-next-line fb-www/react-no-unused-state-hook

  const [, forceUpdate] = useState$1([]);
  const componentName = Recoil_useComponentName();
  const getLoadable = useCallback$1(() => {
    var _storeState$nextTree5;

    if (process.env.NODE_ENV !== "production") {
      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;
    }

    const store = storeRef.current;
    const storeState = store.getState();
    const treeState = reactMode$3().early ? (_storeState$nextTree5 = storeState.nextTree) !== null && _storeState$nextTree5 !== void 0 ? _storeState$nextTree5 : storeState.currentTree : storeState.currentTree;
    return getRecoilValueAsLoadable$2(store, recoilValue, treeState);
  }, [storeRef, recoilValue]);
  const loadable = getLoadable();
  const prevLoadableRef = useRef$4(loadable);
  useEffect$3(() => {
    prevLoadableRef.current = loadable;
  });
  useEffect$3(() => {
    const store = storeRef.current;
    const storeState = store.getState();
    const subscription = subscribeToRecoilValue$1(store, recoilValue, _state => {
      var _prevLoadableRef$curr;

      if (!Recoil_gkx('recoil_suppress_rerender_in_callback')) {
        return forceUpdate([]);
      }

      const newLoadable = getLoadable();

      if (!((_prevLoadableRef$curr = prevLoadableRef.current) !== null && _prevLoadableRef$curr !== void 0 && _prevLoadableRef$curr.is(newLoadable))) {
        // $FlowFixMe[incompatible-call]
        forceUpdate(newLoadable);
      }

      prevLoadableRef.current = newLoadable;
    }, componentName);
    /**
     * Since we're subscribing in an effect we need to update to the latest
     * value of the atom since it may have changed since we rendered. We can
     * go ahead and do that now, unless we're in the middle of a batch --
     * in which case we should do it at the end of the batch, due to the
     * following edge case: Suppose an atom is updated in another useEffect
     * of this same component. Then the following sequence of events occur:
     * 1. Atom is updated and subs fired (but we may not be subscribed
     *    yet depending on order of effects, so we miss this) Updated value
     *    is now in nextTree, but not currentTree.
     * 2. This effect happens. We subscribe and update.
     * 3. From the update we re-render and read currentTree, with old value.
     * 4. Batcher's effect sets currentTree to nextTree.
     * In this sequence we miss the update. To avoid that, add the update
     * to queuedComponentCallback if a batch is in progress.
     */

    if (storeState.nextTree) {
      store.getState().queuedComponentCallbacks_DEPRECATED.push(() => {
        // $FlowFixMe[incompatible-type]
        prevLoadableRef.current = null;
        forceUpdate([]);
      });
    } else {
      var _prevLoadableRef$curr2;

      if (!Recoil_gkx('recoil_suppress_rerender_in_callback')) {
        return forceUpdate([]);
      }

      const newLoadable = getLoadable();

      if (!((_prevLoadableRef$curr2 = prevLoadableRef.current) !== null && _prevLoadableRef$curr2 !== void 0 && _prevLoadableRef$curr2.is(newLoadable))) {
        // $FlowFixMe[incompatible-call]
        forceUpdate(newLoadable);
      }

      prevLoadableRef.current = newLoadable;
    }

    return subscription.release;
  }, [componentName, getLoadable, recoilValue, storeRef]);
  return loadable;
}
/**
  Like useRecoilValue(), but either returns the value if available or
  just undefined if not available for any reason, such as pending or error.
*/


function useRecoilValueLoadable(recoilValue) {
  if (process.env.NODE_ENV !== "production") {
    validateRecoilValue(recoilValue, 'useRecoilValueLoadable');
  }

  if (Recoil_gkx('recoil_memory_managament_2020')) {
    // eslint-disable-next-line fb-www/react-hooks
    Recoil_useRetain(recoilValue);
  }

  return {
    TRANSITION_SUPPORT: useRecoilValueLoadable_TRANSITION_SUPPORT,
    // Recoil will attemp to detect if `useSyncExternalStore()` is supported with
    // `reactMode()` before calling it.  However, sometimes the host React
    // environment supports it but uses additional React renderers (such as with
    // `react-three-fiber`) which do not.  While this is technically a user issue
    // by using a renderer with React 18+ that doesn't fully support React 18 we
    // don't want to break users if it can be avoided. As the current renderer can
    // change at runtime, we need to dynamically check and fallback if necessary.
    SYNC_EXTERNAL_STORE: currentRendererSupportsUseSyncExternalStore$1() ? useRecoilValueLoadable_SYNC_EXTERNAL_STORE : useRecoilValueLoadable_TRANSITION_SUPPORT,
    MUTABLE_SOURCE: useRecoilValueLoadable_MUTABLE_SOURCE,
    LEGACY: useRecoilValueLoadable_LEGACY
  }[reactMode$3().mode](recoilValue);
}
/**
  Returns the value represented by the RecoilValue.
  If the value is pending, it will throw a Promise to suspend the component,
  if the value is an error it will throw it for the nearest React error boundary.
  This will also subscribe the component for any updates in the value.
  */


function useRecoilValue(recoilValue) {
  if (process.env.NODE_ENV !== "production") {
    validateRecoilValue(recoilValue, 'useRecoilValue');
  }

  const storeRef = useStoreRef$2();
  const loadable = useRecoilValueLoadable(recoilValue);
  return handleLoadable(loadable, recoilValue, storeRef);
}
/**
  Returns a function that allows the value of a RecoilState to be updated, but does
  not subscribe the component to changes to that RecoilState.
*/


function useSetRecoilState(recoilState) {
  if (process.env.NODE_ENV !== "production") {
    validateRecoilValue(recoilState, 'useSetRecoilState');
  }

  const storeRef = useStoreRef$2();
  return useCallback$1(newValueOrUpdater => {
    setRecoilValue$2(storeRef.current, recoilState, newValueOrUpdater);
  }, [storeRef, recoilState]);
}
/**
  Returns a function that will reset the value of a RecoilState to its default
*/


function useResetRecoilState(recoilState) {
  if (process.env.NODE_ENV !== "production") {
    validateRecoilValue(recoilState, 'useResetRecoilState');
  }

  const storeRef = useStoreRef$2();
  return useCallback$1(() => {
    setRecoilValue$2(storeRef.current, recoilState, DEFAULT_VALUE$2);
  }, [storeRef, recoilState]);
}
/**
  Equivalent to useState(). Allows the value of the RecoilState to be read and written.
  Subsequent updates to the RecoilState will cause the component to re-render. If the
  RecoilState is pending, this will suspend the component and initiate the
  retrieval of the value. If evaluating the RecoilState resulted in an error, this will
  throw the error so that the nearest React error boundary can catch it.
*/


function useRecoilState(recoilState) {
  if (process.env.NODE_ENV !== "production") {
    validateRecoilValue(recoilState, 'useRecoilState');
  }

  return [useRecoilValue(recoilState), useSetRecoilState(recoilState)];
}
/**
  Like useRecoilState(), but does not cause Suspense or React error handling. Returns
  an object that indicates whether the RecoilState is available, pending, or
  unavailable due to an error.
*/


function useRecoilStateLoadable(recoilState) {
  if (process.env.NODE_ENV !== "production") {
    validateRecoilValue(recoilState, 'useRecoilStateLoadable');
  }

  return [useRecoilValueLoadable(recoilState), useSetRecoilState(recoilState)];
}

function useSetUnvalidatedAtomValues() {
  const storeRef = useStoreRef$2();
  return (values, transactionMetadata = {}) => {
    batchUpdates$2(() => {
      storeRef.current.addTransactionMetadata(transactionMetadata);
      values.forEach((value, key) => setUnvalidatedRecoilValue$2(storeRef.current, new AbstractRecoilValue$3(key), value));
    });
  };
}
/**
 * Experimental variants of hooks with support for useTransition()
 */


function useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(recoilValue) {
  if (process.env.NODE_ENV !== "production") {
    validateRecoilValue(recoilValue, 'useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE');

    if (!reactMode$3().early) {
      Recoil_recoverableViolation('Attepmt to use a hook with UNSTABLE_TRANSITION_SUPPORT in a rendering mode incompatible with concurrent rendering.  Try enabling the recoil_sync_external_store or recoil_transition_support GKs.');
    }
  }

  if (Recoil_gkx('recoil_memory_managament_2020')) {
    // eslint-disable-next-line fb-www/react-hooks
    Recoil_useRetain(recoilValue);
  }

  return useRecoilValueLoadable_TRANSITION_SUPPORT(recoilValue);
}

function useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(recoilValue) {
  if (process.env.NODE_ENV !== "production") {
    validateRecoilValue(recoilValue, 'useRecoilValue_TRANSITION_SUPPORT_UNSTABLE');
  }

  const storeRef = useStoreRef$2();
  const loadable = useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(recoilValue);
  return handleLoadable(loadable, recoilValue, storeRef);
}

function useRecoilState_TRANSITION_SUPPORT_UNSTABLE(recoilState) {
  if (process.env.NODE_ENV !== "production") {
    validateRecoilValue(recoilState, 'useRecoilState_TRANSITION_SUPPORT_UNSTABLE');
  }

  return [useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(recoilState), useSetRecoilState(recoilState)];
}

var Recoil_Hooks = {
  recoilComponentGetRecoilValueCount_FOR_TESTING,
  useRecoilInterface: useRecoilInterface_DEPRECATED,
  useRecoilState,
  useRecoilStateLoadable,
  useRecoilValue,
  useRecoilValueLoadable,
  useResetRecoilState,
  useSetRecoilState,
  useSetUnvalidatedAtomValues,
  useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE,
  useRecoilValue_TRANSITION_SUPPORT_UNSTABLE,
  useRecoilState_TRANSITION_SUPPORT_UNSTABLE
};

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */
/**
 * Returns a map containing all of the keys + values from the original map where
 * the given callback returned true.
 */

function filterMap(map, callback) {
  const result = new Map();

  for (const [key, value] of map) {
    if (callback(value, key)) {
      result.set(key, value);
    }
  }

  return result;
}

var Recoil_filterMap = filterMap;

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */
/**
 * Returns a set containing all of the values from the original set where
 * the given callback returned true.
 */

function filterSet(set, callback) {
  const result = new Set();

  for (const value of set) {
    if (callback(value)) {
      result.add(value);
    }
  }

  return result;
}

var Recoil_filterSet = filterSet;

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */

function mergeMaps(...maps) {
  const result = new Map();

  for (let i = 0; i < maps.length; i++) {
    const iterator = maps[i].keys();
    let nextKey;

    while (!(nextKey = iterator.next()).done) {
      // $FlowIssue[incompatible-call] - map/iterator knows nothing about flow types
      result.set(nextKey.value, maps[i].get(nextKey.value));
    }
  }

  return result;
}

var Recoil_mergeMaps = mergeMaps;

const {
  batchUpdates: batchUpdates$3
} = Recoil_Batching;

const {
  DEFAULT_VALUE: DEFAULT_VALUE$3,
  getNode: getNode$4,
  nodes: nodes$1
} = Recoil_Node;

const {
  useStoreRef: useStoreRef$3
} = Recoil_RecoilRoot;

const {
  AbstractRecoilValue: AbstractRecoilValue$4,
  setRecoilValueLoadable: setRecoilValueLoadable$1
} = Recoil_RecoilValueInterface;

const {
  SUSPENSE_TIMEOUT_MS: SUSPENSE_TIMEOUT_MS$2
} = Recoil_Retention;

const {
  cloneSnapshot: cloneSnapshot$1
} = Recoil_Snapshot$1;

const {
  useCallback: useCallback$2,
  useEffect: useEffect$4,
  useRef: useRef$5,
  useState: useState$2
} = React;

const {
  isSSR: isSSR$4
} = Recoil_Environment;















function useTransactionSubscription(callback) {
  const storeRef = useStoreRef$3();
  useEffect$4(() => {
    const sub = storeRef.current.subscribeToTransactions(callback);
    return sub.release;
  }, [callback, storeRef]);
}

function externallyVisibleAtomValuesInState(state) {
  const atomValues = state.atomValues.toMap();
  const persistedAtomContentsValues = Recoil_mapMap(Recoil_filterMap(atomValues, (v, k) => {
    const node = getNode$4(k);
    const persistence = node.persistence_UNSTABLE;
    return persistence != null && persistence.type !== 'none' && v.state === 'hasValue';
  }), v => v.contents); // Merge in nonvalidated atoms; we may not have defs for them but they will
  // all have persistence on or they wouldn't be there in the first place.

  return Recoil_mergeMaps(state.nonvalidatedAtoms.toMap(), persistedAtomContentsValues);
}

/**
  Calls the given callback after any atoms have been modified and the consequent
  component re-renders have been committed. This is intended for persisting
  the values of the atoms to storage. The stored values can then be restored
  using the useSetUnvalidatedAtomValues hook.

  The callback receives the following info:

  atomValues: The current value of every atom that is both persistable (persistence
              type not set to 'none') and whose value is available (not in an
              error or loading state).

  previousAtomValues: The value of every persistable and available atom before
               the transaction began.

  atomInfo: A map containing the persistence settings for each atom. Every key
            that exists in atomValues will also exist in atomInfo.

  modifiedAtoms: The set of atoms that were written to during the transaction.

  transactionMetadata: Arbitrary information that was added via the
          useSetUnvalidatedAtomValues hook. Useful for ignoring the useSetUnvalidatedAtomValues
          transaction, to avoid loops.
*/
function useTransactionObservation_DEPRECATED(callback) {
  useTransactionSubscription(useCallback$2(store => {
    let previousTree = store.getState().previousTree;
    const currentTree = store.getState().currentTree;

    if (!previousTree) {
      Recoil_recoverableViolation('Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil');
      previousTree = store.getState().currentTree; // attempt to trundle on
    }

    const atomValues = externallyVisibleAtomValuesInState(currentTree);
    const previousAtomValues = externallyVisibleAtomValuesInState(previousTree);
    const atomInfo = Recoil_mapMap(nodes$1, node => {
      var _node$persistence_UNS, _node$persistence_UNS2, _node$persistence_UNS3, _node$persistence_UNS4;

      return {
        persistence_UNSTABLE: {
          type: (_node$persistence_UNS = (_node$persistence_UNS2 = node.persistence_UNSTABLE) === null || _node$persistence_UNS2 === void 0 ? void 0 : _node$persistence_UNS2.type) !== null && _node$persistence_UNS !== void 0 ? _node$persistence_UNS : 'none',
          backButton: (_node$persistence_UNS3 = (_node$persistence_UNS4 = node.persistence_UNSTABLE) === null || _node$persistence_UNS4 === void 0 ? void 0 : _node$persistence_UNS4.backButton) !== null && _node$persistence_UNS3 !== void 0 ? _node$persistence_UNS3 : false
        }
      };
    }); // Filter on existance in atomValues so that externally-visible rules
    // are also applied to modified atoms (specifically exclude selectors):

    const modifiedAtoms = Recoil_filterSet(currentTree.dirtyAtoms, k => atomValues.has(k) || previousAtomValues.has(k));
    callback({
      atomValues,
      previousAtomValues,
      atomInfo,
      modifiedAtoms,
      transactionMetadata: { ...currentTree.transactionMetadata
      }
    });
  }, [callback]));
}

function useRecoilTransactionObserver(callback) {
  useTransactionSubscription(useCallback$2(store => {
    const snapshot = cloneSnapshot$1(store, 'latest');
    const previousSnapshot = cloneSnapshot$1(store, 'previous');
    callback({
      snapshot,
      previousSnapshot
    });
  }, [callback]));
} // Return a snapshot of the current state and subscribe to all state changes


function useRecoilSnapshot() {
  const storeRef = useStoreRef$3();
  const [snapshot, setSnapshot] = useState$2(() => cloneSnapshot$1(storeRef.current));
  const previousSnapshot = Recoil_usePrevious(snapshot);
  const timeoutID = useRef$5();
  const releaseRef = useRef$5();
  useTransactionSubscription(useCallback$2(store => setSnapshot(cloneSnapshot$1(store)), [])); // Retain snapshot for duration component is mounted

  useEffect$4(() => {
    const release = snapshot.retain(); // Release the retain from the rendering call

    if (timeoutID.current && !isSSR$4) {
      var _releaseRef$current;

      window.clearTimeout(timeoutID.current);
      timeoutID.current = null;
      (_releaseRef$current = releaseRef.current) === null || _releaseRef$current === void 0 ? void 0 : _releaseRef$current.call(releaseRef);
      releaseRef.current = null;
    }

    return () => {
      // Defer the release.  If "Fast Refresh"" is used then the component may
      // re-render with the same state.  The previous cleanup will then run and
      // then the new effect will run. We don't want the snapshot to be released
      // by that cleanup before the new effect has a chance to retain it again.
      // Use timeout of 10 to workaround Firefox issue: https://github.com/facebookexperimental/Recoil/issues/1936
      window.setTimeout(release, 10);
    };
  }, [snapshot]); // Retain snapshot until above effect is run.
  // Release after a threshold in case component is suspended.

  if (previousSnapshot !== snapshot && !isSSR$4) {
    // Release the previous snapshot
    if (timeoutID.current) {
      var _releaseRef$current2;

      window.clearTimeout(timeoutID.current);
      timeoutID.current = null;
      (_releaseRef$current2 = releaseRef.current) === null || _releaseRef$current2 === void 0 ? void 0 : _releaseRef$current2.call(releaseRef);
      releaseRef.current = null;
    }

    releaseRef.current = snapshot.retain();
    timeoutID.current = window.setTimeout(() => {
      var _releaseRef$current3;

      timeoutID.current = null;
      (_releaseRef$current3 = releaseRef.current) === null || _releaseRef$current3 === void 0 ? void 0 : _releaseRef$current3.call(releaseRef);
      releaseRef.current = null;
    }, SUSPENSE_TIMEOUT_MS$2);
  }

  return snapshot;
}

function gotoSnapshot(store, snapshot) {
  var _storeState$nextTree;

  const storeState = store.getState();
  const prev = (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree;
  const next = snapshot.getStore_INTERNAL().getState().currentTree;
  batchUpdates$3(() => {
    const keysToUpdate = new Set();

    for (const keys of [prev.atomValues.keys(), next.atomValues.keys()]) {
      for (const key of keys) {
        var _prev$atomValues$get, _next$atomValues$get;

        if (((_prev$atomValues$get = prev.atomValues.get(key)) === null || _prev$atomValues$get === void 0 ? void 0 : _prev$atomValues$get.contents) !== ((_next$atomValues$get = next.atomValues.get(key)) === null || _next$atomValues$get === void 0 ? void 0 : _next$atomValues$get.contents) && getNode$4(key).shouldRestoreFromSnapshots) {
          keysToUpdate.add(key);
        }
      }
    }

    keysToUpdate.forEach(key => {
      setRecoilValueLoadable$1(store, new AbstractRecoilValue$4(key), next.atomValues.has(key) ? Recoil_nullthrows(next.atomValues.get(key)) : DEFAULT_VALUE$3);
    });
    store.replaceState(state => ({ ...state,
      stateID: snapshot.getID()
    }));
  });
}

function useGotoRecoilSnapshot() {
  const storeRef = useStoreRef$3();
  return useCallback$2(snapshot => gotoSnapshot(storeRef.current, snapshot), [storeRef]);
}

var Recoil_SnapshotHooks = {
  useRecoilSnapshot,
  gotoSnapshot,
  useGotoRecoilSnapshot,
  useRecoilTransactionObserver,
  useTransactionObservation_DEPRECATED,
  useTransactionSubscription_DEPRECATED: useTransactionSubscription
};

const {
  peekNodeInfo: peekNodeInfo$2
} = Recoil_FunctionalCore;

const {
  useStoreRef: useStoreRef$4
} = Recoil_RecoilRoot;

function useGetRecoilValueInfo() {
  const storeRef = useStoreRef$4(); // $FlowFixMe[incompatible-return]

  return ({
    key
  }) => peekNodeInfo$2(storeRef.current, storeRef.current.getState().currentTree, key);
}

var Recoil_useGetRecoilValueInfo = useGetRecoilValueInfo;

const {
  reactMode: reactMode$4
} = Recoil_ReactMode;

const {
  RecoilRoot: RecoilRoot$1,
  useStoreRef: useStoreRef$5
} = Recoil_RecoilRoot;



const {
  useMemo: useMemo$2
} = React;

function useRecoilBridgeAcrossReactRoots() {
  // The test fails when using useMutableSource(), but only if act() is used
  // for the nested root.  So, this may only be a testing environment issue.
  if (reactMode$4().mode === 'MUTABLE_SOURCE') {
    // eslint-disable-next-line fb-www/no-console
    console.warn('Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.');
  }

  const store = useStoreRef$5().current;
  return useMemo$2(() => {
    // eslint-disable-next-line no-shadow
    function RecoilBridge({
      children
    }) {
      return /*#__PURE__*/React.createElement(RecoilRoot$1, {
        store_INTERNAL: store
      }, children);
    }

    return RecoilBridge;
  }, [store]);
}

var Recoil_useRecoilBridgeAcrossReactRoots = useRecoilBridgeAcrossReactRoots;

const {
  loadableWithValue: loadableWithValue$1
} = Recoil_Loadable$1;

const {
  initializeNode: initializeNode$3
} = Recoil_FunctionalCore;

const {
  DEFAULT_VALUE: DEFAULT_VALUE$4,
  getNode: getNode$5
} = Recoil_Node;

const {
  copyTreeState: copyTreeState$1,
  getRecoilValueAsLoadable: getRecoilValueAsLoadable$3,
  invalidateDownstreams: invalidateDownstreams$1,
  writeLoadableToTreeState: writeLoadableToTreeState$1
} = Recoil_RecoilValueInterface;



function isAtom(recoilValue) {
  return getNode$5(recoilValue.key).nodeType === 'atom';
}

class TransactionInterfaceImpl {
  constructor(store, treeState) {
    _defineProperty$2(this, "_store", void 0);

    _defineProperty$2(this, "_treeState", void 0);

    _defineProperty$2(this, "_changes", void 0);

    _defineProperty$2(this, "get", recoilValue => {
      if (this._changes.has(recoilValue.key)) {
        // $FlowIssue[incompatible-return]
        return this._changes.get(recoilValue.key);
      }

      if (!isAtom(recoilValue)) {
        throw Recoil_err('Reading selectors within atomicUpdate is not supported');
      }

      const loadable = getRecoilValueAsLoadable$3(this._store, recoilValue, this._treeState);

      if (loadable.state === 'hasValue') {
        return loadable.contents;
      } else if (loadable.state === 'hasError') {
        throw loadable.contents;
      } else {
        throw Recoil_err(`Expected Recoil atom ${recoilValue.key} to have a value, but it is in a loading state.`);
      }
    });

    _defineProperty$2(this, "set", (recoilState, valueOrUpdater) => {
      if (!isAtom(recoilState)) {
        throw Recoil_err('Setting selectors within atomicUpdate is not supported');
      }

      if (typeof valueOrUpdater === 'function') {
        const current = this.get(recoilState);

        this._changes.set(recoilState.key, valueOrUpdater(current)); // flowlint-line unclear-type:off

      } else {
        // Initialize atom and run effects if not initialized yet
        initializeNode$3(this._store, recoilState.key, 'set');

        this._changes.set(recoilState.key, valueOrUpdater);
      }
    });

    _defineProperty$2(this, "reset", recoilState => {
      this.set(recoilState, DEFAULT_VALUE$4);
    });

    this._store = store;
    this._treeState = treeState;
    this._changes = new Map();
  } // Allow destructing
  // eslint-disable-next-line fb-www/extra-arrow-initializer


  newTreeState_INTERNAL() {
    if (this._changes.size === 0) {
      return this._treeState;
    }

    const newState = copyTreeState$1(this._treeState);

    for (const [k, v] of this._changes) {
      writeLoadableToTreeState$1(newState, k, loadableWithValue$1(v));
    }

    invalidateDownstreams$1(this._store, newState);
    return newState;
  }

}

function atomicUpdater(store) {
  return fn => {
    store.replaceState(treeState => {
      const changeset = new TransactionInterfaceImpl(store, treeState);
      fn(changeset);
      return changeset.newTreeState_INTERNAL();
    });
  };
}

var Recoil_AtomicUpdates = {
  atomicUpdater
};

var Recoil_AtomicUpdates_1 = Recoil_AtomicUpdates.atomicUpdater;

var Recoil_AtomicUpdates$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  atomicUpdater: Recoil_AtomicUpdates_1
});

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */

function invariant(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}

var invariant_1 = invariant;

// @oss-only


var Recoil_invariant = invariant_1;

const {
  atomicUpdater: atomicUpdater$1
} = Recoil_AtomicUpdates$1;

const {
  batchUpdates: batchUpdates$4
} = Recoil_Batching;

const {
  DEFAULT_VALUE: DEFAULT_VALUE$5
} = Recoil_Node;

const {
  useStoreRef: useStoreRef$6
} = Recoil_RecoilRoot;

const {
  refreshRecoilValue: refreshRecoilValue$1,
  setRecoilValue: setRecoilValue$3
} = Recoil_RecoilValueInterface;

const {
  cloneSnapshot: cloneSnapshot$2
} = Recoil_Snapshot$1;

const {
  gotoSnapshot: gotoSnapshot$1
} = Recoil_SnapshotHooks;

const {
  useCallback: useCallback$3
} = React;









class Sentinel {}

const SENTINEL = new Sentinel();

function recoilCallback(store, fn, args, extraInterface) {
  let ret = SENTINEL;
  let releaseSnapshot;
  batchUpdates$4(() => {
    const errMsg = 'useRecoilCallback() expects a function that returns a function: ' + 'it accepts a function of the type (RecoilInterface) => (Args) => ReturnType ' + 'and returns a callback function (Args) => ReturnType, where RecoilInterface is ' + 'an object {snapshot, set, ...} and Args and ReturnType are the argument and return ' + 'types of the callback you want to create.  Please see the docs ' + 'at recoiljs.org for details.';

    if (typeof fn !== 'function') {
      throw Recoil_err(errMsg);
    } // Clone the snapshot lazily to avoid overhead if the callback does not use it.
    // Note that this means the snapshot may represent later state from when
    // the callback was called if it first accesses the snapshot asynchronously.


    const callbackInterface = Recoil_lazyProxy({ ...(extraInterface !== null && extraInterface !== void 0 ? extraInterface : {}),
      // flowlint-line unclear-type:off
      // $FlowFixMe[missing-local-annot]
      set: (node, newValue) => setRecoilValue$3(store, node, newValue),
      // $FlowFixMe[missing-local-annot]
      reset: node => setRecoilValue$3(store, node, DEFAULT_VALUE$5),
      // $FlowFixMe[missing-local-annot]
      refresh: node => refreshRecoilValue$1(store, node),
      gotoSnapshot: snapshot => gotoSnapshot$1(store, snapshot),
      transact_UNSTABLE: transaction => atomicUpdater$1(store)(transaction)
    }, {
      snapshot: () => {
        const snapshot = cloneSnapshot$2(store);
        releaseSnapshot = snapshot.retain();
        return snapshot;
      }
    });
    const callback = fn(callbackInterface);

    if (typeof callback !== 'function') {
      throw Recoil_err(errMsg);
    }

    ret = callback(...args);
  });
  !!(ret instanceof Sentinel) ? process.env.NODE_ENV !== "production" ? Recoil_invariant(false, 'batchUpdates should return immediately') : Recoil_invariant(false) : void 0;

  if (Recoil_isPromise(ret)) {
    ret = ret.finally(() => {
      var _releaseSnapshot;

      (_releaseSnapshot = releaseSnapshot) === null || _releaseSnapshot === void 0 ? void 0 : _releaseSnapshot();
    });
  } else {
    var _releaseSnapshot2;

    (_releaseSnapshot2 = releaseSnapshot) === null || _releaseSnapshot2 === void 0 ? void 0 : _releaseSnapshot2();
  }

  return ret;
}

function useRecoilCallback(fn, deps) {
  const storeRef = useStoreRef$6();
  return useCallback$3( // $FlowIssue[incompatible-call]
  (...args) => {
    return recoilCallback(storeRef.current, fn, args);
  }, deps != null ? [...deps, storeRef] : undefined // eslint-disable-line fb-www/react-hooks-deps
  );
}

var Recoil_useRecoilCallback = {
  recoilCallback,
  useRecoilCallback
};

const {
  useStoreRef: useStoreRef$7
} = Recoil_RecoilRoot;

const {
  refreshRecoilValue: refreshRecoilValue$2
} = Recoil_RecoilValueInterface;

const {
  useCallback: useCallback$4
} = React;

function useRecoilRefresher(recoilValue) {
  const storeRef = useStoreRef$7();
  return useCallback$4(() => {
    const store = storeRef.current;
    refreshRecoilValue$2(store, recoilValue);
  }, [recoilValue, storeRef]);
}

var Recoil_useRecoilRefresher = useRecoilRefresher;

const {
  atomicUpdater: atomicUpdater$2
} = Recoil_AtomicUpdates$1;

const {
  useStoreRef: useStoreRef$8
} = Recoil_RecoilRoot;

const {
  useMemo: useMemo$3
} = React;

function useRecoilTransaction(fn, deps) {
  const storeRef = useStoreRef$8();
  return useMemo$3(() => (...args) => {
    const atomicUpdate = atomicUpdater$2(storeRef.current);
    atomicUpdate(transactionInterface => {
      fn(transactionInterface)(...args);
    });
  }, deps != null ? [...deps, storeRef] : undefined // eslint-disable-line fb-www/react-hooks-deps
  );
}

var Recoil_useRecoilTransaction = useRecoilTransaction;

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */

class WrappedValue {
  constructor(value) {
    _defineProperty$2(this, "value", void 0);

    this.value = value;
  }

}

var Recoil_Wrapper = {
  WrappedValue
};

var Recoil_Wrapper_1 = Recoil_Wrapper.WrappedValue;

var Recoil_Wrapper$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  WrappedValue: Recoil_Wrapper_1
});

const {
  isFastRefreshEnabled: isFastRefreshEnabled$2
} = Recoil_ReactMode;



class ChangedPathError extends Error {}

class TreeCache {
  // $FlowIssue[unclear-type]
  constructor(options) {
    var _options$onHit, _options$onSet, _options$mapNodeValue;

    _defineProperty$2(this, "_name", void 0);

    _defineProperty$2(this, "_numLeafs", void 0);

    _defineProperty$2(this, "_root", void 0);

    _defineProperty$2(this, "_onHit", void 0);

    _defineProperty$2(this, "_onSet", void 0);

    _defineProperty$2(this, "_mapNodeValue", void 0);

    this._name = options === null || options === void 0 ? void 0 : options.name;
    this._numLeafs = 0;
    this._root = null;
    this._onHit = (_options$onHit = options === null || options === void 0 ? void 0 : options.onHit) !== null && _options$onHit !== void 0 ? _options$onHit : () => {};
    this._onSet = (_options$onSet = options === null || options === void 0 ? void 0 : options.onSet) !== null && _options$onSet !== void 0 ? _options$onSet : () => {};
    this._mapNodeValue = (_options$mapNodeValue = options === null || options === void 0 ? void 0 : options.mapNodeValue) !== null && _options$mapNodeValue !== void 0 ? _options$mapNodeValue : val => val;
  }

  size() {
    return this._numLeafs;
  } // $FlowIssue[unclear-type]


  root() {
    return this._root;
  }

  get(getNodeValue, handlers) {
    var _this$getLeafNode;

    return (_this$getLeafNode = this.getLeafNode(getNodeValue, handlers)) === null || _this$getLeafNode === void 0 ? void 0 : _this$getLeafNode.value;
  }

  getLeafNode(getNodeValue, handlers) {
    if (this._root == null) {
      return undefined;
    } // Iterate down the tree based on the current node values until we hit a leaf
    // $FlowIssue[unclear-type]


    let node = this._root;

    while (node) {
      handlers === null || handlers === void 0 ? void 0 : handlers.onNodeVisit(node);

      if (node.type === 'leaf') {
        this._onHit(node);

        return node;
      }

      const nodeValue = this._mapNodeValue(getNodeValue(node.nodeKey));

      node = node.branches.get(nodeValue);
    }

    return undefined;
  }

  set(route, value, handlers) {
    const addLeaf = () => {
      var _node2, _node3, _this$_root2, _handlers$onNodeVisit2;

      // First, setup the branch nodes for the route:
      // Iterate down the tree to find or add branch nodes following the route
      let node;
      let branchKey;

      for (const [nodeKey, nodeValue] of route) {
        var _node, _handlers$onNodeVisit, _this$_root;

        // If the previous root was a leaf, while we not have a get(), it means
        // the selector has inconsistent values or implementation changed.
        const root = this._root;

        if ((root === null || root === void 0 ? void 0 : root.type) === 'leaf') {
          throw this.invalidCacheError();
        } // node now refers to the next node down in the tree


        const parent = node; // $FlowFixMe[prop-missing]
        // $FlowFixMe[incompatible-type]

        node = parent ? parent.branches.get(branchKey) : root; // $FlowFixMe[prop-missing]
        // $FlowFixMe[incompatible-type]

        node = (_node = node) !== null && _node !== void 0 ? _node : {
          type: 'branch',
          nodeKey,
          parent,
          branches: new Map(),
          branchKey
        }; // If we found an existing node, confirm it has a consistent value

        if (node.type !== 'branch' || node.nodeKey !== nodeKey) {
          throw this.invalidCacheError();
        } // Add the branch node to the tree


        parent === null || parent === void 0 ? void 0 : parent.branches.set(branchKey, node);
        handlers === null || handlers === void 0 ? void 0 : (_handlers$onNodeVisit = handlers.onNodeVisit) === null || _handlers$onNodeVisit === void 0 ? void 0 : _handlers$onNodeVisit.call(handlers, node); // Prepare for next iteration and install root if it is new.

        branchKey = this._mapNodeValue(nodeValue);
        this._root = (_this$_root = this._root) !== null && _this$_root !== void 0 ? _this$_root : node;
      } // Second, setup the leaf node:
      // If there is an existing leaf for this route confirm it is consistent


      const oldLeaf = node ? (_node2 = node) === null || _node2 === void 0 ? void 0 : _node2.branches.get(branchKey) : this._root;

      if (oldLeaf != null && (oldLeaf.type !== 'leaf' || oldLeaf.branchKey !== branchKey)) {
        throw this.invalidCacheError();
      } // Create a new or replacement leaf.


      const leafNode = {
        type: 'leaf',
        value,
        parent: node,
        branchKey
      }; // Install the leaf and call handlers

      (_node3 = node) === null || _node3 === void 0 ? void 0 : _node3.branches.set(branchKey, leafNode);
      this._root = (_this$_root2 = this._root) !== null && _this$_root2 !== void 0 ? _this$_root2 : leafNode;
      this._numLeafs++;

      this._onSet(leafNode);

      handlers === null || handlers === void 0 ? void 0 : (_handlers$onNodeVisit2 = handlers.onNodeVisit) === null || _handlers$onNodeVisit2 === void 0 ? void 0 : _handlers$onNodeVisit2.call(handlers, leafNode);
    };

    try {
      addLeaf();
    } catch (error) {
      // If the cache was stale or observed inconsistent values, such as with
      // Fast Refresh, then clear it and rebuild with the new values.
      if (error instanceof ChangedPathError) {
        this.clear();
        addLeaf();
      } else {
        throw error;
      }
    }
  } // Returns true if leaf was actually deleted from the tree


  delete(leaf) {
    const root = this.root();

    if (!root) {
      return false;
    }

    if (leaf === root) {
      this._root = null;
      this._numLeafs = 0;
      return true;
    } // Iterate up from the leaf deleteing it from it's parent's branches.


    let node = leaf.parent;
    let branchKey = leaf.branchKey;

    while (node) {
      var _node4;

      node.branches.delete(branchKey); // Stop iterating if we hit the root.

      if (node === root) {
        if (node.branches.size === 0) {
          this._root = null;
          this._numLeafs = 0;
        } else {
          this._numLeafs--;
        }

        return true;
      } // Stop iterating if there are other branches since we don't need to
      // remove any more nodes.


      if (node.branches.size > 0) {
        break;
      } // Iterate up to our parent


      branchKey = (_node4 = node) === null || _node4 === void 0 ? void 0 : _node4.branchKey;
      node = node.parent;
    } // Confirm that the leaf we are deleting is actually attached to our tree


    for (; node !== root; node = node.parent) {
      if (node == null) {
        return false;
      }
    }

    this._numLeafs--;
    return true;
  }

  clear() {
    this._numLeafs = 0;
    this._root = null;
  }

  invalidCacheError() {
    const CHANGED_PATH_ERROR_MESSAGE = isFastRefreshEnabled$2() ? 'Possible Fast Refresh module reload detected.  ' + 'This may also be caused by an selector returning inconsistent values. ' + 'Resetting cache.' : 'Invalid cache values.  This happens when selectors do not return ' + 'consistent values for the same input dependency values.  That may also ' + 'be caused when using Fast Refresh to change a selector implementation.  ' + 'Resetting cache.';
    Recoil_recoverableViolation(CHANGED_PATH_ERROR_MESSAGE + (this._name != null ? ` - ${this._name}` : ''));
    throw new ChangedPathError();
  }

}

var Recoil_TreeCache = {
  TreeCache
};

var Recoil_TreeCache_1 = Recoil_TreeCache.TreeCache;

var Recoil_TreeCache$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  TreeCache: Recoil_TreeCache_1
});

class LRUCache {
  constructor(options) {
    var _options$mapKey;

    _defineProperty$2(this, "_maxSize", void 0);

    _defineProperty$2(this, "_size", void 0);

    _defineProperty$2(this, "_head", void 0);

    _defineProperty$2(this, "_tail", void 0);

    _defineProperty$2(this, "_map", void 0);

    _defineProperty$2(this, "_keyMapper", void 0);

    this._maxSize = options.maxSize;
    this._size = 0;
    this._head = null;
    this._tail = null;
    this._map = new Map();
    this._keyMapper = (_options$mapKey = options.mapKey) !== null && _options$mapKey !== void 0 ? _options$mapKey : v => v;
  }

  head() {
    return this._head;
  }

  tail() {
    return this._tail;
  }

  size() {
    return this._size;
  }

  maxSize() {
    return this._maxSize;
  }

  has(key) {
    return this._map.has(this._keyMapper(key));
  }

  get(key) {
    const mappedKey = this._keyMapper(key);

    const node = this._map.get(mappedKey);

    if (!node) {
      return undefined;
    }

    this.set(key, node.value);
    return node.value;
  }

  set(key, val) {
    const mappedKey = this._keyMapper(key);

    const existingNode = this._map.get(mappedKey);

    if (existingNode) {
      this.delete(key);
    }

    const head = this.head();
    const node = {
      key,
      right: head,
      left: null,
      value: val
    };

    if (head) {
      head.left = node;
    } else {
      this._tail = node;
    }

    this._map.set(mappedKey, node);

    this._head = node;
    this._size++;

    this._maybeDeleteLRU();
  }

  _maybeDeleteLRU() {
    if (this.size() > this.maxSize()) {
      this.deleteLru();
    }
  }

  deleteLru() {
    const tail = this.tail();

    if (tail) {
      this.delete(tail.key);
    }
  }

  delete(key) {
    const mappedKey = this._keyMapper(key);

    if (!this._size || !this._map.has(mappedKey)) {
      return;
    }

    const node = Recoil_nullthrows(this._map.get(mappedKey));
    const right = node.right;
    const left = node.left;

    if (right) {
      right.left = node.left;
    }

    if (left) {
      left.right = node.right;
    }

    if (node === this.head()) {
      this._head = right;
    }

    if (node === this.tail()) {
      this._tail = left;
    }

    this._map.delete(mappedKey);

    this._size--;
  }

  clear() {
    this._size = 0;
    this._head = null;
    this._tail = null;
    this._map = new Map();
  }

}

var Recoil_LRUCache = {
  LRUCache
};

var Recoil_LRUCache_1 = Recoil_LRUCache.LRUCache;

var Recoil_LRUCache$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LRUCache: Recoil_LRUCache_1
});

const {
  LRUCache: LRUCache$1
} = Recoil_LRUCache$1;

const {
  TreeCache: TreeCache$1
} = Recoil_TreeCache$1;

function treeCacheLRU({
  name,
  maxSize,
  mapNodeValue = v => v
}) {
  const lruCache = new LRUCache$1({
    maxSize
  });
  const cache = new TreeCache$1({
    name,
    mapNodeValue,
    onHit: node => {
      lruCache.set(node, true);
    },
    onSet: node => {
      const lruNode = lruCache.tail();
      lruCache.set(node, true);

      if (lruNode && cache.size() > maxSize) {
        // $FlowFixMe[incompatible-call]
        cache.delete(lruNode.key);
      }
    }
  });
  return cache;
}

var Recoil_treeCacheLRU = treeCacheLRU;

const TIME_WARNING_THRESHOLD_MS = 15;

function stringify(x, opt, key) {
  // A optimization to avoid the more expensive JSON.stringify() for simple strings
  // This may lose protection for u2028 and u2029, though.
  if (typeof x === 'string' && !x.includes('"') && !x.includes('\\')) {
    return `"${x}"`;
  } // Handle primitive types


  switch (typeof x) {
    case 'undefined':
      return '';
    // JSON.stringify(undefined) returns undefined, but we always want to return a string

    case 'boolean':
      return x ? 'true' : 'false';

    case 'number':
    case 'symbol':
      // case 'bigint': // BigInt is not supported in www
      return String(x);

    case 'string':
      // Add surrounding quotes and escape internal quotes
      return JSON.stringify(x);

    case 'function':
      if ((opt === null || opt === void 0 ? void 0 : opt.allowFunctions) !== true) {
        throw Recoil_err('Attempt to serialize function in a Recoil cache key');
      }

      return `__FUNCTION(${x.name})__`;
  }

  if (x === null) {
    return 'null';
  } // Fallback case for unknown types


  if (typeof x !== 'object') {
    var _JSON$stringify;

    return (_JSON$stringify = JSON.stringify(x)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : '';
  } // Deal with all promises as equivalent for now.


  if (Recoil_isPromise(x)) {
    return '__PROMISE__';
  } // Arrays handle recursive stringification


  if (Array.isArray(x)) {
    // $FlowFixMe[missing-local-annot]
    return `[${x.map((v, i) => stringify(v, opt, i.toString()))}]`;
  } // If an object defines a toJSON() method, then use that to override the
  // serialization.  This matches the behavior of JSON.stringify().
  // Pass the key for compatibility.
  // Immutable.js collections define this method to allow us to serialize them.


  if (typeof x.toJSON === 'function') {
    // flowlint-next-line unclear-type: off
    return stringify(x.toJSON(key), opt, key);
  } // For built-in Maps, sort the keys in a stable order instead of the
  // default insertion order.  Support non-string keys.


  if (x instanceof Map) {
    const obj = {};

    for (const [k, v] of x) {
      // Stringify will escape any nested quotes
      obj[typeof k === 'string' ? k : stringify(k, opt)] = v;
    }

    return stringify(obj, opt, key);
  } // For built-in Sets, sort the keys in a stable order instead of the
  // default insertion order.


  if (x instanceof Set) {
    return stringify( // $FlowFixMe[missing-local-annot]
    Array.from(x).sort((a, b) => stringify(a, opt).localeCompare(stringify(b, opt))), opt, key);
  } // Anything else that is iterable serialize as an Array.


  if (Symbol !== undefined && x[Symbol.iterator] != null && typeof x[Symbol.iterator] === 'function') {
    // flowlint-next-line unclear-type: off
    return stringify(Array.from(x), opt, key);
  } // For all other Objects, sort the keys in a stable order.


  return `{${Object.keys(x).filter(k => x[k] !== undefined).sort() // stringify the key to add quotes and escape any nested slashes or quotes.
  .map(k => `${stringify(k, opt)}:${stringify(x[k], opt, k)}`).join(',')}}`;
} // Utility similar to JSON.stringify() except:
// * Serialize built-in Sets as an Array
// * Serialize built-in Maps as an Object.  Supports non-string keys.
// * Serialize other iterables as arrays
// * Sort the keys of Objects and Maps to have a stable order based on string conversion.
//    This overrides their default insertion order.
// * Still uses toJSON() of any object to override serialization
// * Support Symbols (though don't guarantee uniqueness)
// * We could support BigInt, but Flow doesn't seem to like it.
// See Recoil_stableStringify-test.js for examples


function stableStringify(x, opt = {
  allowFunctions: false
}) {
  if (process.env.NODE_ENV !== "production") {
    if (typeof window !== 'undefined') {
      const startTime = window.performance ? window.performance.now() : 0;
      const str = stringify(x, opt);
      const endTime = window.performance ? window.performance.now() : 0;

      if (endTime - startTime > TIME_WARNING_THRESHOLD_MS) {
        /* eslint-disable fb-www/no-console */
        console.groupCollapsed(`Recoil: Spent ${endTime - startTime}ms computing a cache key`);
        console.warn(x, str);
        console.groupEnd();
        /* eslint-enable fb-www/no-console */
      }

      return str;
    }
  }

  return stringify(x, opt);
}

var Recoil_stableStringify = stableStringify;

const {
  TreeCache: TreeCache$2
} = Recoil_TreeCache$1;









const defaultPolicy = {
  equality: 'reference',
  eviction: 'keep-all',
  maxSize: Infinity
};

function treeCacheFromPolicy({
  equality = defaultPolicy.equality,
  eviction = defaultPolicy.eviction,
  maxSize = defaultPolicy.maxSize
} = defaultPolicy, name) {
  const valueMapper = getValueMapper(equality);
  return getTreeCache(eviction, maxSize, valueMapper, name);
}

function getValueMapper(equality) {
  switch (equality) {
    case 'reference':
      return val => val;

    case 'value':
      return val => Recoil_stableStringify(val);
  }

  throw Recoil_err(`Unrecognized equality policy ${equality}`);
}

function getTreeCache(eviction, maxSize, mapNodeValue, name) {
  switch (eviction) {
    case 'keep-all':
      return new TreeCache$2({
        name,
        mapNodeValue
      });

    case 'lru':
      return Recoil_treeCacheLRU({
        name,
        maxSize: Recoil_nullthrows(maxSize),
        mapNodeValue
      });

    case 'most-recent':
      return Recoil_treeCacheLRU({
        name,
        maxSize: 1,
        mapNodeValue
      });
  }

  throw Recoil_err(`Unrecognized eviction policy ${eviction}`);
}

var Recoil_treeCacheFromPolicy = treeCacheFromPolicy;

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */

function isNode$1(object) {
  var _ownerDocument, _doc$defaultView;

  if (typeof window === 'undefined') {
    return false;
  }

  const doc = object != null ? (_ownerDocument = object.ownerDocument) !== null && _ownerDocument !== void 0 ? _ownerDocument : object : document;
  const defaultView = (_doc$defaultView = doc.defaultView) !== null && _doc$defaultView !== void 0 ? _doc$defaultView : window;
  return !!(object != null && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

var Recoil_isNode = isNode$1;

const {
  isReactNative: isReactNative$1,
  isWindow: isWindow$1$1
} = Recoil_Environment;





function shouldNotBeFrozen(value) {
  // Primitives and functions:
  if (value === null || typeof value !== 'object') {
    return true;
  } // React elements:


  switch (typeof value.$$typeof) {
    case 'symbol':
      return true;

    case 'number':
      return true;
  } // Immutable structures:


  if (value['@@__IMMUTABLE_ITERABLE__@@'] != null || value['@@__IMMUTABLE_KEYED__@@'] != null || value['@@__IMMUTABLE_INDEXED__@@'] != null || value['@@__IMMUTABLE_ORDERED__@@'] != null || value['@@__IMMUTABLE_RECORD__@@'] != null) {
    return true;
  } // DOM nodes:


  if (Recoil_isNode(value)) {
    return true;
  }

  if (Recoil_isPromise(value)) {
    return true;
  }

  if (value instanceof Error) {
    return true;
  }

  if (ArrayBuffer.isView(value)) {
    return true;
  } // Some environments, just as Jest, don't work with the instanceof check


  if (!isReactNative$1 && isWindow$1$1(value)) {
    return true;
  }

  return false;
} // Recursively freeze a value to enforce it is read-only.
// This may also have minimal performance improvements for enumerating
// objects (based on browser implementations, of course)


function deepFreezeValue(value) {
  if (typeof value !== 'object' || shouldNotBeFrozen(value)) {
    return;
  }

  Object.freeze(value); // Make all properties read-only

  for (const key in value) {
    // $FlowIssue[method-unbinding] added when improving typing for this parameters
    if (Object.prototype.hasOwnProperty.call(value, key)) {
      const prop = value[key]; // Prevent infinite recurssion for circular references.

      if (typeof prop === 'object' && prop != null && !Object.isFrozen(prop)) {
        deepFreezeValue(prop);
      }
    }
  }

  Object.seal(value); // This also makes existing properties non-configurable.
}

var Recoil_deepFreezeValue = deepFreezeValue;

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * This is a stub for some integration into FB internal stuff
 *
 * 
 * @format
 * @oncall recoil
 */
function startPerfBlock(_id) {
  return () => null;
}

var Recoil_PerformanceTimings = {
  startPerfBlock
};

const {
  isLoadable: isLoadable$1,
  loadableWithError: loadableWithError$1,
  loadableWithPromise: loadableWithPromise$1,
  loadableWithValue: loadableWithValue$2
} = Recoil_Loadable$1;

const {
  WrappedValue: WrappedValue$1
} = Recoil_Wrapper$1;



const {
  getNodeLoadable: getNodeLoadable$2,
  peekNodeLoadable: peekNodeLoadable$1,
  setNodeValue: setNodeValue$3
} = Recoil_FunctionalCore;

const {
  saveDepsToStore: saveDepsToStore$1
} = Recoil_Graph;

const {
  DEFAULT_VALUE: DEFAULT_VALUE$6,
  getConfigDeletionHandler: getConfigDeletionHandler$1,
  getNode: getNode$6,
  registerNode: registerNode$1
} = Recoil_Node;

const {
  isRecoilValue: isRecoilValue$3
} = Recoil_RecoilValue$1;

const {
  markRecoilValueModified: markRecoilValueModified$1
} = Recoil_RecoilValueInterface;

const {
  retainedByOptionWithDefault: retainedByOptionWithDefault$1
} = Recoil_Retention;

const {
  recoilCallback: recoilCallback$1
} = Recoil_useRecoilCallback;



















const {
  startPerfBlock: startPerfBlock$1
} = Recoil_PerformanceTimings;



class Canceled {}

const CANCELED = new Canceled();
/**
 * An ExecutionID is an arbitrary ID that lets us distinguish executions from
 * each other. This is necessary as we need a way of solving this problem:
 * "given 3 async executions, only update state for the 'latest' execution when
 * it finishes running regardless of when the other 2 finish". ExecutionIDs
 * provide a convenient way of identifying executions so that we can track and
 * manage them over time.
 */

const dependencyStack = []; // for detecting circular dependencies.

const waitingStores = new Map();

const getNewExecutionID = (() => {
  let executionID = 0;
  return () => executionID++;
})();
/* eslint-disable no-redeclare */


function selector(options) {
  let recoilValue = null;
  const {
    key,
    get,
    cachePolicy_UNSTABLE: cachePolicy
  } = options;
  const set = options.set != null ? options.set : undefined; // flow

  if (process.env.NODE_ENV !== "production") {
    if (typeof key !== 'string') {
      throw Recoil_err('A key option with a unique string value must be provided when creating a selector.');
    }

    if (typeof get !== 'function') {
      throw Recoil_err('Selectors must specify a get callback option to get the selector value.');
    }
  } // This is every discovered dependency across all executions


  const discoveredDependencyNodeKeys = new Set();
  const cache = Recoil_treeCacheFromPolicy(cachePolicy !== null && cachePolicy !== void 0 ? cachePolicy : {
    equality: 'reference',
    eviction: 'keep-all'
  }, key);
  const retainedBy = retainedByOptionWithDefault$1(options.retainedBy_UNSTABLE);
  const executionInfoMap = new Map();
  let liveStoresCount = 0;

  function selectorIsLive() {
    return !Recoil_gkx('recoil_memory_managament_2020') || liveStoresCount > 0;
  }

  function selectorInit(store) {
    store.getState().knownSelectors.add(key);
    liveStoresCount++;
    return () => {
      liveStoresCount--;
    };
  }

  function selectorShouldDeleteConfigOnRelease() {
    return getConfigDeletionHandler$1(key) !== undefined && !selectorIsLive();
  }

  function resolveAsync(store, state, executionID, loadable, depValues) {
    setCache(state, loadable, depValues);
    notifyStoresOfResolvedAsync(store, executionID);
  }

  function notifyStoresOfResolvedAsync(store, executionID) {
    if (isLatestExecution(store, executionID)) {
      clearExecutionInfo(store);
    }

    notifyWaitingStores(executionID, true);
  }
  /**
   * Notify stores to pull the selector again if a new async dep was discovered.
   * 1) Async selector adds a new dep but doesn't resolve yet.
   *    Note that deps for an async selector are based on the state when the
   *    evaluation started, in order to provide a consistent picture of state.
   * 2) But, new value of dep based on the current state might cause the selector
   *    to resolve or resolve differently.
   * 3) Therefore, this notification will pull the selector based on the current
   *    state for the components
   */


  function notifyStoresOfNewAsyncDep(store, executionID) {
    if (isLatestExecution(store, executionID)) {
      const executionInfo = Recoil_nullthrows(getExecutionInfo(store));
      executionInfo.stateVersions.clear();
      notifyWaitingStores(executionID, false);
    }
  }

  function notifyWaitingStores(executionID, clearWaitlist) {
    const stores = waitingStores.get(executionID);

    if (stores != null) {
      for (const waitingStore of stores) {
        markRecoilValueModified$1(waitingStore, Recoil_nullthrows(recoilValue));
      }

      if (clearWaitlist) {
        waitingStores.delete(executionID);
      }
    }
  }

  function markStoreWaitingForResolvedAsync(store, executionID) {
    let stores = waitingStores.get(executionID);

    if (stores == null) {
      waitingStores.set(executionID, stores = new Set());
    }

    stores.add(store);
  }
  /**
   * This function attaches a then() and a catch() to a promise that was
   * returned from a selector's get() (either explicitly or implicitly by
   * running a function that uses the "async" keyword). If a selector's get()
   * returns a promise, we have two possibilities:
   *
   * 1. The promise will resolve, in which case it will have completely finished
   *    executing without any remaining pending dependencies. No more retries
   *    are needed and we can proceed with updating the cache and notifying
   *    subscribers (if it is the latest execution, otherwise only the cache
   *    will be updated and subscriptions will not be fired). This is the case
   *    handled by the attached then() handler.
   *
   * 2. The promise will throw because it either has an error or it came across
   *    an async dependency that has not yet resolved, in which case we will
   *    call wrapDepdencyPromise(), whose responsibility is to handle dependency
   *    promises. This case is handled by the attached catch() handler.
   *
   * Both branches will eventually resolve to the final result of the selector
   * (or an error if a real error occurred).
   *
   * The execution will run to completion even if it is stale, and its value
   * will be cached. But stale executions will not update global state or update
   * executionInfo as that is the responsibility of the 'latest' execution.
   *
   * Note this function should not be passed a promise that was thrown--AKA a
   * dependency promise. Dependency promises should be passed to
   * wrapPendingDependencyPromise()).
   */


  function wrapResultPromise(store, promise, state, depValues, executionID, loadingDepsState) {
    return promise.then(value => {
      if (!selectorIsLive()) {
        // The selector was released since the request began; ignore the response.
        clearExecutionInfo(store);
        throw CANCELED;
      }

      const loadable = loadableWithValue$2(value);
      resolveAsync(store, state, executionID, loadable, depValues);
      return value;
    }).catch(errorOrPromise => {
      if (!selectorIsLive()) {
        // The selector was released since the request began; ignore the response.
        clearExecutionInfo(store);
        throw CANCELED;
      }

      if (Recoil_isPromise(errorOrPromise)) {
        return wrapPendingDependencyPromise(store, errorOrPromise, state, depValues, executionID, loadingDepsState);
      }

      const loadable = loadableWithError$1(errorOrPromise);
      resolveAsync(store, state, executionID, loadable, depValues);
      throw errorOrPromise;
    });
  }
  /**
   * This function attaches a then() and a catch() to a promise that was
   * thrown from a selector's get(). If a selector's get() throws a promise,
   * we have two possibilities:
   *
   * 1. The promise will resolve, meaning one of our selector's dependencies is
   *    now available and we should "retry" our get() by running it again. This
   *    is the case handled by the attached then() handler.
   *
   * 2. The promise will throw because something went wrong with the dependency
   *    promise (in other words a real error occurred). This case is handled by
   *    the attached catch() handler. If the dependency promise throws, it is
   *    _always_ a real error and not another dependency promise (any dependency
   *    promises would have been handled upstream).
   *
   * The then() branch will eventually resolve to the final result of the
   * selector (or an error if a real error occurs), and the catch() will always
   * resolve to an error because the dependency promise is a promise that was
   * wrapped upstream, meaning it will only resolve to its real value or to a
   * real error.
   *
   * The execution will run to completion even if it is stale, and its value
   * will be cached. But stale executions will not update global state or update
   * executionInfo as that is the responsibility of the 'latest' execution.
   *
   * Note this function should not be passed a promise that was returned from
   * get(). The intention is that this function is only passed promises that
   * were thrown due to a pending dependency. Promises returned by get() should
   * be passed to wrapResultPromise() instead.
   */


  function wrapPendingDependencyPromise(store, promise, state, existingDeps, executionID, loadingDepsState) {
    return promise.then(resolvedDep => {
      if (!selectorIsLive()) {
        // The selector was released since the request began; ignore the response.
        clearExecutionInfo(store);
        throw CANCELED;
      } // Check if we are handling a pending Recoil dependency or if the user
      // threw their own Promise to "suspend" a selector evaluation.  We need
      // to check that the loadingDepPromise actually matches the promise that
      // we caught in case the selector happened to catch the promise we threw
      // for a pending Recoil dependency from `getRecoilValue()` and threw
      // their own promise instead.


      if (loadingDepsState.loadingDepKey != null && loadingDepsState.loadingDepPromise === promise) {
        /**
         * Note for async atoms, this means we are changing the atom's value
         * in the store for the given version. This should be alright because
         * the version of state is now stale and a new version will have
         * already been triggered by the atom being resolved (see this logic
         * in Recoil_atom.js)
         */
        state.atomValues.set(loadingDepsState.loadingDepKey, loadableWithValue$2(resolvedDep));
      } else {
        /**
         * If resolvedDepKey is not defined, the promise was a user-thrown
         * promise. User-thrown promises are an advanced feature and they
         * should be avoided in almost all cases. Using `loadable.map()` inside
         * of selectors for loading loadables and then throwing that mapped
         * loadable's promise is an example of a user-thrown promise.
         *
         * When we hit a user-thrown promise, we have to bail out of an optimization
         * where we bypass calculating selector cache keys for selectors that
         * have been previously seen for a given state (these selectors are saved in
         * state.atomValues) to avoid stale state as we have no way of knowing
         * what state changes happened (if any) in result to the promise resolving.
         *
         * Ideally we would only bail out selectors that are in the chain of
         * dependencies for this selector, but there's currently no way to get
         * a full list of a selector's downstream nodes because the state that
         * is executing may be a discarded tree (so store.getGraph(state.version)
         * will be empty), and the full dep tree may not be in the selector
         * caches in the case where the selector's cache was cleared. To solve
         * for this we would have to keep track of all running selector
         * executions and their downstream deps. Because this only covers edge
         * cases, that complexity might not be justifyable.
         */
        store.getState().knownSelectors.forEach(nodeKey => {
          state.atomValues.delete(nodeKey);
        });
      }
      /**
       * Optimization: Now that the dependency has resolved, let's try hitting
       * the cache in case the dep resolved to a value we have previously seen.
       *
       * TODO:
       * Note this optimization is not perfect because it only prevents re-executions
       * _after_ the point where an async dependency is found. Any code leading
       * up to the async dependency may have run unnecessarily. The ideal case
       * would be to wait for the async dependency to resolve first, check the
       * cache, and prevent _any_ execution of the selector if the resulting
       * value of the dependency leads to a path that is found in the cache.
       * The ideal case is more difficult to implement as it would require that
       * we capture and wait for the the async dependency right after checking
       * the cache. The current approach takes advantage of the fact that running
       * the selector already has a code path that lets us exit early when
       * an async dep resolves.
       */


      const cachedLoadable = getLoadableFromCacheAndUpdateDeps(store, state);

      if (cachedLoadable && cachedLoadable.state !== 'loading') {
        /**
         * This has to notify stores of a resolved async, even if there is no
         * current pending execution for the following case:
         * 1) A component renders with this pending loadable.
         * 2) The upstream dependency resolves.
         * 3) While processing some other selector it reads this one, such as
         *    while traversing its dependencies.  At this point it gets the
         *    new resolved value synchronously and clears the current
         *    execution ID.  The component wasn't getting the value itself,
         *    though, so it still has the pending loadable.
         * 4) When this code executes the current execution id was cleared
         *    and it wouldn't notify the component of the new value.
         *
         * I think this is only an issue with "early" rendering since the
         * components got their value using the in-progress execution.
         * We don't have a unit test for this case yet.  I'm not sure it is
         * necessary with recoil_transition_support mode.
         */
        if (isLatestExecution(store, executionID) || getExecutionInfo(store) == null) {
          notifyStoresOfResolvedAsync(store, executionID);
        }

        if (cachedLoadable.state === 'hasValue') {
          return cachedLoadable.contents;
        } else {
          throw cachedLoadable.contents;
        }
      }
      /**
       * If this execution is stale, let's check to see if there is some in
       * progress execution with a matching state. If we find a match, then
       * we can take the value from that in-progress execution. Note this may
       * sound like an edge case, but may be very common in cases where a
       * loading dependency resolves from loading to having a value (thus
       * possibly triggering a re-render), and React re-renders before the
       * chained .then() functions run, thus starting a new execution as the
       * dep has changed value. Without this check we will run the selector
       * twice (once in the new execution and once again in this .then(), so
       * this check is necessary to keep unnecessary re-executions to a
       * minimum).
       *
       * Also note this code does not check across all executions that may be
       * running. It only optimizes for the _latest_ execution per store as
       * we currently do not maintain a list of all currently running executions.
       * This means in some cases we may run selectors more than strictly
       * necessary when there are multiple executions running for the same
       * selector. This may be a valid tradeoff as checking for dep changes
       * across all in-progress executions may take longer than just
       * re-running the selector. This will be app-dependent, and maybe in the
       * future we can make the behavior configurable. An ideal fix may be
       * to extend the tree cache to support caching loading states.
       */


      if (!isLatestExecution(store, executionID)) {
        const executionInfo = getInProgressExecutionInfo(store, state);

        if (executionInfo != null) {
          /**
           * Returning promise here without wrapping as the wrapper logic was
           * already done upstream when this promise was generated.
           */
          return executionInfo.loadingLoadable.contents;
        }
      } // Retry the selector evaluation now that the dependency has resolved


      const [loadable, depValues] = evaluateSelectorGetter(store, state, executionID);

      if (loadable.state !== 'loading') {
        resolveAsync(store, state, executionID, loadable, depValues);
      }

      if (loadable.state === 'hasError') {
        throw loadable.contents;
      }

      return loadable.contents;
    }).catch(error => {
      // The selector was released since the request began; ignore the response.
      if (error instanceof Canceled) {
        throw CANCELED;
      }

      if (!selectorIsLive()) {
        clearExecutionInfo(store);
        throw CANCELED;
      }

      const loadable = loadableWithError$1(error);
      resolveAsync(store, state, executionID, loadable, existingDeps);
      throw error;
    });
  }

  function updateDeps(store, state, deps, executionID) {
    var _store$getState, _store$getState$curre, _store$getState2, _store$getState2$next;

    if (isLatestExecution(store, executionID) || state.version === ((_store$getState = store.getState()) === null || _store$getState === void 0 ? void 0 : (_store$getState$curre = _store$getState.currentTree) === null || _store$getState$curre === void 0 ? void 0 : _store$getState$curre.version) || state.version === ((_store$getState2 = store.getState()) === null || _store$getState2 === void 0 ? void 0 : (_store$getState2$next = _store$getState2.nextTree) === null || _store$getState2$next === void 0 ? void 0 : _store$getState2$next.version)) {
      var _store$getState$nextT, _store$getState3, _store$getState3$next;

      saveDepsToStore$1(key, deps, store, (_store$getState$nextT = (_store$getState3 = store.getState()) === null || _store$getState3 === void 0 ? void 0 : (_store$getState3$next = _store$getState3.nextTree) === null || _store$getState3$next === void 0 ? void 0 : _store$getState3$next.version) !== null && _store$getState$nextT !== void 0 ? _store$getState$nextT : store.getState().currentTree.version);
    }

    for (const nodeKey of deps) {
      discoveredDependencyNodeKeys.add(nodeKey);
    }
  }

  function evaluateSelectorGetter(store, state, executionID) {
    const endPerfBlock = startPerfBlock$1(key); // TODO T63965866: use execution ID here

    let duringSynchronousExecution = true;
    let duringAsynchronousExecution = true;

    const finishEvaluation = () => {
      endPerfBlock();
      duringAsynchronousExecution = false;
    };

    let result;
    let resultIsError = false;
    let loadable;
    const loadingDepsState = {
      loadingDepKey: null,
      loadingDepPromise: null
    };
    /**
     * Starting a fresh set of deps that we'll be using to update state. We're
     * starting a new set versus adding it in existing state deps because
     * the version of state that we update deps for may be a more recent version
     * than the version the selector was called with. This is because the latest
     * execution will update the deps of the current/latest version of state
     * (This is safe to do because the fact that the selector is the latest
     * execution means the deps we discover below are our best guess at the
     * deps for the current/latest state in the store)
     */

    const depValues = new Map();

    function getRecoilValue({
      key: depKey
    }) {
      const depLoadable = getNodeLoadable$2(store, state, depKey);
      depValues.set(depKey, depLoadable); // We need to update asynchronous dependencies as we go so the selector
      // knows if it has to restart evaluation if one of them is updated before
      // the asynchronous selector completely resolves.

      if (!duringSynchronousExecution) {
        updateDeps(store, state, new Set(depValues.keys()), executionID);
        notifyStoresOfNewAsyncDep(store, executionID);
      }

      switch (depLoadable.state) {
        case 'hasValue':
          return depLoadable.contents;

        case 'hasError':
          throw depLoadable.contents;

        case 'loading':
          loadingDepsState.loadingDepKey = depKey;
          loadingDepsState.loadingDepPromise = depLoadable.contents;
          throw depLoadable.contents;
      }

      throw Recoil_err('Invalid Loadable state');
    }

    const getCallback = fn => {
      return (...args) => {
        if (duringAsynchronousExecution) {
          throw Recoil_err('Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.');
        }

        !(recoilValue != null) ? process.env.NODE_ENV !== "production" ? Recoil_invariant(false, 'Recoil Value can never be null') : Recoil_invariant(false) : void 0;
        return recoilCallback$1(store, fn, args, {
          node: recoilValue
        } // flowlint-line unclear-type:off
        );
      };
    };

    try {
      result = get({
        get: getRecoilValue,
        getCallback
      });
      result = isRecoilValue$3(result) ? getRecoilValue(result) : result;

      if (isLoadable$1(result)) {
        if (result.state === 'hasError') {
          resultIsError = true;
        }

        result = result.contents;
      }

      if (Recoil_isPromise(result)) {
        result = wrapResultPromise(store, result, state, depValues, executionID, loadingDepsState).finally(finishEvaluation);
      } else {
        finishEvaluation();
      }

      result = result instanceof WrappedValue$1 ? result.value : result;
    } catch (errorOrDepPromise) {
      result = errorOrDepPromise;

      if (Recoil_isPromise(result)) {
        result = wrapPendingDependencyPromise(store, result, state, depValues, executionID, loadingDepsState).finally(finishEvaluation);
      } else {
        resultIsError = true;
        finishEvaluation();
      }
    }

    if (resultIsError) {
      loadable = loadableWithError$1(result);
    } else if (Recoil_isPromise(result)) {
      loadable = loadableWithPromise$1(result);
    } else {
      loadable = loadableWithValue$2(result);
    }

    duringSynchronousExecution = false;
    updateExecutionInfoDepValues(store, executionID, depValues);
    updateDeps(store, state, new Set(depValues.keys()), executionID);
    return [loadable, depValues];
  }

  function getLoadableFromCacheAndUpdateDeps(store, state) {
    // First, look up in the state cache
    // If it's here, then the deps in the store should already be valid.
    let cachedLoadable = state.atomValues.get(key);

    if (cachedLoadable != null) {
      return cachedLoadable;
    } // Second, look up in the selector cache and update the deps in the store


    const depsAfterCacheLookup = new Set();

    try {
      cachedLoadable = cache.get(nodeKey => {
        !(typeof nodeKey === 'string') ? process.env.NODE_ENV !== "production" ? Recoil_invariant(false, 'Cache nodeKey is type string') : Recoil_invariant(false) : void 0;
        return getNodeLoadable$2(store, state, nodeKey).contents;
      }, {
        onNodeVisit: node => {
          if (node.type === 'branch' && node.nodeKey !== key) {
            depsAfterCacheLookup.add(node.nodeKey);
          }
        }
      });
    } catch (error) {
      throw Recoil_err(`Problem with cache lookup for selector "${key}": ${error.message}`);
    }

    if (cachedLoadable) {
      var _getExecutionInfo;

      // Cache the results in the state to allow for cheaper lookup than
      // iterating the tree cache of dependencies.
      state.atomValues.set(key, cachedLoadable);
      /**
       * Ensure store contains correct dependencies if we hit the cache so that
       * the store deps and cache are in sync for a given state. This is important
       * because store deps are normally updated when new executions are created,
       * but cache hits don't trigger new executions but they still _may_ signify
       * a change in deps in the store if the store deps for this state are empty
       * or stale.
       */

      updateDeps(store, state, depsAfterCacheLookup, (_getExecutionInfo = getExecutionInfo(store)) === null || _getExecutionInfo === void 0 ? void 0 : _getExecutionInfo.executionID);
    }

    return cachedLoadable;
  }
  /**
   * Given a tree state, this function returns a Loadable of the current state.
   *
   * The selector's get() function will only be re-evaluated if _both_ of the
   * following statements are true:
   *
   * 1. The current dep values from the given state produced a cache key that
   *    was not found in the cache.
   * 2. There is no currently running async execution OR there is an
   *    async execution that is running, but after comparing the dep values in
   *    the given state with the dep values that the execution has discovered so
   *    far we find that at least one dep value has changed, in which case we
   *    start a new execution (the previously running execution will continue to
   *    run to completion, but only the new execution will be deemed the
   *    'latest' execution, meaning it will be the only execution that will
   *    update global state when it is finished. Any non-latest executions will
   *    run to completion and update the selector cache but not global state).
   */


  function getSelectorLoadableAndUpdateDeps(store, state) {
    // First, see if our current state is cached
    const cachedVal = getLoadableFromCacheAndUpdateDeps(store, state);

    if (cachedVal != null) {
      clearExecutionInfo(store);
      return cachedVal;
    } // Second, check if there is already an ongoing execution based on the current state


    const inProgressExecutionInfo = getInProgressExecutionInfo(store, state);

    if (inProgressExecutionInfo != null) {
      var _inProgressExecutionI;

      if (((_inProgressExecutionI = inProgressExecutionInfo.loadingLoadable) === null || _inProgressExecutionI === void 0 ? void 0 : _inProgressExecutionI.state) === 'loading') {
        markStoreWaitingForResolvedAsync(store, inProgressExecutionInfo.executionID);
      } // FIXME: check after the fact to see if we made the right choice by waiting


      return inProgressExecutionInfo.loadingLoadable;
    } // Third, start a new evaluation of the selector


    const newExecutionID = getNewExecutionID();
    const [loadable, newDepValues] = evaluateSelectorGetter(store, state, newExecutionID);
    /**
     * Conditionally updates the cache with a given loadable.
     *
     * We only cache loadables that are not loading because our cache keys are
     * based on dep values, which are in an unfinished state for loadables that
     * have a 'loading' state (new deps may be discovered while the selector
     * runs its async code). We never want to cache partial dependencies b/c it
     * could lead to errors, such as prematurely returning the result based on a
     * partial list of deps-- we need the full list of deps to ensure that we
     * are returning the correct result from cache.
     */

    if (loadable.state === 'loading') {
      setExecutionInfo(store, newExecutionID, loadable, newDepValues, state);
      markStoreWaitingForResolvedAsync(store, newExecutionID);
    } else {
      clearExecutionInfo(store);
      setCache(state, loadable, newDepValues);
    }

    return loadable;
  }
  /**
   * Searches execution info across all stores to see if there is an in-progress
   * execution whose dependency values match the values of the requesting store.
   */


  function getInProgressExecutionInfo(store, state) {
    // Sort the pending executions so that our current store is checked first.
    const pendingExecutions = Recoil_concatIterables([executionInfoMap.has(store) ? [Recoil_nullthrows(executionInfoMap.get(store))] : [], Recoil_mapIterable(Recoil_filterIterable(executionInfoMap, ([s]) => s !== store), ([, execInfo]) => execInfo)]);

    function anyDepChanged(execDepValues) {
      for (const [depKey, execLoadable] of execDepValues) {
        if (!getNodeLoadable$2(store, state, depKey).is(execLoadable)) {
          return true;
        }
      }

      return false;
    }

    for (const execInfo of pendingExecutions) {
      if ( // If this execution was already checked to be valid with this version
      // of state, then let's use it!
      execInfo.stateVersions.get(state.version) || // If the deps for the execution match our current state, then it's valid
      !anyDepChanged(execInfo.depValuesDiscoveredSoFarDuringAsyncWork)) {
        execInfo.stateVersions.set(state.version, true);
        return execInfo;
      } else {
        execInfo.stateVersions.set(state.version, false);
      }
    }

    return undefined;
  }

  function getExecutionInfo(store) {
    return executionInfoMap.get(store);
  }
  /**
   * This function will update the selector's execution info when the selector
   * has either finished running an execution or has started a new execution. If
   * the given loadable is in a 'loading' state, the intention is that a new
   * execution has started. Otherwise, the intention is that an execution has
   * just finished.
   */


  function setExecutionInfo(store, newExecutionID, loadable, depValues, state) {
    executionInfoMap.set(store, {
      depValuesDiscoveredSoFarDuringAsyncWork: depValues,
      executionID: newExecutionID,
      loadingLoadable: loadable,
      stateVersions: new Map([[state.version, true]])
    });
  }

  function updateExecutionInfoDepValues(store, executionID, depValues) {
    // We only need to bother updating the deps for the latest execution because
    // that's all getInProgressExecutionInfo() will be looking for.
    if (isLatestExecution(store, executionID)) {
      const executionInfo = getExecutionInfo(store);

      if (executionInfo != null) {
        executionInfo.depValuesDiscoveredSoFarDuringAsyncWork = depValues;
      }
    }
  }

  function clearExecutionInfo(store) {
    executionInfoMap.delete(store);
  }

  function isLatestExecution(store, executionID) {
    var _getExecutionInfo2;

    return executionID === ((_getExecutionInfo2 = getExecutionInfo(store)) === null || _getExecutionInfo2 === void 0 ? void 0 : _getExecutionInfo2.executionID);
  }
  /**
   * FIXME: dep keys should take into account the state of the loadable to
   * prevent the edge case where a loadable with an error and a loadable with
   * an error as a value are treated as the same thing incorrectly. For example
   * these two should be treated differently:
   *
   * selector({key: '', get: () => new Error('hi')});
   * selector({key: '', get () => {throw new Error('hi')}});
   *
   * With current implementation they are treated the same
   */


  function depValuesToDepRoute(depValues) {
    return Array.from(depValues.entries()).map(([depKey, valLoadable]) => [depKey, valLoadable.contents]);
  }

  function setCache(state, loadable, depValues) {
    if (process.env.NODE_ENV !== "production") {
      if (loadable.state !== 'loading' && Boolean(options.dangerouslyAllowMutability) === false) {
        Recoil_deepFreezeValue(loadable.contents);
      }
    }

    state.atomValues.set(key, loadable);

    try {
      cache.set(depValuesToDepRoute(depValues), loadable);
    } catch (error) {
      throw Recoil_err(`Problem with setting cache for selector "${key}": ${error.message}`);
    }
  }

  function detectCircularDependencies(fn) {
    if (dependencyStack.includes(key)) {
      const message = `Recoil selector has circular dependencies: ${dependencyStack.slice(dependencyStack.indexOf(key)).join(' \u2192 ')}`;
      return loadableWithError$1(Recoil_err(message));
    }

    dependencyStack.push(key);

    try {
      return fn();
    } finally {
      dependencyStack.pop();
    }
  }

  function selectorPeek(store, state) {
    const cachedLoadable = state.atomValues.get(key);

    if (cachedLoadable != null) {
      return cachedLoadable;
    }

    return cache.get(nodeKey => {
      var _peekNodeLoadable;

      !(typeof nodeKey === 'string') ? process.env.NODE_ENV !== "production" ? Recoil_invariant(false, 'Cache nodeKey is type string') : Recoil_invariant(false) : void 0;
      return (_peekNodeLoadable = peekNodeLoadable$1(store, state, nodeKey)) === null || _peekNodeLoadable === void 0 ? void 0 : _peekNodeLoadable.contents;
    });
  }

  function selectorGet(store, state) {
    return detectCircularDependencies(() => getSelectorLoadableAndUpdateDeps(store, state));
  }

  function invalidateSelector(state) {
    state.atomValues.delete(key);
  }

  function clearSelectorCache(store, treeState) {
    !(recoilValue != null) ? process.env.NODE_ENV !== "production" ? Recoil_invariant(false, 'Recoil Value can never be null') : Recoil_invariant(false) : void 0;

    for (const nodeKey of discoveredDependencyNodeKeys) {
      var _node$clearCache;

      const node = getNode$6(nodeKey);
      (_node$clearCache = node.clearCache) === null || _node$clearCache === void 0 ? void 0 : _node$clearCache.call(node, store, treeState);
    }

    discoveredDependencyNodeKeys.clear();
    invalidateSelector(treeState);
    cache.clear();
    markRecoilValueModified$1(store, recoilValue);
  }

  if (set != null) {
    /**
     * ES5 strict mode prohibits defining non-top-level function declarations,
     * so don't use function declaration syntax here
     */
    const selectorSet = (store, state, newValue) => {
      let syncSelectorSetFinished = false;
      const writes = new Map();

      function getRecoilValue({
        key: depKey
      }) {
        if (syncSelectorSetFinished) {
          throw Recoil_err('Recoil: Async selector sets are not currently supported.');
        }

        const loadable = getNodeLoadable$2(store, state, depKey);

        if (loadable.state === 'hasValue') {
          return loadable.contents;
        } else if (loadable.state === 'loading') {
          const msg = `Getting value of asynchronous atom or selector "${depKey}" in a pending state while setting selector "${key}" is not yet supported.`;
          Recoil_recoverableViolation(msg);
          throw Recoil_err(msg);
        } else {
          throw loadable.contents;
        }
      }

      function setRecoilState(recoilState, valueOrUpdater // $FlowFixMe[missing-local-annot]
      ) {
        if (syncSelectorSetFinished) {
          const msg = 'Recoil: Async selector sets are not currently supported.';
          Recoil_recoverableViolation(msg);
          throw Recoil_err(msg);
        }

        const setValue = typeof valueOrUpdater === 'function' ? // cast to any because we can't restrict type S from being a function itself without losing support for opaque types
        // flowlint-next-line unclear-type:off
        valueOrUpdater(getRecoilValue(recoilState)) : valueOrUpdater;
        const upstreamWrites = setNodeValue$3(store, state, recoilState.key, setValue);
        upstreamWrites.forEach((v, k) => writes.set(k, v));
      }

      function resetRecoilState(recoilState) {
        setRecoilState(recoilState, DEFAULT_VALUE$6);
      }

      const ret = set({
        set: setRecoilState,
        get: getRecoilValue,
        reset: resetRecoilState
      }, newValue); // set should be a void method, but if the user makes it `async`, then it
      // will return a Promise, which we don't currently support.

      if (ret !== undefined) {
        throw Recoil_isPromise(ret) ? Recoil_err('Recoil: Async selector sets are not currently supported.') : Recoil_err('Recoil: selector set should be a void function.');
      }

      syncSelectorSetFinished = true;
      return writes;
    };

    return recoilValue = registerNode$1({
      key,
      nodeType: 'selector',
      peek: selectorPeek,
      get: selectorGet,
      set: selectorSet,
      init: selectorInit,
      invalidate: invalidateSelector,
      clearCache: clearSelectorCache,
      shouldDeleteConfigOnRelease: selectorShouldDeleteConfigOnRelease,
      dangerouslyAllowMutability: options.dangerouslyAllowMutability,
      shouldRestoreFromSnapshots: false,
      retainedBy
    });
  } else {
    return recoilValue = registerNode$1({
      key,
      nodeType: 'selector',
      peek: selectorPeek,
      get: selectorGet,
      init: selectorInit,
      invalidate: invalidateSelector,
      clearCache: clearSelectorCache,
      shouldDeleteConfigOnRelease: selectorShouldDeleteConfigOnRelease,
      dangerouslyAllowMutability: options.dangerouslyAllowMutability,
      shouldRestoreFromSnapshots: false,
      retainedBy
    });
  }
}
/* eslint-enable no-redeclare */
// $FlowIssue[incompatible-use]
// $FlowFixMe[missing-local-annot]


selector.value = value => new WrappedValue$1(value);

var Recoil_selector = selector;

// @fb-only: import type {ScopeRules} from 'Recoil_ScopedAtom';
// @fb-only: const {scopedAtom} = require('Recoil_ScopedAtom');
const {
  isLoadable: isLoadable$2,
  loadableWithError: loadableWithError$2,
  loadableWithPromise: loadableWithPromise$2,
  loadableWithValue: loadableWithValue$3
} = Recoil_Loadable$1;

const {
  WrappedValue: WrappedValue$2
} = Recoil_Wrapper$1;

const {
  peekNodeInfo: peekNodeInfo$3
} = Recoil_FunctionalCore;

const {
  DEFAULT_VALUE: DEFAULT_VALUE$7,
  DefaultValue: DefaultValue$2,
  getConfigDeletionHandler: getConfigDeletionHandler$2,
  registerNode: registerNode$2,
  setConfigDeletionHandler: setConfigDeletionHandler$1
} = Recoil_Node;

const {
  isRecoilValue: isRecoilValue$4
} = Recoil_RecoilValue$1;

const {
  getRecoilValueAsLoadable: getRecoilValueAsLoadable$4,
  markRecoilValueModified: markRecoilValueModified$2,
  setRecoilValue: setRecoilValue$4,
  setRecoilValueLoadable: setRecoilValueLoadable$2
} = Recoil_RecoilValueInterface;

const {
  retainedByOptionWithDefault: retainedByOptionWithDefault$2
} = Recoil_Retention;















const unwrap = x => x instanceof WrappedValue$2 ? x.value : x;

function baseAtom(options) {
  const {
    key,
    persistence_UNSTABLE: persistence
  } = options;
  const retainedBy = retainedByOptionWithDefault$2(options.retainedBy_UNSTABLE);
  let liveStoresCount = 0;

  function unwrapPromise(promise) {
    return loadableWithPromise$2(promise.then(value => {
      defaultLoadable = loadableWithValue$3(value);
      return value;
    }).catch(error => {
      defaultLoadable = loadableWithError$2(error);
      throw error;
    }));
  }

  let defaultLoadable = Recoil_isPromise(options.default) ? unwrapPromise(options.default) : isLoadable$2(options.default) ? options.default.state === 'loading' ? unwrapPromise(options.default.contents) : options.default : // $FlowFixMe[incompatible-call]
  loadableWithValue$3(unwrap(options.default));
  maybeFreezeValueOrPromise(defaultLoadable.contents);
  let cachedAnswerForUnvalidatedValue = undefined; // Cleanup handlers for this atom
  // Rely on stable reference equality of the store to use it as a key per <RecoilRoot>

  const cleanupEffectsByStore = new Map();

  function maybeFreezeValueOrPromise(valueOrPromise) {
    if (process.env.NODE_ENV !== "production") {
      if (options.dangerouslyAllowMutability !== true) {
        if (Recoil_isPromise(valueOrPromise)) {
          return valueOrPromise.then(value => {
            Recoil_deepFreezeValue(value);
            return value;
          });
        } else {
          Recoil_deepFreezeValue(valueOrPromise);
          return valueOrPromise;
        }
      }
    }

    return valueOrPromise;
  }

  function wrapPendingPromise(store, promise) {
    const wrappedPromise = promise.then(value => {
      var _store$getState$nextT, _state$atomValues$get;

      const state = (_store$getState$nextT = store.getState().nextTree) !== null && _store$getState$nextT !== void 0 ? _store$getState$nextT : store.getState().currentTree;

      if (((_state$atomValues$get = state.atomValues.get(key)) === null || _state$atomValues$get === void 0 ? void 0 : _state$atomValues$get.contents) === wrappedPromise) {
        setRecoilValue$4(store, node, value);
      }

      return value;
    }).catch(error => {
      var _store$getState$nextT2, _state$atomValues$get2;

      const state = (_store$getState$nextT2 = store.getState().nextTree) !== null && _store$getState$nextT2 !== void 0 ? _store$getState$nextT2 : store.getState().currentTree;

      if (((_state$atomValues$get2 = state.atomValues.get(key)) === null || _state$atomValues$get2 === void 0 ? void 0 : _state$atomValues$get2.contents) === wrappedPromise) {
        setRecoilValueLoadable$2(store, node, loadableWithError$2(error));
      }

      throw error;
    });
    return wrappedPromise;
  }

  function initAtom(store, initState, trigger) {
    var _options$effects;

    liveStoresCount++;

    const cleanupAtom = () => {
      var _cleanupEffectsByStor;

      liveStoresCount--;
      (_cleanupEffectsByStor = cleanupEffectsByStore.get(store)) === null || _cleanupEffectsByStor === void 0 ? void 0 : _cleanupEffectsByStor.forEach(cleanup => cleanup());
      cleanupEffectsByStore.delete(store);
    };

    store.getState().knownAtoms.add(key); // Setup async defaults to notify subscribers when they resolve

    if (defaultLoadable.state === 'loading') {
      const notifyDefaultSubscribers = () => {
        var _store$getState$nextT3;

        const state = (_store$getState$nextT3 = store.getState().nextTree) !== null && _store$getState$nextT3 !== void 0 ? _store$getState$nextT3 : store.getState().currentTree;

        if (!state.atomValues.has(key)) {
          markRecoilValueModified$2(store, node);
        }
      };

      defaultLoadable.contents.finally(notifyDefaultSubscribers);
    } ///////////////////
    // Run Atom Effects
    ///////////////////


    const effects = (_options$effects = options.effects) !== null && _options$effects !== void 0 ? _options$effects : options.effects_UNSTABLE;

    if (effects != null) {
      // This state is scoped by Store, since this is in the initAtom() closure
      let initValue = DEFAULT_VALUE$7;
      let isDuringInit = true;
      let isInitError = false;
      let pendingSetSelf = null;

      function getLoadable(recoilValue) {
        // Normally we can just get the current value of another atom.
        // But for our own value we need to check if there is a pending
        // initialized value or get the fallback default value.
        if (isDuringInit && recoilValue.key === key) {
          // Cast T to S
          const retValue = initValue; // flowlint-line unclear-type:off

          return retValue instanceof DefaultValue$2 ? peekAtom(store, initState) // flowlint-line unclear-type:off
          : Recoil_isPromise(retValue) ? loadableWithPromise$2(retValue.then(v => v instanceof DefaultValue$2 ? // Cast T to S
          defaultLoadable.toPromise() // flowlint-line unclear-type:off
          : v)) : // $FlowFixMe[incompatible-call]
          loadableWithValue$3(retValue);
        }

        return getRecoilValueAsLoadable$4(store, recoilValue);
      }

      function getPromise(recoilValue) {
        return getLoadable(recoilValue).toPromise();
      }

      function getInfo_UNSTABLE(recoilValue) {
        var _store$getState$nextT4;

        const info = peekNodeInfo$3(store, (_store$getState$nextT4 = store.getState().nextTree) !== null && _store$getState$nextT4 !== void 0 ? _store$getState$nextT4 : store.getState().currentTree, recoilValue.key);
        return isDuringInit && recoilValue.key === key && !(initValue instanceof DefaultValue$2) ? { ...info,
          isSet: true,
          loadable: getLoadable(recoilValue)
        } : info;
      }

      const setSelf = effect => valueOrUpdater => {
        if (isDuringInit) {
          const currentLoadable = getLoadable(node);
          const currentValue = currentLoadable.state === 'hasValue' ? currentLoadable.contents : DEFAULT_VALUE$7;
          initValue = typeof valueOrUpdater === 'function' ? // cast to any because we can't restrict T from being a function without losing support for opaque types
          valueOrUpdater(currentValue) // flowlint-line unclear-type:off
          : valueOrUpdater;

          if (Recoil_isPromise(initValue)) {
            initValue = initValue.then(value => {
              // Avoid calling onSet() when setSelf() initializes with a Promise
              pendingSetSelf = {
                effect,
                value
              };
              return value;
            });
          }
        } else {
          if (Recoil_isPromise(valueOrUpdater)) {
            throw Recoil_err('Setting atoms to async values is not implemented.');
          }

          if (typeof valueOrUpdater !== 'function') {
            pendingSetSelf = {
              effect,
              value: unwrap(valueOrUpdater)
            };
          }

          setRecoilValue$4(store, node, typeof valueOrUpdater === 'function' ? currentValue => {
            const newValue = unwrap( // cast to any because we can't restrict T from being a function without losing support for opaque types
            valueOrUpdater(currentValue) // flowlint-line unclear-type:off
            ); // $FlowFixMe[incompatible-type]

            pendingSetSelf = {
              effect,
              value: newValue
            };
            return newValue;
          } : unwrap(valueOrUpdater));
        }
      };

      const resetSelf = effect => () => setSelf(effect)(DEFAULT_VALUE$7);

      const onSet = effect => handler => {
        var _cleanupEffectsByStor2;

        const {
          release
        } = store.subscribeToTransactions(currentStore => {
          var _currentTree$atomValu;

          // eslint-disable-next-line prefer-const
          let {
            currentTree,
            previousTree
          } = currentStore.getState();

          if (!previousTree) {
            Recoil_recoverableViolation('Transaction subscribers notified without a next tree being present -- this is a bug in Recoil');
            previousTree = currentTree; // attempt to trundle on
          }

          const newLoadable = (_currentTree$atomValu = currentTree.atomValues.get(key)) !== null && _currentTree$atomValu !== void 0 ? _currentTree$atomValu : defaultLoadable;

          if (newLoadable.state === 'hasValue') {
            var _previousTree$atomVal, _pendingSetSelf, _pendingSetSelf2, _pendingSetSelf3;

            const newValue = newLoadable.contents;
            const oldLoadable = (_previousTree$atomVal = previousTree.atomValues.get(key)) !== null && _previousTree$atomVal !== void 0 ? _previousTree$atomVal : defaultLoadable;
            const oldValue = oldLoadable.state === 'hasValue' ? oldLoadable.contents : DEFAULT_VALUE$7; // TODO This isn't actually valid, use as a placeholder for now.
            // Ignore atom value changes that were set via setSelf() in the same effect.
            // We will still properly call the handler if there was a subsequent
            // set from something other than an atom effect which was batched
            // with the `setSelf()` call.  However, we may incorrectly ignore
            // the handler if the subsequent batched call happens to set the
            // atom to the exact same value as the `setSelf()`.   But, in that
            // case, it was kind of a noop, so the semantics are debatable..

            if (((_pendingSetSelf = pendingSetSelf) === null || _pendingSetSelf === void 0 ? void 0 : _pendingSetSelf.effect) !== effect || ((_pendingSetSelf2 = pendingSetSelf) === null || _pendingSetSelf2 === void 0 ? void 0 : _pendingSetSelf2.value) !== newValue) {
              handler(newValue, oldValue, !currentTree.atomValues.has(key));
            } else if (((_pendingSetSelf3 = pendingSetSelf) === null || _pendingSetSelf3 === void 0 ? void 0 : _pendingSetSelf3.effect) === effect) {
              pendingSetSelf = null;
            }
          }
        }, key);
        cleanupEffectsByStore.set(store, [...((_cleanupEffectsByStor2 = cleanupEffectsByStore.get(store)) !== null && _cleanupEffectsByStor2 !== void 0 ? _cleanupEffectsByStor2 : []), release]);
      };

      for (const effect of effects) {
        try {
          const cleanup = effect({
            node,
            storeID: store.storeID,
            parentStoreID_UNSTABLE: store.parentStoreID,
            trigger,
            setSelf: setSelf(effect),
            resetSelf: resetSelf(effect),
            onSet: onSet(effect),
            getPromise,
            getLoadable,
            getInfo_UNSTABLE
          });

          if (cleanup != null) {
            var _cleanupEffectsByStor3;

            cleanupEffectsByStore.set(store, [...((_cleanupEffectsByStor3 = cleanupEffectsByStore.get(store)) !== null && _cleanupEffectsByStor3 !== void 0 ? _cleanupEffectsByStor3 : []), cleanup]);
          }
        } catch (error) {
          initValue = error;
          isInitError = true;
        }
      }

      isDuringInit = false; // Mutate initial state in place since we know there are no other subscribers
      // since we are the ones initializing on first use.

      if (!(initValue instanceof DefaultValue$2)) {
        var _store$getState$nextT5;

        const initLoadable = isInitError ? loadableWithError$2(initValue) : Recoil_isPromise(initValue) ? loadableWithPromise$2(wrapPendingPromise(store, initValue)) : loadableWithValue$3(unwrap(initValue));
        maybeFreezeValueOrPromise(initLoadable.contents);
        initState.atomValues.set(key, initLoadable); // If there is a pending transaction, then also mutate the next state tree.
        // This could happen if the atom was first initialized in an action that
        // also updated some other atom's state.

        (_store$getState$nextT5 = store.getState().nextTree) === null || _store$getState$nextT5 === void 0 ? void 0 : _store$getState$nextT5.atomValues.set(key, initLoadable);
      }
    }

    return cleanupAtom;
  }

  function peekAtom(_store, state) {
    var _ref, _state$atomValues$get3;

    return (_ref = (_state$atomValues$get3 = state.atomValues.get(key)) !== null && _state$atomValues$get3 !== void 0 ? _state$atomValues$get3 : cachedAnswerForUnvalidatedValue) !== null && _ref !== void 0 ? _ref : defaultLoadable;
  }

  function getAtom(_store, state) {
    if (state.atomValues.has(key)) {
      // Atom value is stored in state:
      return Recoil_nullthrows(state.atomValues.get(key));
    } else if (state.nonvalidatedAtoms.has(key)) {
      // Atom value is stored but needs validation before use.
      // We might have already validated it and have a cached validated value:
      if (cachedAnswerForUnvalidatedValue != null) {
        return cachedAnswerForUnvalidatedValue;
      }

      if (persistence == null) {
        Recoil_expectationViolation(`Tried to restore a persisted value for atom ${key} but it has no persistence settings.`);
        return defaultLoadable;
      }

      const nonvalidatedValue = state.nonvalidatedAtoms.get(key);
      const validatorResult = persistence.validator(nonvalidatedValue, DEFAULT_VALUE$7);
      const validatedValueLoadable = validatorResult instanceof DefaultValue$2 ? defaultLoadable : loadableWithValue$3(validatorResult);
      cachedAnswerForUnvalidatedValue = validatedValueLoadable;
      return cachedAnswerForUnvalidatedValue;
    } else {
      return defaultLoadable;
    }
  }

  function invalidateAtom() {
    cachedAnswerForUnvalidatedValue = undefined;
  }

  function setAtom(_store, state, newValue) {
    // Bail out if we're being set to the existing value, or if we're being
    // reset but have no stored value (validated or unvalidated) to reset from:
    if (state.atomValues.has(key)) {
      const existing = Recoil_nullthrows(state.atomValues.get(key));

      if (existing.state === 'hasValue' && newValue === existing.contents) {
        return new Map();
      }
    } else if (!state.nonvalidatedAtoms.has(key) && newValue instanceof DefaultValue$2) {
      return new Map();
    }

    maybeFreezeValueOrPromise(newValue);
    cachedAnswerForUnvalidatedValue = undefined; // can be released now if it was previously in use

    return new Map().set(key, loadableWithValue$3(newValue));
  }

  function shouldDeleteConfigOnReleaseAtom() {
    return getConfigDeletionHandler$2(key) !== undefined && liveStoresCount <= 0;
  }

  const node = registerNode$2({
    key,
    nodeType: 'atom',
    peek: peekAtom,
    get: getAtom,
    set: setAtom,
    init: initAtom,
    invalidate: invalidateAtom,
    shouldDeleteConfigOnRelease: shouldDeleteConfigOnReleaseAtom,
    dangerouslyAllowMutability: options.dangerouslyAllowMutability,
    persistence_UNSTABLE: options.persistence_UNSTABLE ? {
      type: options.persistence_UNSTABLE.type,
      backButton: options.persistence_UNSTABLE.backButton
    } : undefined,
    shouldRestoreFromSnapshots: true,
    retainedBy
  });
  return node;
} // prettier-ignore


function atom(options) {
  if (process.env.NODE_ENV !== "production") {
    if (typeof options.key !== 'string') {
      throw Recoil_err('A key option with a unique string value must be provided when creating an atom.');
    }
  }

  const { // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS,
    ...restOptions
  } = options;
  const optionsDefault = 'default' in options ? // $FlowIssue[incompatible-type] No way to refine in Flow that property is not defined
  options.default : new Promise(() => {});

  if (isRecoilValue$4(optionsDefault) // Continue to use atomWithFallback for promise defaults for scoped atoms
  // for now, since scoped atoms don't support async defaults
  // @fb-only: || (isPromise(optionsDefault) && scopeRules_APPEND_ONLY_READ_THE_DOCS)
  // @fb-only: || (isLoadable(optionsDefault) && scopeRules_APPEND_ONLY_READ_THE_DOCS)
  ) {
    return atomWithFallback({ ...restOptions,
      default: optionsDefault // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS,

    }); // @fb-only: } else if (scopeRules_APPEND_ONLY_READ_THE_DOCS
    // @fb-only: && !isPromise(optionsDefault)
    // @fb-only: && !isLoadable(optionsDefault)
    // @fb-only: ) {
    // @fb-only: return scopedAtom<T>({
    // @fb-only: ...restOptions,
    // @fb-only: default: unwrap<T>(optionsDefault),
    // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS,
    // @fb-only: });
  } else {
    return baseAtom({ ...restOptions,
      default: optionsDefault
    });
  }
}

function atomWithFallback(options) {
  const base = atom({ ...options,
    default: DEFAULT_VALUE$7,
    persistence_UNSTABLE: options.persistence_UNSTABLE === undefined ? undefined : { ...options.persistence_UNSTABLE,
      validator: storedValue => storedValue instanceof DefaultValue$2 ? storedValue : Recoil_nullthrows(options.persistence_UNSTABLE).validator(storedValue, DEFAULT_VALUE$7)
    },
    // TODO Hack for now.
    effects: options.effects,
    // flowlint-line unclear-type: off
    effects_UNSTABLE: options.effects_UNSTABLE // flowlint-line unclear-type: off

  }); // $FlowFixMe[incompatible-call]

  const sel = Recoil_selector({
    key: `${options.key}__withFallback`,
    get: ({
      get
    }) => {
      const baseValue = get(base);
      return baseValue instanceof DefaultValue$2 ? options.default : baseValue;
    },
    // $FlowFixMe[incompatible-call]
    set: ({
      set
    }, newValue) => set(base, newValue),
    // This selector does not need to cache as it is a wrapper selector
    // and the selector within the wrapper selector will have a cache
    // option by default
    cachePolicy_UNSTABLE: {
      eviction: 'most-recent'
    },
    dangerouslyAllowMutability: options.dangerouslyAllowMutability
  });
  setConfigDeletionHandler$1(sel.key, getConfigDeletionHandler$2(options.key));
  return sel;
} // $FlowFixMe[missing-local-annot]


atom.value = value => new WrappedValue$2(value);

var Recoil_atom = atom;

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall recoil
 */

class MapCache {
  constructor(options) {
    var _options$mapKey;

    _defineProperty$2(this, "_map", void 0);

    _defineProperty$2(this, "_keyMapper", void 0);

    this._map = new Map();
    this._keyMapper = (_options$mapKey = options === null || options === void 0 ? void 0 : options.mapKey) !== null && _options$mapKey !== void 0 ? _options$mapKey : v => v;
  }

  size() {
    return this._map.size;
  }

  has(key) {
    return this._map.has(this._keyMapper(key));
  }

  get(key) {
    return this._map.get(this._keyMapper(key));
  }

  set(key, val) {
    this._map.set(this._keyMapper(key), val);
  }

  delete(key) {
    this._map.delete(this._keyMapper(key));
  }

  clear() {
    this._map.clear();
  }

}

var Recoil_MapCache = {
  MapCache
};

var Recoil_MapCache_1 = Recoil_MapCache.MapCache;

var Recoil_MapCache$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  MapCache: Recoil_MapCache_1
});

const {
  LRUCache: LRUCache$2
} = Recoil_LRUCache$1;

const {
  MapCache: MapCache$1
} = Recoil_MapCache$1;







const defaultPolicy$1 = {
  equality: 'reference',
  eviction: 'none',
  maxSize: Infinity
};

function cacheFromPolicy({
  equality = defaultPolicy$1.equality,
  eviction = defaultPolicy$1.eviction,
  maxSize = defaultPolicy$1.maxSize
} = defaultPolicy$1) {
  const valueMapper = getValueMapper$1(equality);
  const cache = getCache(eviction, maxSize, valueMapper);
  return cache;
}

function getValueMapper$1(equality) {
  switch (equality) {
    case 'reference':
      return val => val;

    case 'value':
      return val => Recoil_stableStringify(val);
  }

  throw Recoil_err(`Unrecognized equality policy ${equality}`);
}

function getCache(eviction, maxSize, mapKey) {
  switch (eviction) {
    case 'keep-all':
      return new MapCache$1({
        mapKey
      });

    case 'lru':
      return new LRUCache$2({
        mapKey,
        maxSize: Recoil_nullthrows(maxSize)
      });

    case 'most-recent':
      return new LRUCache$2({
        mapKey,
        maxSize: 1
      });
  }

  throw Recoil_err(`Unrecognized eviction policy ${eviction}`);
}

var Recoil_cacheFromPolicy = cacheFromPolicy;

// @fb-only: import type {ScopeRules} from 'Recoil_ScopedAtom';


const {
  setConfigDeletionHandler: setConfigDeletionHandler$2
} = Recoil_Node;





// Process scopeRules to handle any entries which are functions taking parameters
// prettier-ignore
// @fb-only: function mapScopeRules<P>(
// @fb-only: scopeRules?: ParameterizedScopeRules<P>,
// @fb-only: param: P,
// @fb-only: ): ScopeRules | void {
// @fb-only: return scopeRules?.map(rule =>
// @fb-only: Array.isArray(rule)
// @fb-only: ? rule.map(entry => (typeof entry === 'function' ? entry(param) : entry))
// @fb-only: : rule,
// @fb-only: );
// @fb-only: }

/*
A function which returns an atom based on the input parameter.

Each unique parameter returns a unique atom. E.g.,

  const f = atomFamily(...);
  f({a: 1}) => an atom
  f({a: 2}) => a different atom

This allows components to persist local, private state using atoms.  Each
instance of the component may have a different key, which it uses as the
parameter for a family of atoms; in this way, each component will have
its own atom not shared by other instances.  These state keys may be composed
into children's state keys as well.
*/
function atomFamily(options) {
  var _options$cachePolicyF, _options$cachePolicyF2;

  const atomCache = Recoil_cacheFromPolicy({
    equality: (_options$cachePolicyF = (_options$cachePolicyF2 = options.cachePolicyForParams_UNSTABLE) === null || _options$cachePolicyF2 === void 0 ? void 0 : _options$cachePolicyF2.equality) !== null && _options$cachePolicyF !== void 0 ? _options$cachePolicyF : 'value',
    eviction: 'keep-all'
  }); // Simple atomFamily implementation to cache individual atoms based
  // on the parameter value equality.

  return params => {
    var _stableStringify, _options$effects;

    const cachedAtom = atomCache.get(params);

    if (cachedAtom != null) {
      return cachedAtom;
    }

    const {
      cachePolicyForParams_UNSTABLE,
      ...atomOptions
    } = options;
    const optionsDefault = 'default' in options ? // $FlowIssue[incompatible-type] No way to refine in Flow that property is not defined
    options.default : new Promise(() => {});
    const newAtom = Recoil_atom({ ...atomOptions,
      key: `${options.key}__${(_stableStringify = Recoil_stableStringify(params)) !== null && _stableStringify !== void 0 ? _stableStringify : 'void'}`,
      default: typeof optionsDefault === 'function' ? // The default was parameterized
      // Flow doesn't know that T isn't a function, so we need to case to any
      // $FlowIssue[incompatible-use]
      optionsDefault(params) : // Default may be a static value, promise, or RecoilValue
      optionsDefault,
      retainedBy_UNSTABLE: typeof options.retainedBy_UNSTABLE === 'function' ? options.retainedBy_UNSTABLE(params) : options.retainedBy_UNSTABLE,
      effects: typeof options.effects === 'function' ? options.effects(params) : typeof options.effects_UNSTABLE === 'function' ? options.effects_UNSTABLE(params) : (_options$effects = options.effects) !== null && _options$effects !== void 0 ? _options$effects : options.effects_UNSTABLE // prettier-ignore
      // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS: mapScopeRules(
      // @fb-only: options.scopeRules_APPEND_ONLY_READ_THE_DOCS,
      // @fb-only: params,
      // @fb-only: ),

    });
    atomCache.set(params, newAtom);
    setConfigDeletionHandler$2(newAtom.key, () => {
      atomCache.delete(params);
    });
    return newAtom;
  };
}

var Recoil_atomFamily = atomFamily;

const {
  setConfigDeletionHandler: setConfigDeletionHandler$3
} = Recoil_Node;





 // Keep in mind the parameter needs to be serializable as a cahche key
// using Recoil_stableStringify


// Add a unique index to each selector in case the cache implementation allows
// duplicate keys based on equivalent stringified parameters
let nextIndex = 0;
/* eslint-disable no-redeclare */

// Return a function that returns members of a family of selectors of the same type
// E.g.,
//
// const s = selectorFamily(...);
// s({a: 1}) => a selector
// s({a: 2}) => a different selector
//
// By default, the selectors are distinguished by distinct values of the
// parameter based on value equality, not reference equality.  This allows using
// object literals or other equivalent objects at callsites to not create
// duplicate cache entries.  This behavior may be overridden with the
// cacheImplementationForParams option.
function selectorFamily(options) {
  var _options$cachePolicyF, _options$cachePolicyF2;

  const selectorCache = Recoil_cacheFromPolicy({
    equality: (_options$cachePolicyF = (_options$cachePolicyF2 = options.cachePolicyForParams_UNSTABLE) === null || _options$cachePolicyF2 === void 0 ? void 0 : _options$cachePolicyF2.equality) !== null && _options$cachePolicyF !== void 0 ? _options$cachePolicyF : 'value',
    eviction: 'keep-all'
  });
  return params => {
    var _stableStringify;

    // Throw an error with selector key so that it is clear which
    // selector is causing an error
    let cachedSelector;

    try {
      cachedSelector = selectorCache.get(params);
    } catch (error) {
      throw Recoil_err(`Problem with cache lookup for selector ${options.key}: ${error.message}`);
    }

    if (cachedSelector != null) {
      return cachedSelector;
    }

    const myKey = `${options.key}__selectorFamily/${(_stableStringify = Recoil_stableStringify(params, {
      // It is possible to use functions in parameters if the user uses
      // a cache with reference equality thanks to the incrementing index.
      allowFunctions: true
    })) !== null && _stableStringify !== void 0 ? _stableStringify : 'void'}/${nextIndex++}`; // Append index in case values serialize to the same key string

    const myGet = callbacks => options.get(params)(callbacks);

    const myCachePolicy = options.cachePolicy_UNSTABLE;
    const retainedBy = typeof options.retainedBy_UNSTABLE === 'function' ? options.retainedBy_UNSTABLE(params) : options.retainedBy_UNSTABLE;
    let newSelector;

    if (options.set != null) {
      const set = options.set;

      const mySet = (callbacks, newValue) => set(params)(callbacks, newValue);

      newSelector = Recoil_selector({
        key: myKey,
        get: myGet,
        set: mySet,
        cachePolicy_UNSTABLE: myCachePolicy,
        dangerouslyAllowMutability: options.dangerouslyAllowMutability,
        retainedBy_UNSTABLE: retainedBy
      });
    } else {
      newSelector = Recoil_selector({
        key: myKey,
        get: myGet,
        cachePolicy_UNSTABLE: myCachePolicy,
        dangerouslyAllowMutability: options.dangerouslyAllowMutability,
        retainedBy_UNSTABLE: retainedBy
      });
    }

    selectorCache.set(params, newSelector);
    setConfigDeletionHandler$3(newSelector.key, () => {
      selectorCache.delete(params);
    });
    return newSelector;
  };
}
/* eslint-enable no-redeclare */


var Recoil_selectorFamily = selectorFamily;

// flowlint-next-line unclear-type:off


const constantSelector = Recoil_selectorFamily({
  key: '__constant',
  get: constant => () => constant,
  cachePolicyForParams_UNSTABLE: {
    equality: 'reference'
  }
}); // Function that returns a selector which always produces the
// same constant value.  It may be called multiple times with the
// same value, based on reference equality, and will provide the
// same selector.

function constSelector(constant) {
  return constantSelector(constant);
}

var Recoil_constSelector = constSelector;

// flowlint-next-line unclear-type:off


const throwingSelector = Recoil_selectorFamily({
  key: '__error',
  get: message => () => {
    throw Recoil_err(message);
  },
  // TODO Why?
  cachePolicyForParams_UNSTABLE: {
    equality: 'reference'
  }
}); // Function that returns a selector which always throws an error
// with the provided message.

function errorSelector(message) {
  return throwingSelector(message);
}

var Recoil_errorSelector = errorSelector;

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Wraps another recoil value and prevents writing to it.
 *
 * 
 * @format
 * @oncall recoil
 */

function readOnlySelector(atom) {
  // flowlint-next-line unclear-type: off
  return atom;
}

var Recoil_readOnlySelector = readOnlySelector;

const {
  loadableWithError: loadableWithError$3,
  loadableWithPromise: loadableWithPromise$3,
  loadableWithValue: loadableWithValue$4
} = Recoil_Loadable$1;





 /////////////////
//  TRUTH TABLE
/////////////////
// Dependencies        waitForNone         waitForAny        waitForAll       waitForAllSettled
//  [loading, loading]  [Promise, Promise]  Promise           Promise         Promise
//  [value, loading]    [value, Promise]    [value, Promise]  Promise         Promise
//  [value, value]      [value, value]      [value, value]    [value, value]  [value, value]
//
//  [error, loading]    [Error, Promise]    [Error, Promise]  Error           Promise
//  [error, error]      [Error, Error]      [Error, Error]    Error           [error, error]
//  [value, error]      [value, Error]      [value, Error]    Error           [value, error]
// Issue parallel requests for all dependencies and return the current
// status if they have results, have some error, or are still pending.


function concurrentRequests(getRecoilValue, deps) {
  const results = Array(deps.length).fill(undefined);
  const exceptions = Array(deps.length).fill(undefined);

  for (const [i, dep] of deps.entries()) {
    try {
      results[i] = getRecoilValue(dep);
    } catch (e) {
      // exceptions can either be Promises of pending results or real errors
      exceptions[i] = e;
    }
  }

  return [results, exceptions];
}

function isError(exp) {
  return exp != null && !Recoil_isPromise(exp);
}

function unwrapDependencies(dependencies) {
  return Array.isArray(dependencies) ? dependencies : Object.getOwnPropertyNames(dependencies).map(key => dependencies[key]);
}

function wrapResults(dependencies,
/* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's
 * LTI update could not be added via codemod */
results) {
  return Array.isArray(dependencies) ? results : // Object.getOwnPropertyNames() has consistent key ordering with ES6
  Object.getOwnPropertyNames(dependencies).reduce((out, key, idx) => ({ ...out,
    [key]: results[idx]
  }), {});
}

function wrapLoadables(dependencies, results, exceptions) {
  const output = exceptions.map((exception, idx) => exception == null ? loadableWithValue$4(results[idx]) : Recoil_isPromise(exception) ? loadableWithPromise$3(exception) : loadableWithError$3(exception));
  return wrapResults(dependencies, output);
}

function combineAsyncResultsWithSyncResults(syncResults, asyncResults) {
  return asyncResults.map((result, idx) =>
  /**
   * it's important we use === undefined as opposed to == null, because the
   * resolved value of the async promise could be `null`, in which case we
   * don't want to use syncResults[idx], which would be undefined. If async
   * promise resolves to `undefined`, that's ok because `syncResults[idx]`
   * will also be `undefined`. That's a little hacky, but it works.
   */
  result === undefined ? syncResults[idx] : result);
} // Selector that requests all dependencies in parallel and immediately returns
// current results without waiting.


const waitForNone = Recoil_selectorFamily({
  key: '__waitForNone',
  get: dependencies => ({
    get
  }) => {
    // Issue requests for all dependencies in parallel.
    const deps = unwrapDependencies(dependencies);
    const [results, exceptions] = concurrentRequests(get, deps); // Always return the current status of the results; never block.

    return wrapLoadables(dependencies, results, exceptions);
  },
  dangerouslyAllowMutability: true
}); // Selector that requests all dependencies in parallel and waits for at least
// one to be available before returning results.  It will only error if all
// dependencies have errors.

const waitForAny = Recoil_selectorFamily({
  key: '__waitForAny',
  get: dependencies => ({
    get
  }) => {
    // Issue requests for all dependencies in parallel.
    // Exceptions can either be Promises of pending results or real errors
    const deps = unwrapDependencies(dependencies);
    const [results, exceptions] = concurrentRequests(get, deps); // If any results are available, value or error, return the current status

    if (exceptions.some(exp => !Recoil_isPromise(exp))) {
      return wrapLoadables(dependencies, results, exceptions);
    } // Otherwise, return a promise that will resolve when the next result is
    // available, whichever one happens to be next.  But, if all pending
    // dependencies end up with errors, then reject the promise.


    return new Promise(resolve => {
      for (const [i, exp] of exceptions.entries()) {
        if (Recoil_isPromise(exp)) {
          exp.then(result => {
            results[i] = result;
            exceptions[i] = undefined;
            resolve(wrapLoadables(dependencies, results, exceptions));
          }).catch(error => {
            exceptions[i] = error;
            resolve(wrapLoadables(dependencies, results, exceptions));
          });
        }
      }
    });
  },
  dangerouslyAllowMutability: true
}); // Selector that requests all dependencies in parallel and waits for all to be
// available before returning a value.  It will error if any dependencies error.

const waitForAll = Recoil_selectorFamily({
  key: '__waitForAll',
  get: dependencies => ({
    get
  }) => {
    // Issue requests for all dependencies in parallel.
    // Exceptions can either be Promises of pending results or real errors
    const deps = unwrapDependencies(dependencies);
    const [results, exceptions] = concurrentRequests(get, deps); // If all results are available, return the results

    if (exceptions.every(exp => exp == null)) {
      return wrapResults(dependencies, results);
    } // If we have any errors, throw the first error


    const error = exceptions.find(isError);

    if (error != null) {
      throw error;
    } // Otherwise, return a promise that will resolve when all results are available


    return Promise.all(exceptions).then(exceptionResults => wrapResults(dependencies, combineAsyncResultsWithSyncResults(results, exceptionResults)));
  },
  dangerouslyAllowMutability: true
});
const waitForAllSettled = Recoil_selectorFamily({
  key: '__waitForAllSettled',
  get: dependencies => ({
    get
  }) => {
    // Issue requests for all dependencies in parallel.
    // Exceptions can either be Promises of pending results or real errors
    const deps = unwrapDependencies(dependencies);
    const [results, exceptions] = concurrentRequests(get, deps); // If all results are available, return the results

    if (exceptions.every(exp => !Recoil_isPromise(exp))) {
      return wrapLoadables(dependencies, results, exceptions);
    } // Wait for all results to settle


    return Promise.all(exceptions.map((exp, i) => Recoil_isPromise(exp) ? exp.then(result => {
      results[i] = result;
      exceptions[i] = undefined;
    }).catch(error => {
      results[i] = undefined;
      exceptions[i] = error;
    }) : null)) // Then wrap them as loadables
    .then(() => wrapLoadables(dependencies, results, exceptions));
  },
  dangerouslyAllowMutability: true
});
const noWait = Recoil_selectorFamily({
  key: '__noWait',
  get: dependency => ({
    get
  }) => {
    try {
      return Recoil_selector.value(loadableWithValue$4(get(dependency)));
    } catch (exception) {
      return Recoil_selector.value(Recoil_isPromise(exception) ? loadableWithPromise$3(exception) : loadableWithError$3(exception));
    }
  },
  dangerouslyAllowMutability: true
});
var Recoil_WaitFor = {
  waitForNone,
  waitForAny,
  waitForAll,
  waitForAllSettled,
  noWait
};

const {
  RecoilLoadable
} = Recoil_Loadable$1;

const {
  DefaultValue: DefaultValue$3
} = Recoil_Node;

const {
  RecoilRoot: RecoilRoot$2,
  useRecoilStoreID: useRecoilStoreID$1
} = Recoil_RecoilRoot;

const {
  isRecoilValue: isRecoilValue$5
} = Recoil_RecoilValue$1;

const {
  retentionZone: retentionZone$1
} = Recoil_RetentionZone;

const {
  freshSnapshot: freshSnapshot$2
} = Recoil_Snapshot$1;

const {
  useRecoilState: useRecoilState$1,
  useRecoilState_TRANSITION_SUPPORT_UNSTABLE: useRecoilState_TRANSITION_SUPPORT_UNSTABLE$1,
  useRecoilStateLoadable: useRecoilStateLoadable$1,
  useRecoilValue: useRecoilValue$1,
  useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: useRecoilValue_TRANSITION_SUPPORT_UNSTABLE$1,
  useRecoilValueLoadable: useRecoilValueLoadable$1,
  useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE$1,
  useResetRecoilState: useResetRecoilState$1,
  useSetRecoilState: useSetRecoilState$1
} = Recoil_Hooks;

const {
  useGotoRecoilSnapshot: useGotoRecoilSnapshot$1,
  useRecoilSnapshot: useRecoilSnapshot$1,
  useRecoilTransactionObserver: useRecoilTransactionObserver$1
} = Recoil_SnapshotHooks;





const {
  useRecoilCallback: useRecoilCallback$1
} = Recoil_useRecoilCallback;





















const {
  noWait: noWait$1,
  waitForAll: waitForAll$1,
  waitForAllSettled: waitForAllSettled$1,
  waitForAny: waitForAny$1,
  waitForNone: waitForNone$1
} = Recoil_WaitFor;



var Recoil_index = {
  // Types
  DefaultValue: DefaultValue$3,
  isRecoilValue: isRecoilValue$5,
  RecoilLoadable,
  // Global Recoil environment settiongs
  RecoilEnv: Recoil_RecoilEnv,
  // Recoil Root
  RecoilRoot: RecoilRoot$2,
  useRecoilStoreID: useRecoilStoreID$1,
  useRecoilBridgeAcrossReactRoots_UNSTABLE: Recoil_useRecoilBridgeAcrossReactRoots,
  // Atoms/Selectors
  atom: Recoil_atom,
  selector: Recoil_selector,
  // Convenience Atoms/Selectors
  atomFamily: Recoil_atomFamily,
  selectorFamily: Recoil_selectorFamily,
  constSelector: Recoil_constSelector,
  errorSelector: Recoil_errorSelector,
  readOnlySelector: Recoil_readOnlySelector,
  // Concurrency Helpers for Atoms/Selectors
  noWait: noWait$1,
  waitForNone: waitForNone$1,
  waitForAny: waitForAny$1,
  waitForAll: waitForAll$1,
  waitForAllSettled: waitForAllSettled$1,
  // Hooks for Atoms/Selectors
  useRecoilValue: useRecoilValue$1,
  useRecoilValueLoadable: useRecoilValueLoadable$1,
  useRecoilState: useRecoilState$1,
  useRecoilStateLoadable: useRecoilStateLoadable$1,
  useSetRecoilState: useSetRecoilState$1,
  useResetRecoilState: useResetRecoilState$1,
  useGetRecoilValueInfo_UNSTABLE: Recoil_useGetRecoilValueInfo,
  useRecoilRefresher_UNSTABLE: Recoil_useRecoilRefresher,
  useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE$1,
  useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: useRecoilValue_TRANSITION_SUPPORT_UNSTABLE$1,
  useRecoilState_TRANSITION_SUPPORT_UNSTABLE: useRecoilState_TRANSITION_SUPPORT_UNSTABLE$1,
  // Hooks for complex operations
  useRecoilCallback: useRecoilCallback$1,
  useRecoilTransaction_UNSTABLE: Recoil_useRecoilTransaction,
  // Snapshots
  useGotoRecoilSnapshot: useGotoRecoilSnapshot$1,
  useRecoilSnapshot: useRecoilSnapshot$1,
  useRecoilTransactionObserver_UNSTABLE: useRecoilTransactionObserver$1,
  snapshot_UNSTABLE: freshSnapshot$2,
  // Memory Management
  useRetain: Recoil_useRetain,
  retentionZone: retentionZone$1
};
var Recoil_index_1 = Recoil_index.DefaultValue;
var Recoil_index_2 = Recoil_index.isRecoilValue;
var Recoil_index_3 = Recoil_index.RecoilLoadable;
var Recoil_index_4 = Recoil_index.RecoilEnv;
var Recoil_index_5 = Recoil_index.RecoilRoot;
var Recoil_index_6 = Recoil_index.useRecoilStoreID;
var Recoil_index_7 = Recoil_index.useRecoilBridgeAcrossReactRoots_UNSTABLE;
var Recoil_index_8 = Recoil_index.atom;
var Recoil_index_9 = Recoil_index.selector;
var Recoil_index_10 = Recoil_index.atomFamily;
var Recoil_index_11 = Recoil_index.selectorFamily;
var Recoil_index_12 = Recoil_index.constSelector;
var Recoil_index_13 = Recoil_index.errorSelector;
var Recoil_index_14 = Recoil_index.readOnlySelector;
var Recoil_index_15 = Recoil_index.noWait;
var Recoil_index_16 = Recoil_index.waitForNone;
var Recoil_index_17 = Recoil_index.waitForAny;
var Recoil_index_18 = Recoil_index.waitForAll;
var Recoil_index_19 = Recoil_index.waitForAllSettled;
var Recoil_index_20 = Recoil_index.useRecoilValue;
var Recoil_index_21 = Recoil_index.useRecoilValueLoadable;
var Recoil_index_22 = Recoil_index.useRecoilState;
var Recoil_index_23 = Recoil_index.useRecoilStateLoadable;
var Recoil_index_24 = Recoil_index.useSetRecoilState;
var Recoil_index_25 = Recoil_index.useResetRecoilState;
var Recoil_index_26 = Recoil_index.useGetRecoilValueInfo_UNSTABLE;
var Recoil_index_27 = Recoil_index.useRecoilRefresher_UNSTABLE;
var Recoil_index_28 = Recoil_index.useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE;
var Recoil_index_29 = Recoil_index.useRecoilValue_TRANSITION_SUPPORT_UNSTABLE;
var Recoil_index_30 = Recoil_index.useRecoilState_TRANSITION_SUPPORT_UNSTABLE;
var Recoil_index_31 = Recoil_index.useRecoilCallback;
var Recoil_index_32 = Recoil_index.useRecoilTransaction_UNSTABLE;
var Recoil_index_33 = Recoil_index.useGotoRecoilSnapshot;
var Recoil_index_34 = Recoil_index.useRecoilSnapshot;
var Recoil_index_35 = Recoil_index.useRecoilTransactionObserver_UNSTABLE;
var Recoil_index_36 = Recoil_index.snapshot_UNSTABLE;
var Recoil_index_37 = Recoil_index.useRetain;
var Recoil_index_38 = Recoil_index.retentionZone;

var es = /*#__PURE__*/Object.freeze({
  __proto__: null,
  DefaultValue: Recoil_index_1,
  RecoilEnv: Recoil_index_4,
  RecoilLoadable: Recoil_index_3,
  RecoilRoot: Recoil_index_5,
  atom: Recoil_index_8,
  atomFamily: Recoil_index_10,
  constSelector: Recoil_index_12,
  default: Recoil_index,
  errorSelector: Recoil_index_13,
  isRecoilValue: Recoil_index_2,
  noWait: Recoil_index_15,
  readOnlySelector: Recoil_index_14,
  retentionZone: Recoil_index_38,
  selector: Recoil_index_9,
  selectorFamily: Recoil_index_11,
  snapshot_UNSTABLE: Recoil_index_36,
  useGetRecoilValueInfo_UNSTABLE: Recoil_index_26,
  useGotoRecoilSnapshot: Recoil_index_33,
  useRecoilBridgeAcrossReactRoots_UNSTABLE: Recoil_index_7,
  useRecoilCallback: Recoil_index_31,
  useRecoilRefresher_UNSTABLE: Recoil_index_27,
  useRecoilSnapshot: Recoil_index_34,
  useRecoilState: Recoil_index_22,
  useRecoilStateLoadable: Recoil_index_23,
  useRecoilState_TRANSITION_SUPPORT_UNSTABLE: Recoil_index_30,
  useRecoilStoreID: Recoil_index_6,
  useRecoilTransactionObserver_UNSTABLE: Recoil_index_35,
  useRecoilTransaction_UNSTABLE: Recoil_index_32,
  useRecoilValue: Recoil_index_20,
  useRecoilValueLoadable: Recoil_index_21,
  useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: Recoil_index_28,
  useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: Recoil_index_29,
  useResetRecoilState: Recoil_index_25,
  useRetain: Recoil_index_37,
  useSetRecoilState: Recoil_index_24,
  waitForAll: Recoil_index_18,
  waitForAllSettled: Recoil_index_19,
  waitForAny: Recoil_index_17,
  waitForNone: Recoil_index_16
});

var RecoilNexus$1 = {};

var require$$0 = /*@__PURE__*/getAugmentedNamespace(es);

Object.defineProperty(RecoilNexus$1, "__esModule", { value: true });
RecoilNexus$1.resetRecoil = setRecoil_1 = RecoilNexus$1.setRecoil = RecoilNexus$1.getRecoilPromise = RecoilNexus$1.getRecoil = void 0;
var recoil_1 = require$$0;
var nexus = {};
function RecoilNexus() {
    nexus.get = (0, recoil_1.useRecoilCallback)(function (_a) {
        var snapshot = _a.snapshot;
        return function (atom) {
            return snapshot.getLoadable(atom).contents;
        };
    }, []);
    nexus.getPromise = (0, recoil_1.useRecoilCallback)(function (_a) {
        var snapshot = _a.snapshot;
        return function (atom) {
            return snapshot.getPromise(atom);
        };
    }, []);
    nexus.set = (0, recoil_1.useRecoilCallback)(function (_a) {
        var transact_UNSTABLE = _a.transact_UNSTABLE;
        return function (atom, valOrUpdater) {
            transact_UNSTABLE(function (_a) {
                var set = _a.set;
                set(atom, valOrUpdater);
            });
        };
    }, []);
    nexus.reset = (0, recoil_1.useRecoilCallback)(function (_a) {
        var reset = _a.reset;
        return reset;
    }, []);
    return null;
}
var _default = RecoilNexus$1.default = RecoilNexus;
function getRecoil(atom) {
    return nexus.get(atom);
}
RecoilNexus$1.getRecoil = getRecoil;
function getRecoilPromise(atom) {
    return nexus.getPromise(atom);
}
RecoilNexus$1.getRecoilPromise = getRecoilPromise;
function setRecoil(atom, valOrUpdater) {
    nexus.set(atom, valOrUpdater);
}
var setRecoil_1 = RecoilNexus$1.setRecoil = setRecoil;
function resetRecoil(atom) {
    nexus.reset(atom);
}
RecoilNexus$1.resetRecoil = resetRecoil;

var indexNode$1 = {exports: {}};

var _FullInternals = {};

var _CoreInternals = {};

var Global = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports._registerNode = exports.Konva = exports.glob = void 0;
	var PI_OVER_180 = Math.PI / 180;
	function detectBrowser() {
	    return (typeof window !== 'undefined' &&
	        ({}.toString.call(window) === '[object Window]' ||
	            {}.toString.call(window) === '[object global]'));
	}
	exports.glob = typeof commonjsGlobal !== 'undefined'
	    ? commonjsGlobal
	    : typeof window !== 'undefined'
	        ? window
	        : typeof WorkerGlobalScope !== 'undefined'
	            ? self
	            : {};
	exports.Konva = {
	    _global: exports.glob,
	    version: '9.2.0',
	    isBrowser: detectBrowser(),
	    isUnminified: /param/.test(function (param) { }.toString()),
	    dblClickWindow: 400,
	    getAngle(angle) {
	        return exports.Konva.angleDeg ? angle * PI_OVER_180 : angle;
	    },
	    enableTrace: false,
	    pointerEventsEnabled: true,
	    autoDrawEnabled: true,
	    hitOnDragEnabled: false,
	    capturePointerEventsEnabled: false,
	    _mouseListenClick: false,
	    _touchListenClick: false,
	    _pointerListenClick: false,
	    _mouseInDblClickWindow: false,
	    _touchInDblClickWindow: false,
	    _pointerInDblClickWindow: false,
	    _mouseDblClickPointerId: null,
	    _touchDblClickPointerId: null,
	    _pointerDblClickPointerId: null,
	    pixelRatio: (typeof window !== 'undefined' && window.devicePixelRatio) || 1,
	    dragDistance: 3,
	    angleDeg: true,
	    showWarnings: true,
	    dragButtons: [0, 1],
	    isDragging() {
	        return exports.Konva['DD'].isDragging;
	    },
	    isDragReady() {
	        return !!exports.Konva['DD'].node;
	    },
	    releaseCanvasOnDestroy: true,
	    document: exports.glob.document,
	    _injectGlobal(Konva) {
	        exports.glob.Konva = Konva;
	    },
	};
	const _registerNode = (NodeClass) => {
	    exports.Konva[NodeClass.prototype.getClassName()] = NodeClass;
	};
	exports._registerNode = _registerNode;
	exports.Konva._injectGlobal(exports.Konva); 
} (Global));

var Util = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Util = exports.Transform = void 0;
	const Global_1 = Global;
	class Transform {
	    constructor(m = [1, 0, 0, 1, 0, 0]) {
	        this.dirty = false;
	        this.m = (m && m.slice()) || [1, 0, 0, 1, 0, 0];
	    }
	    reset() {
	        this.m[0] = 1;
	        this.m[1] = 0;
	        this.m[2] = 0;
	        this.m[3] = 1;
	        this.m[4] = 0;
	        this.m[5] = 0;
	    }
	    copy() {
	        return new Transform(this.m);
	    }
	    copyInto(tr) {
	        tr.m[0] = this.m[0];
	        tr.m[1] = this.m[1];
	        tr.m[2] = this.m[2];
	        tr.m[3] = this.m[3];
	        tr.m[4] = this.m[4];
	        tr.m[5] = this.m[5];
	    }
	    point(point) {
	        var m = this.m;
	        return {
	            x: m[0] * point.x + m[2] * point.y + m[4],
	            y: m[1] * point.x + m[3] * point.y + m[5],
	        };
	    }
	    translate(x, y) {
	        this.m[4] += this.m[0] * x + this.m[2] * y;
	        this.m[5] += this.m[1] * x + this.m[3] * y;
	        return this;
	    }
	    scale(sx, sy) {
	        this.m[0] *= sx;
	        this.m[1] *= sx;
	        this.m[2] *= sy;
	        this.m[3] *= sy;
	        return this;
	    }
	    rotate(rad) {
	        var c = Math.cos(rad);
	        var s = Math.sin(rad);
	        var m11 = this.m[0] * c + this.m[2] * s;
	        var m12 = this.m[1] * c + this.m[3] * s;
	        var m21 = this.m[0] * -s + this.m[2] * c;
	        var m22 = this.m[1] * -s + this.m[3] * c;
	        this.m[0] = m11;
	        this.m[1] = m12;
	        this.m[2] = m21;
	        this.m[3] = m22;
	        return this;
	    }
	    getTranslation() {
	        return {
	            x: this.m[4],
	            y: this.m[5],
	        };
	    }
	    skew(sx, sy) {
	        var m11 = this.m[0] + this.m[2] * sy;
	        var m12 = this.m[1] + this.m[3] * sy;
	        var m21 = this.m[2] + this.m[0] * sx;
	        var m22 = this.m[3] + this.m[1] * sx;
	        this.m[0] = m11;
	        this.m[1] = m12;
	        this.m[2] = m21;
	        this.m[3] = m22;
	        return this;
	    }
	    multiply(matrix) {
	        var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1];
	        var m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1];
	        var m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3];
	        var m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];
	        var dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4];
	        var dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];
	        this.m[0] = m11;
	        this.m[1] = m12;
	        this.m[2] = m21;
	        this.m[3] = m22;
	        this.m[4] = dx;
	        this.m[5] = dy;
	        return this;
	    }
	    invert() {
	        var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
	        var m0 = this.m[3] * d;
	        var m1 = -this.m[1] * d;
	        var m2 = -this.m[2] * d;
	        var m3 = this.m[0] * d;
	        var m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
	        var m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
	        this.m[0] = m0;
	        this.m[1] = m1;
	        this.m[2] = m2;
	        this.m[3] = m3;
	        this.m[4] = m4;
	        this.m[5] = m5;
	        return this;
	    }
	    getMatrix() {
	        return this.m;
	    }
	    decompose() {
	        var a = this.m[0];
	        var b = this.m[1];
	        var c = this.m[2];
	        var d = this.m[3];
	        var e = this.m[4];
	        var f = this.m[5];
	        var delta = a * d - b * c;
	        let result = {
	            x: e,
	            y: f,
	            rotation: 0,
	            scaleX: 0,
	            scaleY: 0,
	            skewX: 0,
	            skewY: 0,
	        };
	        if (a != 0 || b != 0) {
	            var r = Math.sqrt(a * a + b * b);
	            result.rotation = b > 0 ? Math.acos(a / r) : -Math.acos(a / r);
	            result.scaleX = r;
	            result.scaleY = delta / r;
	            result.skewX = (a * c + b * d) / delta;
	            result.skewY = 0;
	        }
	        else if (c != 0 || d != 0) {
	            var s = Math.sqrt(c * c + d * d);
	            result.rotation =
	                Math.PI / 2 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s));
	            result.scaleX = delta / s;
	            result.scaleY = s;
	            result.skewX = 0;
	            result.skewY = (a * c + b * d) / delta;
	        }
	        else ;
	        result.rotation = exports.Util._getRotation(result.rotation);
	        return result;
	    }
	}
	exports.Transform = Transform;
	var OBJECT_ARRAY = '[object Array]', OBJECT_NUMBER = '[object Number]', OBJECT_STRING = '[object String]', OBJECT_BOOLEAN = '[object Boolean]', PI_OVER_DEG180 = Math.PI / 180, DEG180_OVER_PI = 180 / Math.PI, HASH = '#', EMPTY_STRING = '', ZERO = '0', KONVA_WARNING = 'Konva warning: ', KONVA_ERROR = 'Konva error: ', RGB_PAREN = 'rgb(', COLORS = {
	    aliceblue: [240, 248, 255],
	    antiquewhite: [250, 235, 215],
	    aqua: [0, 255, 255],
	    aquamarine: [127, 255, 212],
	    azure: [240, 255, 255],
	    beige: [245, 245, 220],
	    bisque: [255, 228, 196],
	    black: [0, 0, 0],
	    blanchedalmond: [255, 235, 205],
	    blue: [0, 0, 255],
	    blueviolet: [138, 43, 226],
	    brown: [165, 42, 42],
	    burlywood: [222, 184, 135],
	    cadetblue: [95, 158, 160],
	    chartreuse: [127, 255, 0],
	    chocolate: [210, 105, 30],
	    coral: [255, 127, 80],
	    cornflowerblue: [100, 149, 237],
	    cornsilk: [255, 248, 220],
	    crimson: [220, 20, 60],
	    cyan: [0, 255, 255],
	    darkblue: [0, 0, 139],
	    darkcyan: [0, 139, 139],
	    darkgoldenrod: [184, 132, 11],
	    darkgray: [169, 169, 169],
	    darkgreen: [0, 100, 0],
	    darkgrey: [169, 169, 169],
	    darkkhaki: [189, 183, 107],
	    darkmagenta: [139, 0, 139],
	    darkolivegreen: [85, 107, 47],
	    darkorange: [255, 140, 0],
	    darkorchid: [153, 50, 204],
	    darkred: [139, 0, 0],
	    darksalmon: [233, 150, 122],
	    darkseagreen: [143, 188, 143],
	    darkslateblue: [72, 61, 139],
	    darkslategray: [47, 79, 79],
	    darkslategrey: [47, 79, 79],
	    darkturquoise: [0, 206, 209],
	    darkviolet: [148, 0, 211],
	    deeppink: [255, 20, 147],
	    deepskyblue: [0, 191, 255],
	    dimgray: [105, 105, 105],
	    dimgrey: [105, 105, 105],
	    dodgerblue: [30, 144, 255],
	    firebrick: [178, 34, 34],
	    floralwhite: [255, 255, 240],
	    forestgreen: [34, 139, 34],
	    fuchsia: [255, 0, 255],
	    gainsboro: [220, 220, 220],
	    ghostwhite: [248, 248, 255],
	    gold: [255, 215, 0],
	    goldenrod: [218, 165, 32],
	    gray: [128, 128, 128],
	    green: [0, 128, 0],
	    greenyellow: [173, 255, 47],
	    grey: [128, 128, 128],
	    honeydew: [240, 255, 240],
	    hotpink: [255, 105, 180],
	    indianred: [205, 92, 92],
	    indigo: [75, 0, 130],
	    ivory: [255, 255, 240],
	    khaki: [240, 230, 140],
	    lavender: [230, 230, 250],
	    lavenderblush: [255, 240, 245],
	    lawngreen: [124, 252, 0],
	    lemonchiffon: [255, 250, 205],
	    lightblue: [173, 216, 230],
	    lightcoral: [240, 128, 128],
	    lightcyan: [224, 255, 255],
	    lightgoldenrodyellow: [250, 250, 210],
	    lightgray: [211, 211, 211],
	    lightgreen: [144, 238, 144],
	    lightgrey: [211, 211, 211],
	    lightpink: [255, 182, 193],
	    lightsalmon: [255, 160, 122],
	    lightseagreen: [32, 178, 170],
	    lightskyblue: [135, 206, 250],
	    lightslategray: [119, 136, 153],
	    lightslategrey: [119, 136, 153],
	    lightsteelblue: [176, 196, 222],
	    lightyellow: [255, 255, 224],
	    lime: [0, 255, 0],
	    limegreen: [50, 205, 50],
	    linen: [250, 240, 230],
	    magenta: [255, 0, 255],
	    maroon: [128, 0, 0],
	    mediumaquamarine: [102, 205, 170],
	    mediumblue: [0, 0, 205],
	    mediumorchid: [186, 85, 211],
	    mediumpurple: [147, 112, 219],
	    mediumseagreen: [60, 179, 113],
	    mediumslateblue: [123, 104, 238],
	    mediumspringgreen: [0, 250, 154],
	    mediumturquoise: [72, 209, 204],
	    mediumvioletred: [199, 21, 133],
	    midnightblue: [25, 25, 112],
	    mintcream: [245, 255, 250],
	    mistyrose: [255, 228, 225],
	    moccasin: [255, 228, 181],
	    navajowhite: [255, 222, 173],
	    navy: [0, 0, 128],
	    oldlace: [253, 245, 230],
	    olive: [128, 128, 0],
	    olivedrab: [107, 142, 35],
	    orange: [255, 165, 0],
	    orangered: [255, 69, 0],
	    orchid: [218, 112, 214],
	    palegoldenrod: [238, 232, 170],
	    palegreen: [152, 251, 152],
	    paleturquoise: [175, 238, 238],
	    palevioletred: [219, 112, 147],
	    papayawhip: [255, 239, 213],
	    peachpuff: [255, 218, 185],
	    peru: [205, 133, 63],
	    pink: [255, 192, 203],
	    plum: [221, 160, 203],
	    powderblue: [176, 224, 230],
	    purple: [128, 0, 128],
	    rebeccapurple: [102, 51, 153],
	    red: [255, 0, 0],
	    rosybrown: [188, 143, 143],
	    royalblue: [65, 105, 225],
	    saddlebrown: [139, 69, 19],
	    salmon: [250, 128, 114],
	    sandybrown: [244, 164, 96],
	    seagreen: [46, 139, 87],
	    seashell: [255, 245, 238],
	    sienna: [160, 82, 45],
	    silver: [192, 192, 192],
	    skyblue: [135, 206, 235],
	    slateblue: [106, 90, 205],
	    slategray: [119, 128, 144],
	    slategrey: [119, 128, 144],
	    snow: [255, 255, 250],
	    springgreen: [0, 255, 127],
	    steelblue: [70, 130, 180],
	    tan: [210, 180, 140],
	    teal: [0, 128, 128],
	    thistle: [216, 191, 216],
	    transparent: [255, 255, 255, 0],
	    tomato: [255, 99, 71],
	    turquoise: [64, 224, 208],
	    violet: [238, 130, 238],
	    wheat: [245, 222, 179],
	    white: [255, 255, 255],
	    whitesmoke: [245, 245, 245],
	    yellow: [255, 255, 0],
	    yellowgreen: [154, 205, 5],
	}, RGB_REGEX = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/, animQueue = [];
	const req = (typeof requestAnimationFrame !== 'undefined' && requestAnimationFrame) ||
	    function (f) {
	        setTimeout(f, 60);
	    };
	exports.Util = {
	    _isElement(obj) {
	        return !!(obj && obj.nodeType == 1);
	    },
	    _isFunction(obj) {
	        return !!(obj && obj.constructor && obj.call && obj.apply);
	    },
	    _isPlainObject(obj) {
	        return !!obj && obj.constructor === Object;
	    },
	    _isArray(obj) {
	        return Object.prototype.toString.call(obj) === OBJECT_ARRAY;
	    },
	    _isNumber(obj) {
	        return (Object.prototype.toString.call(obj) === OBJECT_NUMBER &&
	            !isNaN(obj) &&
	            isFinite(obj));
	    },
	    _isString(obj) {
	        return Object.prototype.toString.call(obj) === OBJECT_STRING;
	    },
	    _isBoolean(obj) {
	        return Object.prototype.toString.call(obj) === OBJECT_BOOLEAN;
	    },
	    isObject(val) {
	        return val instanceof Object;
	    },
	    isValidSelector(selector) {
	        if (typeof selector !== 'string') {
	            return false;
	        }
	        var firstChar = selector[0];
	        return (firstChar === '#' ||
	            firstChar === '.' ||
	            firstChar === firstChar.toUpperCase());
	    },
	    _sign(number) {
	        if (number === 0) {
	            return 1;
	        }
	        if (number > 0) {
	            return 1;
	        }
	        else {
	            return -1;
	        }
	    },
	    requestAnimFrame(callback) {
	        animQueue.push(callback);
	        if (animQueue.length === 1) {
	            req(function () {
	                const queue = animQueue;
	                animQueue = [];
	                queue.forEach(function (cb) {
	                    cb();
	                });
	            });
	        }
	    },
	    createCanvasElement() {
	        var canvas = document.createElement('canvas');
	        try {
	            canvas.style = canvas.style || {};
	        }
	        catch (e) { }
	        return canvas;
	    },
	    createImageElement() {
	        return document.createElement('img');
	    },
	    _isInDocument(el) {
	        while ((el = el.parentNode)) {
	            if (el == document) {
	                return true;
	            }
	        }
	        return false;
	    },
	    _urlToImage(url, callback) {
	        var imageObj = exports.Util.createImageElement();
	        imageObj.onload = function () {
	            callback(imageObj);
	        };
	        imageObj.src = url;
	    },
	    _rgbToHex(r, g, b) {
	        return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
	    },
	    _hexToRgb(hex) {
	        hex = hex.replace(HASH, EMPTY_STRING);
	        var bigint = parseInt(hex, 16);
	        return {
	            r: (bigint >> 16) & 255,
	            g: (bigint >> 8) & 255,
	            b: bigint & 255,
	        };
	    },
	    getRandomColor() {
	        var randColor = ((Math.random() * 0xffffff) << 0).toString(16);
	        while (randColor.length < 6) {
	            randColor = ZERO + randColor;
	        }
	        return HASH + randColor;
	    },
	    getRGB(color) {
	        var rgb;
	        if (color in COLORS) {
	            rgb = COLORS[color];
	            return {
	                r: rgb[0],
	                g: rgb[1],
	                b: rgb[2],
	            };
	        }
	        else if (color[0] === HASH) {
	            return this._hexToRgb(color.substring(1));
	        }
	        else if (color.substr(0, 4) === RGB_PAREN) {
	            rgb = RGB_REGEX.exec(color.replace(/ /g, ''));
	            return {
	                r: parseInt(rgb[1], 10),
	                g: parseInt(rgb[2], 10),
	                b: parseInt(rgb[3], 10),
	            };
	        }
	        else {
	            return {
	                r: 0,
	                g: 0,
	                b: 0,
	            };
	        }
	    },
	    colorToRGBA(str) {
	        str = str || 'black';
	        return (exports.Util._namedColorToRBA(str) ||
	            exports.Util._hex3ColorToRGBA(str) ||
	            exports.Util._hex4ColorToRGBA(str) ||
	            exports.Util._hex6ColorToRGBA(str) ||
	            exports.Util._hex8ColorToRGBA(str) ||
	            exports.Util._rgbColorToRGBA(str) ||
	            exports.Util._rgbaColorToRGBA(str) ||
	            exports.Util._hslColorToRGBA(str));
	    },
	    _namedColorToRBA(str) {
	        var c = COLORS[str.toLowerCase()];
	        if (!c) {
	            return null;
	        }
	        return {
	            r: c[0],
	            g: c[1],
	            b: c[2],
	            a: 1,
	        };
	    },
	    _rgbColorToRGBA(str) {
	        if (str.indexOf('rgb(') === 0) {
	            str = str.match(/rgb\(([^)]+)\)/)[1];
	            var parts = str.split(/ *, */).map(Number);
	            return {
	                r: parts[0],
	                g: parts[1],
	                b: parts[2],
	                a: 1,
	            };
	        }
	    },
	    _rgbaColorToRGBA(str) {
	        if (str.indexOf('rgba(') === 0) {
	            str = str.match(/rgba\(([^)]+)\)/)[1];
	            var parts = str.split(/ *, */).map((n, index) => {
	                if (n.slice(-1) === '%') {
	                    return index === 3 ? parseInt(n) / 100 : (parseInt(n) / 100) * 255;
	                }
	                return Number(n);
	            });
	            return {
	                r: parts[0],
	                g: parts[1],
	                b: parts[2],
	                a: parts[3],
	            };
	        }
	    },
	    _hex8ColorToRGBA(str) {
	        if (str[0] === '#' && str.length === 9) {
	            return {
	                r: parseInt(str.slice(1, 3), 16),
	                g: parseInt(str.slice(3, 5), 16),
	                b: parseInt(str.slice(5, 7), 16),
	                a: parseInt(str.slice(7, 9), 16) / 0xff,
	            };
	        }
	    },
	    _hex6ColorToRGBA(str) {
	        if (str[0] === '#' && str.length === 7) {
	            return {
	                r: parseInt(str.slice(1, 3), 16),
	                g: parseInt(str.slice(3, 5), 16),
	                b: parseInt(str.slice(5, 7), 16),
	                a: 1,
	            };
	        }
	    },
	    _hex4ColorToRGBA(str) {
	        if (str[0] === '#' && str.length === 5) {
	            return {
	                r: parseInt(str[1] + str[1], 16),
	                g: parseInt(str[2] + str[2], 16),
	                b: parseInt(str[3] + str[3], 16),
	                a: parseInt(str[4] + str[4], 16) / 0xff,
	            };
	        }
	    },
	    _hex3ColorToRGBA(str) {
	        if (str[0] === '#' && str.length === 4) {
	            return {
	                r: parseInt(str[1] + str[1], 16),
	                g: parseInt(str[2] + str[2], 16),
	                b: parseInt(str[3] + str[3], 16),
	                a: 1,
	            };
	        }
	    },
	    _hslColorToRGBA(str) {
	        if (/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.test(str)) {
	            const [_, ...hsl] = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(str);
	            const h = Number(hsl[0]) / 360;
	            const s = Number(hsl[1]) / 100;
	            const l = Number(hsl[2]) / 100;
	            let t2;
	            let t3;
	            let val;
	            if (s === 0) {
	                val = l * 255;
	                return {
	                    r: Math.round(val),
	                    g: Math.round(val),
	                    b: Math.round(val),
	                    a: 1,
	                };
	            }
	            if (l < 0.5) {
	                t2 = l * (1 + s);
	            }
	            else {
	                t2 = l + s - l * s;
	            }
	            const t1 = 2 * l - t2;
	            const rgb = [0, 0, 0];
	            for (let i = 0; i < 3; i++) {
	                t3 = h + (1 / 3) * -(i - 1);
	                if (t3 < 0) {
	                    t3++;
	                }
	                if (t3 > 1) {
	                    t3--;
	                }
	                if (6 * t3 < 1) {
	                    val = t1 + (t2 - t1) * 6 * t3;
	                }
	                else if (2 * t3 < 1) {
	                    val = t2;
	                }
	                else if (3 * t3 < 2) {
	                    val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
	                }
	                else {
	                    val = t1;
	                }
	                rgb[i] = val * 255;
	            }
	            return {
	                r: Math.round(rgb[0]),
	                g: Math.round(rgb[1]),
	                b: Math.round(rgb[2]),
	                a: 1,
	            };
	        }
	    },
	    haveIntersection(r1, r2) {
	        return !(r2.x > r1.x + r1.width ||
	            r2.x + r2.width < r1.x ||
	            r2.y > r1.y + r1.height ||
	            r2.y + r2.height < r1.y);
	    },
	    cloneObject(obj) {
	        var retObj = {};
	        for (var key in obj) {
	            if (this._isPlainObject(obj[key])) {
	                retObj[key] = this.cloneObject(obj[key]);
	            }
	            else if (this._isArray(obj[key])) {
	                retObj[key] = this.cloneArray(obj[key]);
	            }
	            else {
	                retObj[key] = obj[key];
	            }
	        }
	        return retObj;
	    },
	    cloneArray(arr) {
	        return arr.slice(0);
	    },
	    degToRad(deg) {
	        return deg * PI_OVER_DEG180;
	    },
	    radToDeg(rad) {
	        return rad * DEG180_OVER_PI;
	    },
	    _degToRad(deg) {
	        exports.Util.warn('Util._degToRad is removed. Please use public Util.degToRad instead.');
	        return exports.Util.degToRad(deg);
	    },
	    _radToDeg(rad) {
	        exports.Util.warn('Util._radToDeg is removed. Please use public Util.radToDeg instead.');
	        return exports.Util.radToDeg(rad);
	    },
	    _getRotation(radians) {
	        return Global_1.Konva.angleDeg ? exports.Util.radToDeg(radians) : radians;
	    },
	    _capitalize(str) {
	        return str.charAt(0).toUpperCase() + str.slice(1);
	    },
	    throw(str) {
	        throw new Error(KONVA_ERROR + str);
	    },
	    error(str) {
	        console.error(KONVA_ERROR + str);
	    },
	    warn(str) {
	        if (!Global_1.Konva.showWarnings) {
	            return;
	        }
	        console.warn(KONVA_WARNING + str);
	    },
	    each(obj, func) {
	        for (var key in obj) {
	            func(key, obj[key]);
	        }
	    },
	    _inRange(val, left, right) {
	        return left <= val && val < right;
	    },
	    _getProjectionToSegment(x1, y1, x2, y2, x3, y3) {
	        var x, y, dist;
	        var pd2 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
	        if (pd2 == 0) {
	            x = x1;
	            y = y1;
	            dist = (x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2);
	        }
	        else {
	            var u = ((x3 - x1) * (x2 - x1) + (y3 - y1) * (y2 - y1)) / pd2;
	            if (u < 0) {
	                x = x1;
	                y = y1;
	                dist = (x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3);
	            }
	            else if (u > 1.0) {
	                x = x2;
	                y = y2;
	                dist = (x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3);
	            }
	            else {
	                x = x1 + u * (x2 - x1);
	                y = y1 + u * (y2 - y1);
	                dist = (x - x3) * (x - x3) + (y - y3) * (y - y3);
	            }
	        }
	        return [x, y, dist];
	    },
	    _getProjectionToLine(pt, line, isClosed) {
	        var pc = exports.Util.cloneObject(pt);
	        var dist = Number.MAX_VALUE;
	        line.forEach(function (p1, i) {
	            if (!isClosed && i === line.length - 1) {
	                return;
	            }
	            var p2 = line[(i + 1) % line.length];
	            var proj = exports.Util._getProjectionToSegment(p1.x, p1.y, p2.x, p2.y, pt.x, pt.y);
	            var px = proj[0], py = proj[1], pdist = proj[2];
	            if (pdist < dist) {
	                pc.x = px;
	                pc.y = py;
	                dist = pdist;
	            }
	        });
	        return pc;
	    },
	    _prepareArrayForTween(startArray, endArray, isClosed) {
	        var n, start = [], end = [];
	        if (startArray.length > endArray.length) {
	            var temp = endArray;
	            endArray = startArray;
	            startArray = temp;
	        }
	        for (n = 0; n < startArray.length; n += 2) {
	            start.push({
	                x: startArray[n],
	                y: startArray[n + 1],
	            });
	        }
	        for (n = 0; n < endArray.length; n += 2) {
	            end.push({
	                x: endArray[n],
	                y: endArray[n + 1],
	            });
	        }
	        var newStart = [];
	        end.forEach(function (point) {
	            var pr = exports.Util._getProjectionToLine(point, start, isClosed);
	            newStart.push(pr.x);
	            newStart.push(pr.y);
	        });
	        return newStart;
	    },
	    _prepareToStringify(obj) {
	        var desc;
	        obj.visitedByCircularReferenceRemoval = true;
	        for (var key in obj) {
	            if (!(obj.hasOwnProperty(key) && obj[key] && typeof obj[key] == 'object')) {
	                continue;
	            }
	            desc = Object.getOwnPropertyDescriptor(obj, key);
	            if (obj[key].visitedByCircularReferenceRemoval ||
	                exports.Util._isElement(obj[key])) {
	                if (desc.configurable) {
	                    delete obj[key];
	                }
	                else {
	                    return null;
	                }
	            }
	            else if (exports.Util._prepareToStringify(obj[key]) === null) {
	                if (desc.configurable) {
	                    delete obj[key];
	                }
	                else {
	                    return null;
	                }
	            }
	        }
	        delete obj.visitedByCircularReferenceRemoval;
	        return obj;
	    },
	    _assign(target, source) {
	        for (var key in source) {
	            target[key] = source[key];
	        }
	        return target;
	    },
	    _getFirstPointerId(evt) {
	        if (!evt.touches) {
	            return evt.pointerId || 999;
	        }
	        else {
	            return evt.changedTouches[0].identifier;
	        }
	    },
	    releaseCanvas(...canvases) {
	        if (!Global_1.Konva.releaseCanvasOnDestroy)
	            return;
	        canvases.forEach(c => {
	            c.width = 0;
	            c.height = 0;
	        });
	    },
	    drawRoundedRectPath(context, width, height, cornerRadius) {
	        let topLeft = 0;
	        let topRight = 0;
	        let bottomLeft = 0;
	        let bottomRight = 0;
	        if (typeof cornerRadius === 'number') {
	            topLeft = topRight = bottomLeft = bottomRight = Math.min(cornerRadius, width / 2, height / 2);
	        }
	        else {
	            topLeft = Math.min(cornerRadius[0] || 0, width / 2, height / 2);
	            topRight = Math.min(cornerRadius[1] || 0, width / 2, height / 2);
	            bottomRight = Math.min(cornerRadius[2] || 0, width / 2, height / 2);
	            bottomLeft = Math.min(cornerRadius[3] || 0, width / 2, height / 2);
	        }
	        context.moveTo(topLeft, 0);
	        context.lineTo(width - topRight, 0);
	        context.arc(width - topRight, topRight, topRight, (Math.PI * 3) / 2, 0, false);
	        context.lineTo(width, height - bottomRight);
	        context.arc(width - bottomRight, height - bottomRight, bottomRight, 0, Math.PI / 2, false);
	        context.lineTo(bottomLeft, height);
	        context.arc(bottomLeft, height - bottomLeft, bottomLeft, Math.PI / 2, Math.PI, false);
	        context.lineTo(0, topLeft);
	        context.arc(topLeft, topLeft, topLeft, Math.PI, (Math.PI * 3) / 2, false);
	    }
	}; 
} (Util));

var Node$2 = {};

var Factory = {};

var Validators = {};

Object.defineProperty(Validators, "__esModule", { value: true });
Validators.getComponentValidator = Validators.getBooleanValidator = Validators.getNumberArrayValidator = Validators.getFunctionValidator = Validators.getStringOrGradientValidator = Validators.getStringValidator = Validators.getNumberOrAutoValidator = Validators.getNumberOrArrayOfNumbersValidator = Validators.getNumberValidator = Validators.alphaComponent = Validators.RGBComponent = void 0;
const Global_1$p = Global;
const Util_1$f = Util;
function _formatValue(val) {
    if (Util_1$f.Util._isString(val)) {
        return '"' + val + '"';
    }
    if (Object.prototype.toString.call(val) === '[object Number]') {
        return val;
    }
    if (Util_1$f.Util._isBoolean(val)) {
        return val;
    }
    return Object.prototype.toString.call(val);
}
function RGBComponent(val) {
    if (val > 255) {
        return 255;
    }
    else if (val < 0) {
        return 0;
    }
    return Math.round(val);
}
Validators.RGBComponent = RGBComponent;
function alphaComponent(val) {
    if (val > 1) {
        return 1;
    }
    else if (val < 0.0001) {
        return 0.0001;
    }
    return val;
}
Validators.alphaComponent = alphaComponent;
function getNumberValidator() {
    if (Global_1$p.Konva.isUnminified) {
        return function (val, attr) {
            if (!Util_1$f.Util._isNumber(val)) {
                Util_1$f.Util.warn(_formatValue(val) +
                    ' is a not valid value for "' +
                    attr +
                    '" attribute. The value should be a number.');
            }
            return val;
        };
    }
}
Validators.getNumberValidator = getNumberValidator;
function getNumberOrArrayOfNumbersValidator(noOfElements) {
    if (Global_1$p.Konva.isUnminified) {
        return function (val, attr) {
            let isNumber = Util_1$f.Util._isNumber(val);
            let isValidArray = Util_1$f.Util._isArray(val) && val.length == noOfElements;
            if (!isNumber && !isValidArray) {
                Util_1$f.Util.warn(_formatValue(val) +
                    ' is a not valid value for "' +
                    attr +
                    '" attribute. The value should be a number or Array<number>(' +
                    noOfElements +
                    ')');
            }
            return val;
        };
    }
}
Validators.getNumberOrArrayOfNumbersValidator = getNumberOrArrayOfNumbersValidator;
function getNumberOrAutoValidator() {
    if (Global_1$p.Konva.isUnminified) {
        return function (val, attr) {
            var isNumber = Util_1$f.Util._isNumber(val);
            var isAuto = val === 'auto';
            if (!(isNumber || isAuto)) {
                Util_1$f.Util.warn(_formatValue(val) +
                    ' is a not valid value for "' +
                    attr +
                    '" attribute. The value should be a number or "auto".');
            }
            return val;
        };
    }
}
Validators.getNumberOrAutoValidator = getNumberOrAutoValidator;
function getStringValidator() {
    if (Global_1$p.Konva.isUnminified) {
        return function (val, attr) {
            if (!Util_1$f.Util._isString(val)) {
                Util_1$f.Util.warn(_formatValue(val) +
                    ' is a not valid value for "' +
                    attr +
                    '" attribute. The value should be a string.');
            }
            return val;
        };
    }
}
Validators.getStringValidator = getStringValidator;
function getStringOrGradientValidator() {
    if (Global_1$p.Konva.isUnminified) {
        return function (val, attr) {
            const isString = Util_1$f.Util._isString(val);
            const isGradient = Object.prototype.toString.call(val) === '[object CanvasGradient]' ||
                (val && val.addColorStop);
            if (!(isString || isGradient)) {
                Util_1$f.Util.warn(_formatValue(val) +
                    ' is a not valid value for "' +
                    attr +
                    '" attribute. The value should be a string or a native gradient.');
            }
            return val;
        };
    }
}
Validators.getStringOrGradientValidator = getStringOrGradientValidator;
function getFunctionValidator() {
    if (Global_1$p.Konva.isUnminified) {
        return function (val, attr) {
            if (!Util_1$f.Util._isFunction(val)) {
                Util_1$f.Util.warn(_formatValue(val) +
                    ' is a not valid value for "' +
                    attr +
                    '" attribute. The value should be a function.');
            }
            return val;
        };
    }
}
Validators.getFunctionValidator = getFunctionValidator;
function getNumberArrayValidator() {
    if (Global_1$p.Konva.isUnminified) {
        return function (val, attr) {
            const TypedArray = Int8Array ? Object.getPrototypeOf(Int8Array) : null;
            if (TypedArray && val instanceof TypedArray) {
                return val;
            }
            if (!Util_1$f.Util._isArray(val)) {
                Util_1$f.Util.warn(_formatValue(val) +
                    ' is a not valid value for "' +
                    attr +
                    '" attribute. The value should be a array of numbers.');
            }
            else {
                val.forEach(function (item) {
                    if (!Util_1$f.Util._isNumber(item)) {
                        Util_1$f.Util.warn('"' +
                            attr +
                            '" attribute has non numeric element ' +
                            item +
                            '. Make sure that all elements are numbers.');
                    }
                });
            }
            return val;
        };
    }
}
Validators.getNumberArrayValidator = getNumberArrayValidator;
function getBooleanValidator() {
    if (Global_1$p.Konva.isUnminified) {
        return function (val, attr) {
            var isBool = val === true || val === false;
            if (!isBool) {
                Util_1$f.Util.warn(_formatValue(val) +
                    ' is a not valid value for "' +
                    attr +
                    '" attribute. The value should be a boolean.');
            }
            return val;
        };
    }
}
Validators.getBooleanValidator = getBooleanValidator;
function getComponentValidator(components) {
    if (Global_1$p.Konva.isUnminified) {
        return function (val, attr) {
            if (val === undefined || val === null) {
                return val;
            }
            if (!Util_1$f.Util.isObject(val)) {
                Util_1$f.Util.warn(_formatValue(val) +
                    ' is a not valid value for "' +
                    attr +
                    '" attribute. The value should be an object with properties ' +
                    components);
            }
            return val;
        };
    }
}
Validators.getComponentValidator = getComponentValidator;

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Factory = void 0;
	const Util_1 = Util;
	const Validators_1 = Validators;
	var GET = 'get', SET = 'set';
	exports.Factory = {
	    addGetterSetter(constructor, attr, def, validator, after) {
	        exports.Factory.addGetter(constructor, attr, def);
	        exports.Factory.addSetter(constructor, attr, validator, after);
	        exports.Factory.addOverloadedGetterSetter(constructor, attr);
	    },
	    addGetter(constructor, attr, def) {
	        var method = GET + Util_1.Util._capitalize(attr);
	        constructor.prototype[method] =
	            constructor.prototype[method] ||
	                function () {
	                    var val = this.attrs[attr];
	                    return val === undefined ? def : val;
	                };
	    },
	    addSetter(constructor, attr, validator, after) {
	        var method = SET + Util_1.Util._capitalize(attr);
	        if (!constructor.prototype[method]) {
	            exports.Factory.overWriteSetter(constructor, attr, validator, after);
	        }
	    },
	    overWriteSetter(constructor, attr, validator, after) {
	        var method = SET + Util_1.Util._capitalize(attr);
	        constructor.prototype[method] = function (val) {
	            if (validator && val !== undefined && val !== null) {
	                val = validator.call(this, val, attr);
	            }
	            this._setAttr(attr, val);
	            if (after) {
	                after.call(this);
	            }
	            return this;
	        };
	    },
	    addComponentsGetterSetter(constructor, attr, components, validator, after) {
	        var len = components.length, capitalize = Util_1.Util._capitalize, getter = GET + capitalize(attr), setter = SET + capitalize(attr), n, component;
	        constructor.prototype[getter] = function () {
	            var ret = {};
	            for (n = 0; n < len; n++) {
	                component = components[n];
	                ret[component] = this.getAttr(attr + capitalize(component));
	            }
	            return ret;
	        };
	        var basicValidator = (0, Validators_1.getComponentValidator)(components);
	        constructor.prototype[setter] = function (val) {
	            var oldVal = this.attrs[attr], key;
	            if (validator) {
	                val = validator.call(this, val);
	            }
	            if (basicValidator) {
	                basicValidator.call(this, val, attr);
	            }
	            for (key in val) {
	                if (!val.hasOwnProperty(key)) {
	                    continue;
	                }
	                this._setAttr(attr + capitalize(key), val[key]);
	            }
	            if (!val) {
	                components.forEach((component) => {
	                    this._setAttr(attr + capitalize(component), undefined);
	                });
	            }
	            this._fireChangeEvent(attr, oldVal, val);
	            if (after) {
	                after.call(this);
	            }
	            return this;
	        };
	        exports.Factory.addOverloadedGetterSetter(constructor, attr);
	    },
	    addOverloadedGetterSetter(constructor, attr) {
	        var capitalizedAttr = Util_1.Util._capitalize(attr), setter = SET + capitalizedAttr, getter = GET + capitalizedAttr;
	        constructor.prototype[attr] = function () {
	            if (arguments.length) {
	                this[setter](arguments[0]);
	                return this;
	            }
	            return this[getter]();
	        };
	    },
	    addDeprecatedGetterSetter(constructor, attr, def, validator) {
	        Util_1.Util.error('Adding deprecated ' + attr);
	        var method = GET + Util_1.Util._capitalize(attr);
	        var message = attr +
	            ' property is deprecated and will be removed soon. Look at Konva change log for more information.';
	        constructor.prototype[method] = function () {
	            Util_1.Util.error(message);
	            var val = this.attrs[attr];
	            return val === undefined ? def : val;
	        };
	        exports.Factory.addSetter(constructor, attr, validator, function () {
	            Util_1.Util.error(message);
	        });
	        exports.Factory.addOverloadedGetterSetter(constructor, attr);
	    },
	    backCompat(constructor, methods) {
	        Util_1.Util.each(methods, function (oldMethodName, newMethodName) {
	            var method = constructor.prototype[newMethodName];
	            var oldGetter = GET + Util_1.Util._capitalize(oldMethodName);
	            var oldSetter = SET + Util_1.Util._capitalize(oldMethodName);
	            function deprecated() {
	                method.apply(this, arguments);
	                Util_1.Util.error('"' +
	                    oldMethodName +
	                    '" method is deprecated and will be removed soon. Use ""' +
	                    newMethodName +
	                    '" instead.');
	            }
	            constructor.prototype[oldMethodName] = deprecated;
	            constructor.prototype[oldGetter] = deprecated;
	            constructor.prototype[oldSetter] = deprecated;
	        });
	    },
	    afterSetFilter() {
	        this._filterUpToDate = false;
	    },
	}; 
} (Factory));

var Canvas$2 = {};

var Context$2 = {};

Object.defineProperty(Context$2, "__esModule", { value: true });
Context$2.HitContext = Context$2.SceneContext = Context$2.Context = void 0;
const Util_1$e = Util;
const Global_1$o = Global;
function simplifyArray(arr) {
    var retArr = [], len = arr.length, util = Util_1$e.Util, n, val;
    for (n = 0; n < len; n++) {
        val = arr[n];
        if (util._isNumber(val)) {
            val = Math.round(val * 1000) / 1000;
        }
        else if (!util._isString(val)) {
            val = val + '';
        }
        retArr.push(val);
    }
    return retArr;
}
var COMMA = ',', OPEN_PAREN = '(', CLOSE_PAREN = ')', OPEN_PAREN_BRACKET = '([', CLOSE_BRACKET_PAREN = '])', SEMICOLON = ';', DOUBLE_PAREN = '()', EQUALS = '=', CONTEXT_METHODS = [
    'arc',
    'arcTo',
    'beginPath',
    'bezierCurveTo',
    'clearRect',
    'clip',
    'closePath',
    'createLinearGradient',
    'createPattern',
    'createRadialGradient',
    'drawImage',
    'ellipse',
    'fill',
    'fillText',
    'getImageData',
    'createImageData',
    'lineTo',
    'moveTo',
    'putImageData',
    'quadraticCurveTo',
    'rect',
    'restore',
    'rotate',
    'save',
    'scale',
    'setLineDash',
    'setTransform',
    'stroke',
    'strokeText',
    'transform',
    'translate',
];
var CONTEXT_PROPERTIES = [
    'fillStyle',
    'strokeStyle',
    'shadowColor',
    'shadowBlur',
    'shadowOffsetX',
    'shadowOffsetY',
    'lineCap',
    'lineDashOffset',
    'lineJoin',
    'lineWidth',
    'miterLimit',
    'font',
    'textAlign',
    'textBaseline',
    'globalAlpha',
    'globalCompositeOperation',
    'imageSmoothingEnabled',
];
const traceArrMax = 100;
let Context$1 = class Context {
    constructor(canvas) {
        this.canvas = canvas;
        if (Global_1$o.Konva.enableTrace) {
            this.traceArr = [];
            this._enableTrace();
        }
    }
    fillShape(shape) {
        if (shape.fillEnabled()) {
            this._fill(shape);
        }
    }
    _fill(shape) {
    }
    strokeShape(shape) {
        if (shape.hasStroke()) {
            this._stroke(shape);
        }
    }
    _stroke(shape) {
    }
    fillStrokeShape(shape) {
        if (shape.attrs.fillAfterStrokeEnabled) {
            this.strokeShape(shape);
            this.fillShape(shape);
        }
        else {
            this.fillShape(shape);
            this.strokeShape(shape);
        }
    }
    getTrace(relaxed, rounded) {
        var traceArr = this.traceArr, len = traceArr.length, str = '', n, trace, method, args;
        for (n = 0; n < len; n++) {
            trace = traceArr[n];
            method = trace.method;
            if (method) {
                args = trace.args;
                str += method;
                if (relaxed) {
                    str += DOUBLE_PAREN;
                }
                else {
                    if (Util_1$e.Util._isArray(args[0])) {
                        str += OPEN_PAREN_BRACKET + args.join(COMMA) + CLOSE_BRACKET_PAREN;
                    }
                    else {
                        if (rounded) {
                            args = args.map((a) => typeof a === 'number' ? Math.floor(a) : a);
                        }
                        str += OPEN_PAREN + args.join(COMMA) + CLOSE_PAREN;
                    }
                }
            }
            else {
                str += trace.property;
                if (!relaxed) {
                    str += EQUALS + trace.val;
                }
            }
            str += SEMICOLON;
        }
        return str;
    }
    clearTrace() {
        this.traceArr = [];
    }
    _trace(str) {
        var traceArr = this.traceArr, len;
        traceArr.push(str);
        len = traceArr.length;
        if (len >= traceArrMax) {
            traceArr.shift();
        }
    }
    reset() {
        var pixelRatio = this.getCanvas().getPixelRatio();
        this.setTransform(1 * pixelRatio, 0, 0, 1 * pixelRatio, 0, 0);
    }
    getCanvas() {
        return this.canvas;
    }
    clear(bounds) {
        var canvas = this.getCanvas();
        if (bounds) {
            this.clearRect(bounds.x || 0, bounds.y || 0, bounds.width || 0, bounds.height || 0);
        }
        else {
            this.clearRect(0, 0, canvas.getWidth() / canvas.pixelRatio, canvas.getHeight() / canvas.pixelRatio);
        }
    }
    _applyLineCap(shape) {
        const lineCap = shape.attrs.lineCap;
        if (lineCap) {
            this.setAttr('lineCap', lineCap);
        }
    }
    _applyOpacity(shape) {
        var absOpacity = shape.getAbsoluteOpacity();
        if (absOpacity !== 1) {
            this.setAttr('globalAlpha', absOpacity);
        }
    }
    _applyLineJoin(shape) {
        const lineJoin = shape.attrs.lineJoin;
        if (lineJoin) {
            this.setAttr('lineJoin', lineJoin);
        }
    }
    setAttr(attr, val) {
        this._context[attr] = val;
    }
    arc(a0, a1, a2, a3, a4, a5) {
        this._context.arc(a0, a1, a2, a3, a4, a5);
    }
    arcTo(a0, a1, a2, a3, a4) {
        this._context.arcTo(a0, a1, a2, a3, a4);
    }
    beginPath() {
        this._context.beginPath();
    }
    bezierCurveTo(a0, a1, a2, a3, a4, a5) {
        this._context.bezierCurveTo(a0, a1, a2, a3, a4, a5);
    }
    clearRect(a0, a1, a2, a3) {
        this._context.clearRect(a0, a1, a2, a3);
    }
    clip(...args) {
        this._context.clip.apply(this._context, args);
    }
    closePath() {
        this._context.closePath();
    }
    createImageData(a0, a1) {
        var a = arguments;
        if (a.length === 2) {
            return this._context.createImageData(a0, a1);
        }
        else if (a.length === 1) {
            return this._context.createImageData(a0);
        }
    }
    createLinearGradient(a0, a1, a2, a3) {
        return this._context.createLinearGradient(a0, a1, a2, a3);
    }
    createPattern(a0, a1) {
        return this._context.createPattern(a0, a1);
    }
    createRadialGradient(a0, a1, a2, a3, a4, a5) {
        return this._context.createRadialGradient(a0, a1, a2, a3, a4, a5);
    }
    drawImage(a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        var a = arguments, _context = this._context;
        if (a.length === 3) {
            _context.drawImage(a0, a1, a2);
        }
        else if (a.length === 5) {
            _context.drawImage(a0, a1, a2, a3, a4);
        }
        else if (a.length === 9) {
            _context.drawImage(a0, a1, a2, a3, a4, a5, a6, a7, a8);
        }
    }
    ellipse(a0, a1, a2, a3, a4, a5, a6, a7) {
        this._context.ellipse(a0, a1, a2, a3, a4, a5, a6, a7);
    }
    isPointInPath(x, y, path, fillRule) {
        if (path) {
            return this._context.isPointInPath(path, x, y, fillRule);
        }
        return this._context.isPointInPath(x, y, fillRule);
    }
    fill(...args) {
        this._context.fill.apply(this._context, args);
    }
    fillRect(x, y, width, height) {
        this._context.fillRect(x, y, width, height);
    }
    strokeRect(x, y, width, height) {
        this._context.strokeRect(x, y, width, height);
    }
    fillText(text, x, y, maxWidth) {
        if (maxWidth) {
            this._context.fillText(text, x, y, maxWidth);
        }
        else {
            this._context.fillText(text, x, y);
        }
    }
    measureText(text) {
        return this._context.measureText(text);
    }
    getImageData(a0, a1, a2, a3) {
        return this._context.getImageData(a0, a1, a2, a3);
    }
    lineTo(a0, a1) {
        this._context.lineTo(a0, a1);
    }
    moveTo(a0, a1) {
        this._context.moveTo(a0, a1);
    }
    rect(a0, a1, a2, a3) {
        this._context.rect(a0, a1, a2, a3);
    }
    putImageData(a0, a1, a2) {
        this._context.putImageData(a0, a1, a2);
    }
    quadraticCurveTo(a0, a1, a2, a3) {
        this._context.quadraticCurveTo(a0, a1, a2, a3);
    }
    restore() {
        this._context.restore();
    }
    rotate(a0) {
        this._context.rotate(a0);
    }
    save() {
        this._context.save();
    }
    scale(a0, a1) {
        this._context.scale(a0, a1);
    }
    setLineDash(a0) {
        if (this._context.setLineDash) {
            this._context.setLineDash(a0);
        }
        else if ('mozDash' in this._context) {
            this._context['mozDash'] = a0;
        }
        else if ('webkitLineDash' in this._context) {
            this._context['webkitLineDash'] = a0;
        }
    }
    getLineDash() {
        return this._context.getLineDash();
    }
    setTransform(a0, a1, a2, a3, a4, a5) {
        this._context.setTransform(a0, a1, a2, a3, a4, a5);
    }
    stroke(path2d) {
        if (path2d) {
            this._context.stroke(path2d);
        }
        else {
            this._context.stroke();
        }
    }
    strokeText(a0, a1, a2, a3) {
        this._context.strokeText(a0, a1, a2, a3);
    }
    transform(a0, a1, a2, a3, a4, a5) {
        this._context.transform(a0, a1, a2, a3, a4, a5);
    }
    translate(a0, a1) {
        this._context.translate(a0, a1);
    }
    _enableTrace() {
        var that = this, len = CONTEXT_METHODS.length, origSetter = this.setAttr, n, args;
        var func = function (methodName) {
            var origMethod = that[methodName], ret;
            that[methodName] = function () {
                args = simplifyArray(Array.prototype.slice.call(arguments, 0));
                ret = origMethod.apply(that, arguments);
                that._trace({
                    method: methodName,
                    args: args,
                });
                return ret;
            };
        };
        for (n = 0; n < len; n++) {
            func(CONTEXT_METHODS[n]);
        }
        that.setAttr = function () {
            origSetter.apply(that, arguments);
            var prop = arguments[0];
            var val = arguments[1];
            if (prop === 'shadowOffsetX' ||
                prop === 'shadowOffsetY' ||
                prop === 'shadowBlur') {
                val = val / this.canvas.getPixelRatio();
            }
            that._trace({
                property: prop,
                val: val,
            });
        };
    }
    _applyGlobalCompositeOperation(node) {
        const op = node.attrs.globalCompositeOperation;
        var def = !op || op === 'source-over';
        if (!def) {
            this.setAttr('globalCompositeOperation', op);
        }
    }
};
Context$2.Context = Context$1;
CONTEXT_PROPERTIES.forEach(function (prop) {
    Object.defineProperty(Context$1.prototype, prop, {
        get() {
            return this._context[prop];
        },
        set(val) {
            this._context[prop] = val;
        },
    });
});
class SceneContext extends Context$1 {
    constructor(canvas, { willReadFrequently = false } = {}) {
        super(canvas);
        this._context = canvas._canvas.getContext('2d', {
            willReadFrequently,
        });
    }
    _fillColor(shape) {
        var fill = shape.fill();
        this.setAttr('fillStyle', fill);
        shape._fillFunc(this);
    }
    _fillPattern(shape) {
        this.setAttr('fillStyle', shape._getFillPattern());
        shape._fillFunc(this);
    }
    _fillLinearGradient(shape) {
        var grd = shape._getLinearGradient();
        if (grd) {
            this.setAttr('fillStyle', grd);
            shape._fillFunc(this);
        }
    }
    _fillRadialGradient(shape) {
        const grd = shape._getRadialGradient();
        if (grd) {
            this.setAttr('fillStyle', grd);
            shape._fillFunc(this);
        }
    }
    _fill(shape) {
        const hasColor = shape.fill(), fillPriority = shape.getFillPriority();
        if (hasColor && fillPriority === 'color') {
            this._fillColor(shape);
            return;
        }
        const hasPattern = shape.getFillPatternImage();
        if (hasPattern && fillPriority === 'pattern') {
            this._fillPattern(shape);
            return;
        }
        const hasLinearGradient = shape.getFillLinearGradientColorStops();
        if (hasLinearGradient && fillPriority === 'linear-gradient') {
            this._fillLinearGradient(shape);
            return;
        }
        const hasRadialGradient = shape.getFillRadialGradientColorStops();
        if (hasRadialGradient && fillPriority === 'radial-gradient') {
            this._fillRadialGradient(shape);
            return;
        }
        if (hasColor) {
            this._fillColor(shape);
        }
        else if (hasPattern) {
            this._fillPattern(shape);
        }
        else if (hasLinearGradient) {
            this._fillLinearGradient(shape);
        }
        else if (hasRadialGradient) {
            this._fillRadialGradient(shape);
        }
    }
    _strokeLinearGradient(shape) {
        const start = shape.getStrokeLinearGradientStartPoint(), end = shape.getStrokeLinearGradientEndPoint(), colorStops = shape.getStrokeLinearGradientColorStops(), grd = this.createLinearGradient(start.x, start.y, end.x, end.y);
        if (colorStops) {
            for (var n = 0; n < colorStops.length; n += 2) {
                grd.addColorStop(colorStops[n], colorStops[n + 1]);
            }
            this.setAttr('strokeStyle', grd);
        }
    }
    _stroke(shape) {
        var dash = shape.dash(), strokeScaleEnabled = shape.getStrokeScaleEnabled();
        if (shape.hasStroke()) {
            if (!strokeScaleEnabled) {
                this.save();
                var pixelRatio = this.getCanvas().getPixelRatio();
                this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
            }
            this._applyLineCap(shape);
            if (dash && shape.dashEnabled()) {
                this.setLineDash(dash);
                this.setAttr('lineDashOffset', shape.dashOffset());
            }
            this.setAttr('lineWidth', shape.strokeWidth());
            if (!shape.getShadowForStrokeEnabled()) {
                this.setAttr('shadowColor', 'rgba(0,0,0,0)');
            }
            var hasLinearGradient = shape.getStrokeLinearGradientColorStops();
            if (hasLinearGradient) {
                this._strokeLinearGradient(shape);
            }
            else {
                this.setAttr('strokeStyle', shape.stroke());
            }
            shape._strokeFunc(this);
            if (!strokeScaleEnabled) {
                this.restore();
            }
        }
    }
    _applyShadow(shape) {
        var _a, _b, _c;
        var color = (_a = shape.getShadowRGBA()) !== null && _a !== void 0 ? _a : 'black', blur = (_b = shape.getShadowBlur()) !== null && _b !== void 0 ? _b : 5, offset = (_c = shape.getShadowOffset()) !== null && _c !== void 0 ? _c : {
            x: 0,
            y: 0,
        }, scale = shape.getAbsoluteScale(), ratio = this.canvas.getPixelRatio(), scaleX = scale.x * ratio, scaleY = scale.y * ratio;
        this.setAttr('shadowColor', color);
        this.setAttr('shadowBlur', blur * Math.min(Math.abs(scaleX), Math.abs(scaleY)));
        this.setAttr('shadowOffsetX', offset.x * scaleX);
        this.setAttr('shadowOffsetY', offset.y * scaleY);
    }
}
Context$2.SceneContext = SceneContext;
class HitContext extends Context$1 {
    constructor(canvas) {
        super(canvas);
        this._context = canvas._canvas.getContext('2d', {
            willReadFrequently: true,
        });
    }
    _fill(shape) {
        this.save();
        this.setAttr('fillStyle', shape.colorKey);
        shape._fillFuncHit(this);
        this.restore();
    }
    strokeShape(shape) {
        if (shape.hasHitStroke()) {
            this._stroke(shape);
        }
    }
    _stroke(shape) {
        if (shape.hasHitStroke()) {
            const strokeScaleEnabled = shape.getStrokeScaleEnabled();
            if (!strokeScaleEnabled) {
                this.save();
                var pixelRatio = this.getCanvas().getPixelRatio();
                this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
            }
            this._applyLineCap(shape);
            var hitStrokeWidth = shape.hitStrokeWidth();
            var strokeWidth = hitStrokeWidth === 'auto' ? shape.strokeWidth() : hitStrokeWidth;
            this.setAttr('lineWidth', strokeWidth);
            this.setAttr('strokeStyle', shape.colorKey);
            shape._strokeFuncHit(this);
            if (!strokeScaleEnabled) {
                this.restore();
            }
        }
    }
}
Context$2.HitContext = HitContext;

Object.defineProperty(Canvas$2, "__esModule", { value: true });
Canvas$2.HitCanvas = Canvas$2.SceneCanvas = Canvas$2.Canvas = void 0;
const Util_1$d = Util;
const Context_1 = Context$2;
const Global_1$n = Global;
const Factory_1$z = Factory;
const Validators_1$y = Validators;
var _pixelRatio;
function getDevicePixelRatio() {
    if (_pixelRatio) {
        return _pixelRatio;
    }
    var canvas = Util_1$d.Util.createCanvasElement();
    var context = canvas.getContext('2d');
    _pixelRatio = (function () {
        var devicePixelRatio = Global_1$n.Konva._global.devicePixelRatio || 1, backingStoreRatio = context.webkitBackingStorePixelRatio ||
            context.mozBackingStorePixelRatio ||
            context.msBackingStorePixelRatio ||
            context.oBackingStorePixelRatio ||
            context.backingStorePixelRatio ||
            1;
        return devicePixelRatio / backingStoreRatio;
    })();
    Util_1$d.Util.releaseCanvas(canvas);
    return _pixelRatio;
}
let Canvas$1 = class Canvas {
    constructor(config) {
        this.pixelRatio = 1;
        this.width = 0;
        this.height = 0;
        this.isCache = false;
        var conf = config || {};
        var pixelRatio = conf.pixelRatio || Global_1$n.Konva.pixelRatio || getDevicePixelRatio();
        this.pixelRatio = pixelRatio;
        this._canvas = Util_1$d.Util.createCanvasElement();
        this._canvas.style.padding = '0';
        this._canvas.style.margin = '0';
        this._canvas.style.border = '0';
        this._canvas.style.background = 'transparent';
        this._canvas.style.position = 'absolute';
        this._canvas.style.top = '0';
        this._canvas.style.left = '0';
    }
    getContext() {
        return this.context;
    }
    getPixelRatio() {
        return this.pixelRatio;
    }
    setPixelRatio(pixelRatio) {
        var previousRatio = this.pixelRatio;
        this.pixelRatio = pixelRatio;
        this.setSize(this.getWidth() / previousRatio, this.getHeight() / previousRatio);
    }
    setWidth(width) {
        this.width = this._canvas.width = width * this.pixelRatio;
        this._canvas.style.width = width + 'px';
        var pixelRatio = this.pixelRatio, _context = this.getContext()._context;
        _context.scale(pixelRatio, pixelRatio);
    }
    setHeight(height) {
        this.height = this._canvas.height = height * this.pixelRatio;
        this._canvas.style.height = height + 'px';
        var pixelRatio = this.pixelRatio, _context = this.getContext()._context;
        _context.scale(pixelRatio, pixelRatio);
    }
    getWidth() {
        return this.width;
    }
    getHeight() {
        return this.height;
    }
    setSize(width, height) {
        this.setWidth(width || 0);
        this.setHeight(height || 0);
    }
    toDataURL(mimeType, quality) {
        try {
            return this._canvas.toDataURL(mimeType, quality);
        }
        catch (e) {
            try {
                return this._canvas.toDataURL();
            }
            catch (err) {
                Util_1$d.Util.error('Unable to get data URL. ' +
                    err.message +
                    ' For more info read https://konvajs.org/docs/posts/Tainted_Canvas.html.');
                return '';
            }
        }
    }
};
Canvas$2.Canvas = Canvas$1;
Factory_1$z.Factory.addGetterSetter(Canvas$1, 'pixelRatio', undefined, (0, Validators_1$y.getNumberValidator)());
class SceneCanvas extends Canvas$1 {
    constructor(config = { width: 0, height: 0, willReadFrequently: false }) {
        super(config);
        this.context = new Context_1.SceneContext(this, {
            willReadFrequently: config.willReadFrequently,
        });
        this.setSize(config.width, config.height);
    }
}
Canvas$2.SceneCanvas = SceneCanvas;
class HitCanvas extends Canvas$1 {
    constructor(config = { width: 0, height: 0 }) {
        super(config);
        this.hitCanvas = true;
        this.context = new Context_1.HitContext(this);
        this.setSize(config.width, config.height);
    }
}
Canvas$2.HitCanvas = HitCanvas;

var DragAndDrop = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DD = void 0;
	const Global_1 = Global;
	const Util_1 = Util;
	exports.DD = {
	    get isDragging() {
	        var flag = false;
	        exports.DD._dragElements.forEach((elem) => {
	            if (elem.dragStatus === 'dragging') {
	                flag = true;
	            }
	        });
	        return flag;
	    },
	    justDragged: false,
	    get node() {
	        var node;
	        exports.DD._dragElements.forEach((elem) => {
	            node = elem.node;
	        });
	        return node;
	    },
	    _dragElements: new Map(),
	    _drag(evt) {
	        const nodesToFireEvents = [];
	        exports.DD._dragElements.forEach((elem, key) => {
	            const { node } = elem;
	            const stage = node.getStage();
	            stage.setPointersPositions(evt);
	            if (elem.pointerId === undefined) {
	                elem.pointerId = Util_1.Util._getFirstPointerId(evt);
	            }
	            const pos = stage._changedPointerPositions.find((pos) => pos.id === elem.pointerId);
	            if (!pos) {
	                return;
	            }
	            if (elem.dragStatus !== 'dragging') {
	                var dragDistance = node.dragDistance();
	                var distance = Math.max(Math.abs(pos.x - elem.startPointerPos.x), Math.abs(pos.y - elem.startPointerPos.y));
	                if (distance < dragDistance) {
	                    return;
	                }
	                node.startDrag({ evt });
	                if (!node.isDragging()) {
	                    return;
	                }
	            }
	            node._setDragPosition(evt, elem);
	            nodesToFireEvents.push(node);
	        });
	        nodesToFireEvents.forEach((node) => {
	            node.fire('dragmove', {
	                type: 'dragmove',
	                target: node,
	                evt: evt,
	            }, true);
	        });
	    },
	    _endDragBefore(evt) {
	        const drawNodes = [];
	        exports.DD._dragElements.forEach((elem) => {
	            const { node } = elem;
	            const stage = node.getStage();
	            if (evt) {
	                stage.setPointersPositions(evt);
	            }
	            const pos = stage._changedPointerPositions.find((pos) => pos.id === elem.pointerId);
	            if (!pos) {
	                return;
	            }
	            if (elem.dragStatus === 'dragging' || elem.dragStatus === 'stopped') {
	                exports.DD.justDragged = true;
	                Global_1.Konva._mouseListenClick = false;
	                Global_1.Konva._touchListenClick = false;
	                Global_1.Konva._pointerListenClick = false;
	                elem.dragStatus = 'stopped';
	            }
	            const drawNode = elem.node.getLayer() ||
	                (elem.node instanceof Global_1.Konva['Stage'] && elem.node);
	            if (drawNode && drawNodes.indexOf(drawNode) === -1) {
	                drawNodes.push(drawNode);
	            }
	        });
	        drawNodes.forEach((drawNode) => {
	            drawNode.draw();
	        });
	    },
	    _endDragAfter(evt) {
	        exports.DD._dragElements.forEach((elem, key) => {
	            if (elem.dragStatus === 'stopped') {
	                elem.node.fire('dragend', {
	                    type: 'dragend',
	                    target: elem.node,
	                    evt: evt,
	                }, true);
	            }
	            if (elem.dragStatus !== 'dragging') {
	                exports.DD._dragElements.delete(key);
	            }
	        });
	    },
	};
	if (Global_1.Konva.isBrowser) {
	    window.addEventListener('mouseup', exports.DD._endDragBefore, true);
	    window.addEventListener('touchend', exports.DD._endDragBefore, true);
	    window.addEventListener('mousemove', exports.DD._drag);
	    window.addEventListener('touchmove', exports.DD._drag);
	    window.addEventListener('mouseup', exports.DD._endDragAfter, false);
	    window.addEventListener('touchend', exports.DD._endDragAfter, false);
	} 
} (DragAndDrop));

Object.defineProperty(Node$2, "__esModule", { value: true });
Node$2.Node = void 0;
const Util_1$c = Util;
const Factory_1$y = Factory;
const Canvas_1$1 = Canvas$2;
const Global_1$m = Global;
const DragAndDrop_1 = DragAndDrop;
const Validators_1$x = Validators;
var ABSOLUTE_OPACITY = 'absoluteOpacity', ALL_LISTENERS = 'allEventListeners', ABSOLUTE_TRANSFORM = 'absoluteTransform', ABSOLUTE_SCALE = 'absoluteScale', CANVAS = 'canvas', CHANGE = 'Change', CHILDREN = 'children', KONVA = 'konva', LISTENING = 'listening', MOUSEENTER = 'mouseenter', MOUSELEAVE = 'mouseleave', SET = 'set', SHAPE = 'Shape', SPACE$1 = ' ', STAGE = 'stage', TRANSFORM = 'transform', UPPER_STAGE = 'Stage', VISIBLE = 'visible', TRANSFORM_CHANGE_STR$1 = [
    'xChange.konva',
    'yChange.konva',
    'scaleXChange.konva',
    'scaleYChange.konva',
    'skewXChange.konva',
    'skewYChange.konva',
    'rotationChange.konva',
    'offsetXChange.konva',
    'offsetYChange.konva',
    'transformsEnabledChange.konva',
].join(SPACE$1);
let idCounter = 1;
let Node$1 = class Node {
    constructor(config) {
        this._id = idCounter++;
        this.eventListeners = {};
        this.attrs = {};
        this.index = 0;
        this._allEventListeners = null;
        this.parent = null;
        this._cache = new Map();
        this._attachedDepsListeners = new Map();
        this._lastPos = null;
        this._batchingTransformChange = false;
        this._needClearTransformCache = false;
        this._filterUpToDate = false;
        this._isUnderCache = false;
        this._dragEventId = null;
        this._shouldFireChangeEvents = false;
        this.setAttrs(config);
        this._shouldFireChangeEvents = true;
    }
    hasChildren() {
        return false;
    }
    _clearCache(attr) {
        if ((attr === TRANSFORM || attr === ABSOLUTE_TRANSFORM) &&
            this._cache.get(attr)) {
            this._cache.get(attr).dirty = true;
        }
        else if (attr) {
            this._cache.delete(attr);
        }
        else {
            this._cache.clear();
        }
    }
    _getCache(attr, privateGetter) {
        var cache = this._cache.get(attr);
        var isTransform = attr === TRANSFORM || attr === ABSOLUTE_TRANSFORM;
        var invalid = cache === undefined || (isTransform && cache.dirty === true);
        if (invalid) {
            cache = privateGetter.call(this);
            this._cache.set(attr, cache);
        }
        return cache;
    }
    _calculate(name, deps, getter) {
        if (!this._attachedDepsListeners.get(name)) {
            const depsString = deps.map((dep) => dep + 'Change.konva').join(SPACE$1);
            this.on(depsString, () => {
                this._clearCache(name);
            });
            this._attachedDepsListeners.set(name, true);
        }
        return this._getCache(name, getter);
    }
    _getCanvasCache() {
        return this._cache.get(CANVAS);
    }
    _clearSelfAndDescendantCache(attr) {
        this._clearCache(attr);
        if (attr === ABSOLUTE_TRANSFORM) {
            this.fire('absoluteTransformChange');
        }
    }
    clearCache() {
        if (this._cache.has(CANVAS)) {
            const { scene, filter, hit } = this._cache.get(CANVAS);
            Util_1$c.Util.releaseCanvas(scene, filter, hit);
            this._cache.delete(CANVAS);
        }
        this._clearSelfAndDescendantCache();
        this._requestDraw();
        return this;
    }
    cache(config) {
        var conf = config || {};
        var rect = {};
        if (conf.x === undefined ||
            conf.y === undefined ||
            conf.width === undefined ||
            conf.height === undefined) {
            rect = this.getClientRect({
                skipTransform: true,
                relativeTo: this.getParent(),
            });
        }
        var width = Math.ceil(conf.width || rect.width), height = Math.ceil(conf.height || rect.height), pixelRatio = conf.pixelRatio, x = conf.x === undefined ? Math.floor(rect.x) : conf.x, y = conf.y === undefined ? Math.floor(rect.y) : conf.y, offset = conf.offset || 0, drawBorder = conf.drawBorder || false, hitCanvasPixelRatio = conf.hitCanvasPixelRatio || 1;
        if (!width || !height) {
            Util_1$c.Util.error('Can not cache the node. Width or height of the node equals 0. Caching is skipped.');
            return;
        }
        width += offset * 2 + 1;
        height += offset * 2 + 1;
        x -= offset;
        y -= offset;
        var cachedSceneCanvas = new Canvas_1$1.SceneCanvas({
            pixelRatio: pixelRatio,
            width: width,
            height: height,
        }), cachedFilterCanvas = new Canvas_1$1.SceneCanvas({
            pixelRatio: pixelRatio,
            width: 0,
            height: 0,
            willReadFrequently: true,
        }), cachedHitCanvas = new Canvas_1$1.HitCanvas({
            pixelRatio: hitCanvasPixelRatio,
            width: width,
            height: height,
        }), sceneContext = cachedSceneCanvas.getContext(), hitContext = cachedHitCanvas.getContext();
        cachedHitCanvas.isCache = true;
        cachedSceneCanvas.isCache = true;
        this._cache.delete(CANVAS);
        this._filterUpToDate = false;
        if (conf.imageSmoothingEnabled === false) {
            cachedSceneCanvas.getContext()._context.imageSmoothingEnabled = false;
            cachedFilterCanvas.getContext()._context.imageSmoothingEnabled = false;
        }
        sceneContext.save();
        hitContext.save();
        sceneContext.translate(-x, -y);
        hitContext.translate(-x, -y);
        this._isUnderCache = true;
        this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
        this._clearSelfAndDescendantCache(ABSOLUTE_SCALE);
        this.drawScene(cachedSceneCanvas, this);
        this.drawHit(cachedHitCanvas, this);
        this._isUnderCache = false;
        sceneContext.restore();
        hitContext.restore();
        if (drawBorder) {
            sceneContext.save();
            sceneContext.beginPath();
            sceneContext.rect(0, 0, width, height);
            sceneContext.closePath();
            sceneContext.setAttr('strokeStyle', 'red');
            sceneContext.setAttr('lineWidth', 5);
            sceneContext.stroke();
            sceneContext.restore();
        }
        this._cache.set(CANVAS, {
            scene: cachedSceneCanvas,
            filter: cachedFilterCanvas,
            hit: cachedHitCanvas,
            x: x,
            y: y,
        });
        this._requestDraw();
        return this;
    }
    isCached() {
        return this._cache.has(CANVAS);
    }
    getClientRect(config) {
        throw new Error('abstract "getClientRect" method call');
    }
    _transformedRect(rect, top) {
        var points = [
            { x: rect.x, y: rect.y },
            { x: rect.x + rect.width, y: rect.y },
            { x: rect.x + rect.width, y: rect.y + rect.height },
            { x: rect.x, y: rect.y + rect.height },
        ];
        var minX, minY, maxX, maxY;
        var trans = this.getAbsoluteTransform(top);
        points.forEach(function (point) {
            var transformed = trans.point(point);
            if (minX === undefined) {
                minX = maxX = transformed.x;
                minY = maxY = transformed.y;
            }
            minX = Math.min(minX, transformed.x);
            minY = Math.min(minY, transformed.y);
            maxX = Math.max(maxX, transformed.x);
            maxY = Math.max(maxY, transformed.y);
        });
        return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY,
        };
    }
    _drawCachedSceneCanvas(context) {
        context.save();
        context._applyOpacity(this);
        context._applyGlobalCompositeOperation(this);
        const canvasCache = this._getCanvasCache();
        context.translate(canvasCache.x, canvasCache.y);
        var cacheCanvas = this._getCachedSceneCanvas();
        var ratio = cacheCanvas.pixelRatio;
        context.drawImage(cacheCanvas._canvas, 0, 0, cacheCanvas.width / ratio, cacheCanvas.height / ratio);
        context.restore();
    }
    _drawCachedHitCanvas(context) {
        var canvasCache = this._getCanvasCache(), hitCanvas = canvasCache.hit;
        context.save();
        context.translate(canvasCache.x, canvasCache.y);
        context.drawImage(hitCanvas._canvas, 0, 0, hitCanvas.width / hitCanvas.pixelRatio, hitCanvas.height / hitCanvas.pixelRatio);
        context.restore();
    }
    _getCachedSceneCanvas() {
        var filters = this.filters(), cachedCanvas = this._getCanvasCache(), sceneCanvas = cachedCanvas.scene, filterCanvas = cachedCanvas.filter, filterContext = filterCanvas.getContext(), len, imageData, n, filter;
        if (filters) {
            if (!this._filterUpToDate) {
                var ratio = sceneCanvas.pixelRatio;
                filterCanvas.setSize(sceneCanvas.width / sceneCanvas.pixelRatio, sceneCanvas.height / sceneCanvas.pixelRatio);
                try {
                    len = filters.length;
                    filterContext.clear();
                    filterContext.drawImage(sceneCanvas._canvas, 0, 0, sceneCanvas.getWidth() / ratio, sceneCanvas.getHeight() / ratio);
                    imageData = filterContext.getImageData(0, 0, filterCanvas.getWidth(), filterCanvas.getHeight());
                    for (n = 0; n < len; n++) {
                        filter = filters[n];
                        if (typeof filter !== 'function') {
                            Util_1$c.Util.error('Filter should be type of function, but got ' +
                                typeof filter +
                                ' instead. Please check correct filters');
                            continue;
                        }
                        filter.call(this, imageData);
                        filterContext.putImageData(imageData, 0, 0);
                    }
                }
                catch (e) {
                    Util_1$c.Util.error('Unable to apply filter. ' +
                        e.message +
                        ' This post my help you https://konvajs.org/docs/posts/Tainted_Canvas.html.');
                }
                this._filterUpToDate = true;
            }
            return filterCanvas;
        }
        return sceneCanvas;
    }
    on(evtStr, handler) {
        this._cache && this._cache.delete(ALL_LISTENERS);
        if (arguments.length === 3) {
            return this._delegate.apply(this, arguments);
        }
        var events = evtStr.split(SPACE$1), len = events.length, n, event, parts, baseEvent, name;
        for (n = 0; n < len; n++) {
            event = events[n];
            parts = event.split('.');
            baseEvent = parts[0];
            name = parts[1] || '';
            if (!this.eventListeners[baseEvent]) {
                this.eventListeners[baseEvent] = [];
            }
            this.eventListeners[baseEvent].push({
                name: name,
                handler: handler,
            });
        }
        return this;
    }
    off(evtStr, callback) {
        var events = (evtStr || '').split(SPACE$1), len = events.length, n, t, event, parts, baseEvent, name;
        this._cache && this._cache.delete(ALL_LISTENERS);
        if (!evtStr) {
            for (t in this.eventListeners) {
                this._off(t);
            }
        }
        for (n = 0; n < len; n++) {
            event = events[n];
            parts = event.split('.');
            baseEvent = parts[0];
            name = parts[1];
            if (baseEvent) {
                if (this.eventListeners[baseEvent]) {
                    this._off(baseEvent, name, callback);
                }
            }
            else {
                for (t in this.eventListeners) {
                    this._off(t, name, callback);
                }
            }
        }
        return this;
    }
    dispatchEvent(evt) {
        var e = {
            target: this,
            type: evt.type,
            evt: evt,
        };
        this.fire(evt.type, e);
        return this;
    }
    addEventListener(type, handler) {
        this.on(type, function (evt) {
            handler.call(this, evt.evt);
        });
        return this;
    }
    removeEventListener(type) {
        this.off(type);
        return this;
    }
    _delegate(event, selector, handler) {
        var stopNode = this;
        this.on(event, function (evt) {
            var targets = evt.target.findAncestors(selector, true, stopNode);
            for (var i = 0; i < targets.length; i++) {
                evt = Util_1$c.Util.cloneObject(evt);
                evt.currentTarget = targets[i];
                handler.call(targets[i], evt);
            }
        });
    }
    remove() {
        if (this.isDragging()) {
            this.stopDrag();
        }
        DragAndDrop_1.DD._dragElements.delete(this._id);
        this._remove();
        return this;
    }
    _clearCaches() {
        this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
        this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
        this._clearSelfAndDescendantCache(ABSOLUTE_SCALE);
        this._clearSelfAndDescendantCache(STAGE);
        this._clearSelfAndDescendantCache(VISIBLE);
        this._clearSelfAndDescendantCache(LISTENING);
    }
    _remove() {
        this._clearCaches();
        var parent = this.getParent();
        if (parent && parent.children) {
            parent.children.splice(this.index, 1);
            parent._setChildrenIndices();
            this.parent = null;
        }
    }
    destroy() {
        this.remove();
        this.clearCache();
        return this;
    }
    getAttr(attr) {
        var method = 'get' + Util_1$c.Util._capitalize(attr);
        if (Util_1$c.Util._isFunction(this[method])) {
            return this[method]();
        }
        return this.attrs[attr];
    }
    getAncestors() {
        var parent = this.getParent(), ancestors = [];
        while (parent) {
            ancestors.push(parent);
            parent = parent.getParent();
        }
        return ancestors;
    }
    getAttrs() {
        return this.attrs || {};
    }
    setAttrs(config) {
        this._batchTransformChanges(() => {
            var key, method;
            if (!config) {
                return this;
            }
            for (key in config) {
                if (key === CHILDREN) {
                    continue;
                }
                method = SET + Util_1$c.Util._capitalize(key);
                if (Util_1$c.Util._isFunction(this[method])) {
                    this[method](config[key]);
                }
                else {
                    this._setAttr(key, config[key]);
                }
            }
        });
        return this;
    }
    isListening() {
        return this._getCache(LISTENING, this._isListening);
    }
    _isListening(relativeTo) {
        const listening = this.listening();
        if (!listening) {
            return false;
        }
        const parent = this.getParent();
        if (parent && parent !== relativeTo && this !== relativeTo) {
            return parent._isListening(relativeTo);
        }
        else {
            return true;
        }
    }
    isVisible() {
        return this._getCache(VISIBLE, this._isVisible);
    }
    _isVisible(relativeTo) {
        const visible = this.visible();
        if (!visible) {
            return false;
        }
        const parent = this.getParent();
        if (parent && parent !== relativeTo && this !== relativeTo) {
            return parent._isVisible(relativeTo);
        }
        else {
            return true;
        }
    }
    shouldDrawHit(top, skipDragCheck = false) {
        if (top) {
            return this._isVisible(top) && this._isListening(top);
        }
        var layer = this.getLayer();
        var layerUnderDrag = false;
        DragAndDrop_1.DD._dragElements.forEach((elem) => {
            if (elem.dragStatus !== 'dragging') {
                return;
            }
            else if (elem.node.nodeType === 'Stage') {
                layerUnderDrag = true;
            }
            else if (elem.node.getLayer() === layer) {
                layerUnderDrag = true;
            }
        });
        var dragSkip = !skipDragCheck && !Global_1$m.Konva.hitOnDragEnabled && layerUnderDrag;
        return this.isListening() && this.isVisible() && !dragSkip;
    }
    show() {
        this.visible(true);
        return this;
    }
    hide() {
        this.visible(false);
        return this;
    }
    getZIndex() {
        return this.index || 0;
    }
    getAbsoluteZIndex() {
        var depth = this.getDepth(), that = this, index = 0, nodes, len, n, child;
        function addChildren(children) {
            nodes = [];
            len = children.length;
            for (n = 0; n < len; n++) {
                child = children[n];
                index++;
                if (child.nodeType !== SHAPE) {
                    nodes = nodes.concat(child.getChildren().slice());
                }
                if (child._id === that._id) {
                    n = len;
                }
            }
            if (nodes.length > 0 && nodes[0].getDepth() <= depth) {
                addChildren(nodes);
            }
        }
        if (that.nodeType !== UPPER_STAGE) {
            addChildren(that.getStage().getChildren());
        }
        return index;
    }
    getDepth() {
        var depth = 0, parent = this.parent;
        while (parent) {
            depth++;
            parent = parent.parent;
        }
        return depth;
    }
    _batchTransformChanges(func) {
        this._batchingTransformChange = true;
        func();
        this._batchingTransformChange = false;
        if (this._needClearTransformCache) {
            this._clearCache(TRANSFORM);
            this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
        }
        this._needClearTransformCache = false;
    }
    setPosition(pos) {
        this._batchTransformChanges(() => {
            this.x(pos.x);
            this.y(pos.y);
        });
        return this;
    }
    getPosition() {
        return {
            x: this.x(),
            y: this.y(),
        };
    }
    getRelativePointerPosition() {
        if (!this.getStage()) {
            return null;
        }
        var pos = this.getStage().getPointerPosition();
        if (!pos) {
            return null;
        }
        var transform = this.getAbsoluteTransform().copy();
        transform.invert();
        return transform.point(pos);
    }
    getAbsolutePosition(top) {
        let haveCachedParent = false;
        let parent = this.parent;
        while (parent) {
            if (parent.isCached()) {
                haveCachedParent = true;
                break;
            }
            parent = parent.parent;
        }
        if (haveCachedParent && !top) {
            top = true;
        }
        var absoluteMatrix = this.getAbsoluteTransform(top).getMatrix(), absoluteTransform = new Util_1$c.Transform(), offset = this.offset();
        absoluteTransform.m = absoluteMatrix.slice();
        absoluteTransform.translate(offset.x, offset.y);
        return absoluteTransform.getTranslation();
    }
    setAbsolutePosition(pos) {
        var origTrans = this._clearTransform();
        this.attrs.x = origTrans.x;
        this.attrs.y = origTrans.y;
        delete origTrans.x;
        delete origTrans.y;
        this._clearCache(TRANSFORM);
        var it = this._getAbsoluteTransform().copy();
        it.invert();
        it.translate(pos.x, pos.y);
        pos = {
            x: this.attrs.x + it.getTranslation().x,
            y: this.attrs.y + it.getTranslation().y,
        };
        this._setTransform(origTrans);
        this.setPosition({ x: pos.x, y: pos.y });
        this._clearCache(TRANSFORM);
        this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
        return this;
    }
    _setTransform(trans) {
        var key;
        for (key in trans) {
            this.attrs[key] = trans[key];
        }
    }
    _clearTransform() {
        var trans = {
            x: this.x(),
            y: this.y(),
            rotation: this.rotation(),
            scaleX: this.scaleX(),
            scaleY: this.scaleY(),
            offsetX: this.offsetX(),
            offsetY: this.offsetY(),
            skewX: this.skewX(),
            skewY: this.skewY(),
        };
        this.attrs.x = 0;
        this.attrs.y = 0;
        this.attrs.rotation = 0;
        this.attrs.scaleX = 1;
        this.attrs.scaleY = 1;
        this.attrs.offsetX = 0;
        this.attrs.offsetY = 0;
        this.attrs.skewX = 0;
        this.attrs.skewY = 0;
        return trans;
    }
    move(change) {
        var changeX = change.x, changeY = change.y, x = this.x(), y = this.y();
        if (changeX !== undefined) {
            x += changeX;
        }
        if (changeY !== undefined) {
            y += changeY;
        }
        this.setPosition({ x: x, y: y });
        return this;
    }
    _eachAncestorReverse(func, top) {
        var family = [], parent = this.getParent(), len, n;
        if (top && top._id === this._id) {
            return;
        }
        family.unshift(this);
        while (parent && (!top || parent._id !== top._id)) {
            family.unshift(parent);
            parent = parent.parent;
        }
        len = family.length;
        for (n = 0; n < len; n++) {
            func(family[n]);
        }
    }
    rotate(theta) {
        this.rotation(this.rotation() + theta);
        return this;
    }
    moveToTop() {
        if (!this.parent) {
            Util_1$c.Util.warn('Node has no parent. moveToTop function is ignored.');
            return false;
        }
        var index = this.index, len = this.parent.getChildren().length;
        if (index < len - 1) {
            this.parent.children.splice(index, 1);
            this.parent.children.push(this);
            this.parent._setChildrenIndices();
            return true;
        }
        return false;
    }
    moveUp() {
        if (!this.parent) {
            Util_1$c.Util.warn('Node has no parent. moveUp function is ignored.');
            return false;
        }
        var index = this.index, len = this.parent.getChildren().length;
        if (index < len - 1) {
            this.parent.children.splice(index, 1);
            this.parent.children.splice(index + 1, 0, this);
            this.parent._setChildrenIndices();
            return true;
        }
        return false;
    }
    moveDown() {
        if (!this.parent) {
            Util_1$c.Util.warn('Node has no parent. moveDown function is ignored.');
            return false;
        }
        var index = this.index;
        if (index > 0) {
            this.parent.children.splice(index, 1);
            this.parent.children.splice(index - 1, 0, this);
            this.parent._setChildrenIndices();
            return true;
        }
        return false;
    }
    moveToBottom() {
        if (!this.parent) {
            Util_1$c.Util.warn('Node has no parent. moveToBottom function is ignored.');
            return false;
        }
        var index = this.index;
        if (index > 0) {
            this.parent.children.splice(index, 1);
            this.parent.children.unshift(this);
            this.parent._setChildrenIndices();
            return true;
        }
        return false;
    }
    setZIndex(zIndex) {
        if (!this.parent) {
            Util_1$c.Util.warn('Node has no parent. zIndex parameter is ignored.');
            return this;
        }
        if (zIndex < 0 || zIndex >= this.parent.children.length) {
            Util_1$c.Util.warn('Unexpected value ' +
                zIndex +
                ' for zIndex property. zIndex is just index of a node in children of its parent. Expected value is from 0 to ' +
                (this.parent.children.length - 1) +
                '.');
        }
        var index = this.index;
        this.parent.children.splice(index, 1);
        this.parent.children.splice(zIndex, 0, this);
        this.parent._setChildrenIndices();
        return this;
    }
    getAbsoluteOpacity() {
        return this._getCache(ABSOLUTE_OPACITY, this._getAbsoluteOpacity);
    }
    _getAbsoluteOpacity() {
        var absOpacity = this.opacity();
        var parent = this.getParent();
        if (parent && !parent._isUnderCache) {
            absOpacity *= parent.getAbsoluteOpacity();
        }
        return absOpacity;
    }
    moveTo(newContainer) {
        if (this.getParent() !== newContainer) {
            this._remove();
            newContainer.add(this);
        }
        return this;
    }
    toObject() {
        var obj = {}, attrs = this.getAttrs(), key, val, getter, defaultValue, nonPlainObject;
        obj.attrs = {};
        for (key in attrs) {
            val = attrs[key];
            nonPlainObject =
                Util_1$c.Util.isObject(val) && !Util_1$c.Util._isPlainObject(val) && !Util_1$c.Util._isArray(val);
            if (nonPlainObject) {
                continue;
            }
            getter = typeof this[key] === 'function' && this[key];
            delete attrs[key];
            defaultValue = getter ? getter.call(this) : null;
            attrs[key] = val;
            if (defaultValue !== val) {
                obj.attrs[key] = val;
            }
        }
        obj.className = this.getClassName();
        return Util_1$c.Util._prepareToStringify(obj);
    }
    toJSON() {
        return JSON.stringify(this.toObject());
    }
    getParent() {
        return this.parent;
    }
    findAncestors(selector, includeSelf, stopNode) {
        var res = [];
        if (includeSelf && this._isMatch(selector)) {
            res.push(this);
        }
        var ancestor = this.parent;
        while (ancestor) {
            if (ancestor === stopNode) {
                return res;
            }
            if (ancestor._isMatch(selector)) {
                res.push(ancestor);
            }
            ancestor = ancestor.parent;
        }
        return res;
    }
    isAncestorOf(node) {
        return false;
    }
    findAncestor(selector, includeSelf, stopNode) {
        return this.findAncestors(selector, includeSelf, stopNode)[0];
    }
    _isMatch(selector) {
        if (!selector) {
            return false;
        }
        if (typeof selector === 'function') {
            return selector(this);
        }
        var selectorArr = selector.replace(/ /g, '').split(','), len = selectorArr.length, n, sel;
        for (n = 0; n < len; n++) {
            sel = selectorArr[n];
            if (!Util_1$c.Util.isValidSelector(sel)) {
                Util_1$c.Util.warn('Selector "' +
                    sel +
                    '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".');
                Util_1$c.Util.warn('If you have a custom shape with such className, please change it to start with upper letter like "Triangle".');
                Util_1$c.Util.warn('Konva is awesome, right?');
            }
            if (sel.charAt(0) === '#') {
                if (this.id() === sel.slice(1)) {
                    return true;
                }
            }
            else if (sel.charAt(0) === '.') {
                if (this.hasName(sel.slice(1))) {
                    return true;
                }
            }
            else if (this.className === sel || this.nodeType === sel) {
                return true;
            }
        }
        return false;
    }
    getLayer() {
        var parent = this.getParent();
        return parent ? parent.getLayer() : null;
    }
    getStage() {
        return this._getCache(STAGE, this._getStage);
    }
    _getStage() {
        var parent = this.getParent();
        if (parent) {
            return parent.getStage();
        }
        else {
            return undefined;
        }
    }
    fire(eventType, evt = {}, bubble) {
        evt.target = evt.target || this;
        if (bubble) {
            this._fireAndBubble(eventType, evt);
        }
        else {
            this._fire(eventType, evt);
        }
        return this;
    }
    getAbsoluteTransform(top) {
        if (top) {
            return this._getAbsoluteTransform(top);
        }
        else {
            return this._getCache(ABSOLUTE_TRANSFORM, this._getAbsoluteTransform);
        }
    }
    _getAbsoluteTransform(top) {
        var at;
        if (top) {
            at = new Util_1$c.Transform();
            this._eachAncestorReverse(function (node) {
                var transformsEnabled = node.transformsEnabled();
                if (transformsEnabled === 'all') {
                    at.multiply(node.getTransform());
                }
                else if (transformsEnabled === 'position') {
                    at.translate(node.x() - node.offsetX(), node.y() - node.offsetY());
                }
            }, top);
            return at;
        }
        else {
            at = this._cache.get(ABSOLUTE_TRANSFORM) || new Util_1$c.Transform();
            if (this.parent) {
                this.parent.getAbsoluteTransform().copyInto(at);
            }
            else {
                at.reset();
            }
            var transformsEnabled = this.transformsEnabled();
            if (transformsEnabled === 'all') {
                at.multiply(this.getTransform());
            }
            else if (transformsEnabled === 'position') {
                const x = this.attrs.x || 0;
                const y = this.attrs.y || 0;
                const offsetX = this.attrs.offsetX || 0;
                const offsetY = this.attrs.offsetY || 0;
                at.translate(x - offsetX, y - offsetY);
            }
            at.dirty = false;
            return at;
        }
    }
    getAbsoluteScale(top) {
        var parent = this;
        while (parent) {
            if (parent._isUnderCache) {
                top = parent;
            }
            parent = parent.getParent();
        }
        const transform = this.getAbsoluteTransform(top);
        const attrs = transform.decompose();
        return {
            x: attrs.scaleX,
            y: attrs.scaleY,
        };
    }
    getAbsoluteRotation() {
        return this.getAbsoluteTransform().decompose().rotation;
    }
    getTransform() {
        return this._getCache(TRANSFORM, this._getTransform);
    }
    _getTransform() {
        var _a, _b;
        var m = this._cache.get(TRANSFORM) || new Util_1$c.Transform();
        m.reset();
        var x = this.x(), y = this.y(), rotation = Global_1$m.Konva.getAngle(this.rotation()), scaleX = (_a = this.attrs.scaleX) !== null && _a !== void 0 ? _a : 1, scaleY = (_b = this.attrs.scaleY) !== null && _b !== void 0 ? _b : 1, skewX = this.attrs.skewX || 0, skewY = this.attrs.skewY || 0, offsetX = this.attrs.offsetX || 0, offsetY = this.attrs.offsetY || 0;
        if (x !== 0 || y !== 0) {
            m.translate(x, y);
        }
        if (rotation !== 0) {
            m.rotate(rotation);
        }
        if (skewX !== 0 || skewY !== 0) {
            m.skew(skewX, skewY);
        }
        if (scaleX !== 1 || scaleY !== 1) {
            m.scale(scaleX, scaleY);
        }
        if (offsetX !== 0 || offsetY !== 0) {
            m.translate(-1 * offsetX, -1 * offsetY);
        }
        m.dirty = false;
        return m;
    }
    clone(obj) {
        var attrs = Util_1$c.Util.cloneObject(this.attrs), key, allListeners, len, n, listener;
        for (key in obj) {
            attrs[key] = obj[key];
        }
        var node = new this.constructor(attrs);
        for (key in this.eventListeners) {
            allListeners = this.eventListeners[key];
            len = allListeners.length;
            for (n = 0; n < len; n++) {
                listener = allListeners[n];
                if (listener.name.indexOf(KONVA) < 0) {
                    if (!node.eventListeners[key]) {
                        node.eventListeners[key] = [];
                    }
                    node.eventListeners[key].push(listener);
                }
            }
        }
        return node;
    }
    _toKonvaCanvas(config) {
        config = config || {};
        var box = this.getClientRect();
        var stage = this.getStage(), x = config.x !== undefined ? config.x : Math.floor(box.x), y = config.y !== undefined ? config.y : Math.floor(box.y), pixelRatio = config.pixelRatio || 1, canvas = new Canvas_1$1.SceneCanvas({
            width: config.width || Math.ceil(box.width) || (stage ? stage.width() : 0),
            height: config.height ||
                Math.ceil(box.height) ||
                (stage ? stage.height() : 0),
            pixelRatio: pixelRatio,
        }), context = canvas.getContext();
        if (config.imageSmoothingEnabled === false) {
            context._context.imageSmoothingEnabled = false;
        }
        context.save();
        if (x || y) {
            context.translate(-1 * x, -1 * y);
        }
        this.drawScene(canvas);
        context.restore();
        return canvas;
    }
    toCanvas(config) {
        return this._toKonvaCanvas(config)._canvas;
    }
    toDataURL(config) {
        config = config || {};
        var mimeType = config.mimeType || null, quality = config.quality || null;
        var url = this._toKonvaCanvas(config).toDataURL(mimeType, quality);
        if (config.callback) {
            config.callback(url);
        }
        return url;
    }
    toImage(config) {
        return new Promise((resolve, reject) => {
            try {
                const callback = config === null || config === void 0 ? void 0 : config.callback;
                if (callback)
                    delete config.callback;
                Util_1$c.Util._urlToImage(this.toDataURL(config), function (img) {
                    resolve(img);
                    callback === null || callback === void 0 ? void 0 : callback(img);
                });
            }
            catch (err) {
                reject(err);
            }
        });
    }
    toBlob(config) {
        return new Promise((resolve, reject) => {
            try {
                const callback = config === null || config === void 0 ? void 0 : config.callback;
                if (callback)
                    delete config.callback;
                this.toCanvas(config).toBlob((blob) => {
                    resolve(blob);
                    callback === null || callback === void 0 ? void 0 : callback(blob);
                });
            }
            catch (err) {
                reject(err);
            }
        });
    }
    setSize(size) {
        this.width(size.width);
        this.height(size.height);
        return this;
    }
    getSize() {
        return {
            width: this.width(),
            height: this.height(),
        };
    }
    getClassName() {
        return this.className || this.nodeType;
    }
    getType() {
        return this.nodeType;
    }
    getDragDistance() {
        if (this.attrs.dragDistance !== undefined) {
            return this.attrs.dragDistance;
        }
        else if (this.parent) {
            return this.parent.getDragDistance();
        }
        else {
            return Global_1$m.Konva.dragDistance;
        }
    }
    _off(type, name, callback) {
        var evtListeners = this.eventListeners[type], i, evtName, handler;
        for (i = 0; i < evtListeners.length; i++) {
            evtName = evtListeners[i].name;
            handler = evtListeners[i].handler;
            if ((evtName !== 'konva' || name === 'konva') &&
                (!name || evtName === name) &&
                (!callback || callback === handler)) {
                evtListeners.splice(i, 1);
                if (evtListeners.length === 0) {
                    delete this.eventListeners[type];
                    break;
                }
                i--;
            }
        }
    }
    _fireChangeEvent(attr, oldVal, newVal) {
        this._fire(attr + CHANGE, {
            oldVal: oldVal,
            newVal: newVal,
        });
    }
    addName(name) {
        if (!this.hasName(name)) {
            var oldName = this.name();
            var newName = oldName ? oldName + ' ' + name : name;
            this.name(newName);
        }
        return this;
    }
    hasName(name) {
        if (!name) {
            return false;
        }
        const fullName = this.name();
        if (!fullName) {
            return false;
        }
        var names = (fullName || '').split(/\s/g);
        return names.indexOf(name) !== -1;
    }
    removeName(name) {
        var names = (this.name() || '').split(/\s/g);
        var index = names.indexOf(name);
        if (index !== -1) {
            names.splice(index, 1);
            this.name(names.join(' '));
        }
        return this;
    }
    setAttr(attr, val) {
        var func = this[SET + Util_1$c.Util._capitalize(attr)];
        if (Util_1$c.Util._isFunction(func)) {
            func.call(this, val);
        }
        else {
            this._setAttr(attr, val);
        }
        return this;
    }
    _requestDraw() {
        if (Global_1$m.Konva.autoDrawEnabled) {
            const drawNode = this.getLayer() || this.getStage();
            drawNode === null || drawNode === void 0 ? void 0 : drawNode.batchDraw();
        }
    }
    _setAttr(key, val) {
        var oldVal = this.attrs[key];
        if (oldVal === val && !Util_1$c.Util.isObject(val)) {
            return;
        }
        if (val === undefined || val === null) {
            delete this.attrs[key];
        }
        else {
            this.attrs[key] = val;
        }
        if (this._shouldFireChangeEvents) {
            this._fireChangeEvent(key, oldVal, val);
        }
        this._requestDraw();
    }
    _setComponentAttr(key, component, val) {
        var oldVal;
        if (val !== undefined) {
            oldVal = this.attrs[key];
            if (!oldVal) {
                this.attrs[key] = this.getAttr(key);
            }
            this.attrs[key][component] = val;
            this._fireChangeEvent(key, oldVal, val);
        }
    }
    _fireAndBubble(eventType, evt, compareShape) {
        if (evt && this.nodeType === SHAPE) {
            evt.target = this;
        }
        var shouldStop = (eventType === MOUSEENTER || eventType === MOUSELEAVE) &&
            ((compareShape &&
                (this === compareShape ||
                    (this.isAncestorOf && this.isAncestorOf(compareShape)))) ||
                (this.nodeType === 'Stage' && !compareShape));
        if (!shouldStop) {
            this._fire(eventType, evt);
            var stopBubble = (eventType === MOUSEENTER || eventType === MOUSELEAVE) &&
                compareShape &&
                compareShape.isAncestorOf &&
                compareShape.isAncestorOf(this) &&
                !compareShape.isAncestorOf(this.parent);
            if (((evt && !evt.cancelBubble) || !evt) &&
                this.parent &&
                this.parent.isListening() &&
                !stopBubble) {
                if (compareShape && compareShape.parent) {
                    this._fireAndBubble.call(this.parent, eventType, evt, compareShape);
                }
                else {
                    this._fireAndBubble.call(this.parent, eventType, evt);
                }
            }
        }
    }
    _getProtoListeners(eventType) {
        var _a, _b, _c;
        const allListeners = (_a = this._cache.get(ALL_LISTENERS)) !== null && _a !== void 0 ? _a : {};
        let events = allListeners === null || allListeners === void 0 ? void 0 : allListeners[eventType];
        if (events === undefined) {
            events = [];
            let obj = Object.getPrototypeOf(this);
            while (obj) {
                const hierarchyEvents = (_c = (_b = obj.eventListeners) === null || _b === void 0 ? void 0 : _b[eventType]) !== null && _c !== void 0 ? _c : [];
                events.push(...hierarchyEvents);
                obj = Object.getPrototypeOf(obj);
            }
            allListeners[eventType] = events;
            this._cache.set(ALL_LISTENERS, allListeners);
        }
        return events;
    }
    _fire(eventType, evt) {
        evt = evt || {};
        evt.currentTarget = this;
        evt.type = eventType;
        const topListeners = this._getProtoListeners(eventType);
        if (topListeners) {
            for (var i = 0; i < topListeners.length; i++) {
                topListeners[i].handler.call(this, evt);
            }
        }
        const selfListeners = this.eventListeners[eventType];
        if (selfListeners) {
            for (var i = 0; i < selfListeners.length; i++) {
                selfListeners[i].handler.call(this, evt);
            }
        }
    }
    draw() {
        this.drawScene();
        this.drawHit();
        return this;
    }
    _createDragElement(evt) {
        var pointerId = evt ? evt.pointerId : undefined;
        var stage = this.getStage();
        var ap = this.getAbsolutePosition();
        var pos = stage._getPointerById(pointerId) ||
            stage._changedPointerPositions[0] ||
            ap;
        DragAndDrop_1.DD._dragElements.set(this._id, {
            node: this,
            startPointerPos: pos,
            offset: {
                x: pos.x - ap.x,
                y: pos.y - ap.y,
            },
            dragStatus: 'ready',
            pointerId,
        });
    }
    startDrag(evt, bubbleEvent = true) {
        if (!DragAndDrop_1.DD._dragElements.has(this._id)) {
            this._createDragElement(evt);
        }
        const elem = DragAndDrop_1.DD._dragElements.get(this._id);
        elem.dragStatus = 'dragging';
        this.fire('dragstart', {
            type: 'dragstart',
            target: this,
            evt: evt && evt.evt,
        }, bubbleEvent);
    }
    _setDragPosition(evt, elem) {
        const pos = this.getStage()._getPointerById(elem.pointerId);
        if (!pos) {
            return;
        }
        var newNodePos = {
            x: pos.x - elem.offset.x,
            y: pos.y - elem.offset.y,
        };
        var dbf = this.dragBoundFunc();
        if (dbf !== undefined) {
            const bounded = dbf.call(this, newNodePos, evt);
            if (!bounded) {
                Util_1$c.Util.warn('dragBoundFunc did not return any value. That is unexpected behavior. You must return new absolute position from dragBoundFunc.');
            }
            else {
                newNodePos = bounded;
            }
        }
        if (!this._lastPos ||
            this._lastPos.x !== newNodePos.x ||
            this._lastPos.y !== newNodePos.y) {
            this.setAbsolutePosition(newNodePos);
            this._requestDraw();
        }
        this._lastPos = newNodePos;
    }
    stopDrag(evt) {
        const elem = DragAndDrop_1.DD._dragElements.get(this._id);
        if (elem) {
            elem.dragStatus = 'stopped';
        }
        DragAndDrop_1.DD._endDragBefore(evt);
        DragAndDrop_1.DD._endDragAfter(evt);
    }
    setDraggable(draggable) {
        this._setAttr('draggable', draggable);
        this._dragChange();
    }
    isDragging() {
        const elem = DragAndDrop_1.DD._dragElements.get(this._id);
        return elem ? elem.dragStatus === 'dragging' : false;
    }
    _listenDrag() {
        this._dragCleanup();
        this.on('mousedown.konva touchstart.konva', function (evt) {
            var shouldCheckButton = evt.evt['button'] !== undefined;
            var canDrag = !shouldCheckButton || Global_1$m.Konva.dragButtons.indexOf(evt.evt['button']) >= 0;
            if (!canDrag) {
                return;
            }
            if (this.isDragging()) {
                return;
            }
            var hasDraggingChild = false;
            DragAndDrop_1.DD._dragElements.forEach((elem) => {
                if (this.isAncestorOf(elem.node)) {
                    hasDraggingChild = true;
                }
            });
            if (!hasDraggingChild) {
                this._createDragElement(evt);
            }
        });
    }
    _dragChange() {
        if (this.attrs.draggable) {
            this._listenDrag();
        }
        else {
            this._dragCleanup();
            var stage = this.getStage();
            if (!stage) {
                return;
            }
            const dragElement = DragAndDrop_1.DD._dragElements.get(this._id);
            const isDragging = dragElement && dragElement.dragStatus === 'dragging';
            const isReady = dragElement && dragElement.dragStatus === 'ready';
            if (isDragging) {
                this.stopDrag();
            }
            else if (isReady) {
                DragAndDrop_1.DD._dragElements.delete(this._id);
            }
        }
    }
    _dragCleanup() {
        this.off('mousedown.konva');
        this.off('touchstart.konva');
    }
    isClientRectOnScreen(margin = { x: 0, y: 0 }) {
        const stage = this.getStage();
        if (!stage) {
            return false;
        }
        const screenRect = {
            x: -margin.x,
            y: -margin.y,
            width: stage.width() + 2 * margin.x,
            height: stage.height() + 2 * margin.y,
        };
        return Util_1$c.Util.haveIntersection(screenRect, this.getClientRect());
    }
    static create(data, container) {
        if (Util_1$c.Util._isString(data)) {
            data = JSON.parse(data);
        }
        return this._createNode(data, container);
    }
    static _createNode(obj, container) {
        var className = Node.prototype.getClassName.call(obj), children = obj.children, no, len, n;
        if (container) {
            obj.attrs.container = container;
        }
        if (!Global_1$m.Konva[className]) {
            Util_1$c.Util.warn('Can not find a node with class name "' +
                className +
                '". Fallback to "Shape".');
            className = 'Shape';
        }
        const Class = Global_1$m.Konva[className];
        no = new Class(obj.attrs);
        if (children) {
            len = children.length;
            for (n = 0; n < len; n++) {
                no.add(Node._createNode(children[n]));
            }
        }
        return no;
    }
};
Node$2.Node = Node$1;
Node$1.prototype.nodeType = 'Node';
Node$1.prototype._attrsAffectingSize = [];
Node$1.prototype.eventListeners = {};
Node$1.prototype.on.call(Node$1.prototype, TRANSFORM_CHANGE_STR$1, function () {
    if (this._batchingTransformChange) {
        this._needClearTransformCache = true;
        return;
    }
    this._clearCache(TRANSFORM);
    this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
});
Node$1.prototype.on.call(Node$1.prototype, 'visibleChange.konva', function () {
    this._clearSelfAndDescendantCache(VISIBLE);
});
Node$1.prototype.on.call(Node$1.prototype, 'listeningChange.konva', function () {
    this._clearSelfAndDescendantCache(LISTENING);
});
Node$1.prototype.on.call(Node$1.prototype, 'opacityChange.konva', function () {
    this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
});
const addGetterSetter = Factory_1$y.Factory.addGetterSetter;
addGetterSetter(Node$1, 'zIndex');
addGetterSetter(Node$1, 'absolutePosition');
addGetterSetter(Node$1, 'position');
addGetterSetter(Node$1, 'x', 0, (0, Validators_1$x.getNumberValidator)());
addGetterSetter(Node$1, 'y', 0, (0, Validators_1$x.getNumberValidator)());
addGetterSetter(Node$1, 'globalCompositeOperation', 'source-over', (0, Validators_1$x.getStringValidator)());
addGetterSetter(Node$1, 'opacity', 1, (0, Validators_1$x.getNumberValidator)());
addGetterSetter(Node$1, 'name', '', (0, Validators_1$x.getStringValidator)());
addGetterSetter(Node$1, 'id', '', (0, Validators_1$x.getStringValidator)());
addGetterSetter(Node$1, 'rotation', 0, (0, Validators_1$x.getNumberValidator)());
Factory_1$y.Factory.addComponentsGetterSetter(Node$1, 'scale', ['x', 'y']);
addGetterSetter(Node$1, 'scaleX', 1, (0, Validators_1$x.getNumberValidator)());
addGetterSetter(Node$1, 'scaleY', 1, (0, Validators_1$x.getNumberValidator)());
Factory_1$y.Factory.addComponentsGetterSetter(Node$1, 'skew', ['x', 'y']);
addGetterSetter(Node$1, 'skewX', 0, (0, Validators_1$x.getNumberValidator)());
addGetterSetter(Node$1, 'skewY', 0, (0, Validators_1$x.getNumberValidator)());
Factory_1$y.Factory.addComponentsGetterSetter(Node$1, 'offset', ['x', 'y']);
addGetterSetter(Node$1, 'offsetX', 0, (0, Validators_1$x.getNumberValidator)());
addGetterSetter(Node$1, 'offsetY', 0, (0, Validators_1$x.getNumberValidator)());
addGetterSetter(Node$1, 'dragDistance', null, (0, Validators_1$x.getNumberValidator)());
addGetterSetter(Node$1, 'width', 0, (0, Validators_1$x.getNumberValidator)());
addGetterSetter(Node$1, 'height', 0, (0, Validators_1$x.getNumberValidator)());
addGetterSetter(Node$1, 'listening', true, (0, Validators_1$x.getBooleanValidator)());
addGetterSetter(Node$1, 'preventDefault', true, (0, Validators_1$x.getBooleanValidator)());
addGetterSetter(Node$1, 'filters', null, function (val) {
    this._filterUpToDate = false;
    return val;
});
addGetterSetter(Node$1, 'visible', true, (0, Validators_1$x.getBooleanValidator)());
addGetterSetter(Node$1, 'transformsEnabled', 'all', (0, Validators_1$x.getStringValidator)());
addGetterSetter(Node$1, 'size');
addGetterSetter(Node$1, 'dragBoundFunc');
addGetterSetter(Node$1, 'draggable', false, (0, Validators_1$x.getBooleanValidator)());
Factory_1$y.Factory.backCompat(Node$1, {
    rotateDeg: 'rotate',
    setRotationDeg: 'setRotation',
    getRotationDeg: 'getRotation',
});

var Container$1 = {};

Object.defineProperty(Container$1, "__esModule", { value: true });
Container$1.Container = void 0;
const Factory_1$x = Factory;
const Node_1$h = Node$2;
const Validators_1$w = Validators;
class Container extends Node_1$h.Node {
    constructor() {
        super(...arguments);
        this.children = [];
    }
    getChildren(filterFunc) {
        if (!filterFunc) {
            return this.children || [];
        }
        const children = this.children || [];
        var results = [];
        children.forEach(function (child) {
            if (filterFunc(child)) {
                results.push(child);
            }
        });
        return results;
    }
    hasChildren() {
        return this.getChildren().length > 0;
    }
    removeChildren() {
        this.getChildren().forEach((child) => {
            child.parent = null;
            child.index = 0;
            child.remove();
        });
        this.children = [];
        this._requestDraw();
        return this;
    }
    destroyChildren() {
        this.getChildren().forEach((child) => {
            child.parent = null;
            child.index = 0;
            child.destroy();
        });
        this.children = [];
        this._requestDraw();
        return this;
    }
    add(...children) {
        if (children.length === 0) {
            return this;
        }
        if (children.length > 1) {
            for (var i = 0; i < children.length; i++) {
                this.add(children[i]);
            }
            return this;
        }
        const child = children[0];
        if (child.getParent()) {
            child.moveTo(this);
            return this;
        }
        this._validateAdd(child);
        child.index = this.getChildren().length;
        child.parent = this;
        child._clearCaches();
        this.getChildren().push(child);
        this._fire('add', {
            child: child,
        });
        this._requestDraw();
        return this;
    }
    destroy() {
        if (this.hasChildren()) {
            this.destroyChildren();
        }
        super.destroy();
        return this;
    }
    find(selector) {
        return this._generalFind(selector, false);
    }
    findOne(selector) {
        var result = this._generalFind(selector, true);
        return result.length > 0 ? result[0] : undefined;
    }
    _generalFind(selector, findOne) {
        var retArr = [];
        this._descendants((node) => {
            const valid = node._isMatch(selector);
            if (valid) {
                retArr.push(node);
            }
            if (valid && findOne) {
                return true;
            }
            return false;
        });
        return retArr;
    }
    _descendants(fn) {
        let shouldStop = false;
        const children = this.getChildren();
        for (const child of children) {
            shouldStop = fn(child);
            if (shouldStop) {
                return true;
            }
            if (!child.hasChildren()) {
                continue;
            }
            shouldStop = child._descendants(fn);
            if (shouldStop) {
                return true;
            }
        }
        return false;
    }
    toObject() {
        var obj = Node_1$h.Node.prototype.toObject.call(this);
        obj.children = [];
        this.getChildren().forEach((child) => {
            obj.children.push(child.toObject());
        });
        return obj;
    }
    isAncestorOf(node) {
        var parent = node.getParent();
        while (parent) {
            if (parent._id === this._id) {
                return true;
            }
            parent = parent.getParent();
        }
        return false;
    }
    clone(obj) {
        var node = Node_1$h.Node.prototype.clone.call(this, obj);
        this.getChildren().forEach(function (no) {
            node.add(no.clone());
        });
        return node;
    }
    getAllIntersections(pos) {
        var arr = [];
        this.find('Shape').forEach(function (shape) {
            if (shape.isVisible() && shape.intersects(pos)) {
                arr.push(shape);
            }
        });
        return arr;
    }
    _clearSelfAndDescendantCache(attr) {
        var _a;
        super._clearSelfAndDescendantCache(attr);
        if (this.isCached()) {
            return;
        }
        (_a = this.children) === null || _a === void 0 ? void 0 : _a.forEach(function (node) {
            node._clearSelfAndDescendantCache(attr);
        });
    }
    _setChildrenIndices() {
        var _a;
        (_a = this.children) === null || _a === void 0 ? void 0 : _a.forEach(function (child, n) {
            child.index = n;
        });
        this._requestDraw();
    }
    drawScene(can, top) {
        var layer = this.getLayer(), canvas = can || (layer && layer.getCanvas()), context = canvas && canvas.getContext(), cachedCanvas = this._getCanvasCache(), cachedSceneCanvas = cachedCanvas && cachedCanvas.scene;
        var caching = canvas && canvas.isCache;
        if (!this.isVisible() && !caching) {
            return this;
        }
        if (cachedSceneCanvas) {
            context.save();
            var m = this.getAbsoluteTransform(top).getMatrix();
            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
            this._drawCachedSceneCanvas(context);
            context.restore();
        }
        else {
            this._drawChildren('drawScene', canvas, top);
        }
        return this;
    }
    drawHit(can, top) {
        if (!this.shouldDrawHit(top)) {
            return this;
        }
        var layer = this.getLayer(), canvas = can || (layer && layer.hitCanvas), context = canvas && canvas.getContext(), cachedCanvas = this._getCanvasCache(), cachedHitCanvas = cachedCanvas && cachedCanvas.hit;
        if (cachedHitCanvas) {
            context.save();
            var m = this.getAbsoluteTransform(top).getMatrix();
            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
            this._drawCachedHitCanvas(context);
            context.restore();
        }
        else {
            this._drawChildren('drawHit', canvas, top);
        }
        return this;
    }
    _drawChildren(drawMethod, canvas, top) {
        var _a;
        var context = canvas && canvas.getContext(), clipWidth = this.clipWidth(), clipHeight = this.clipHeight(), clipFunc = this.clipFunc(), hasClip = (clipWidth && clipHeight) || clipFunc;
        const selfCache = top === this;
        if (hasClip) {
            context.save();
            var transform = this.getAbsoluteTransform(top);
            var m = transform.getMatrix();
            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
            context.beginPath();
            let clipArgs;
            if (clipFunc) {
                clipArgs = clipFunc.call(this, context, this);
            }
            else {
                var clipX = this.clipX();
                var clipY = this.clipY();
                context.rect(clipX, clipY, clipWidth, clipHeight);
            }
            context.clip.apply(context, clipArgs);
            m = transform.copy().invert().getMatrix();
            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
        }
        var hasComposition = !selfCache &&
            this.globalCompositeOperation() !== 'source-over' &&
            drawMethod === 'drawScene';
        if (hasComposition) {
            context.save();
            context._applyGlobalCompositeOperation(this);
        }
        (_a = this.children) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {
            child[drawMethod](canvas, top);
        });
        if (hasComposition) {
            context.restore();
        }
        if (hasClip) {
            context.restore();
        }
    }
    getClientRect(config) {
        var _a;
        config = config || {};
        var skipTransform = config.skipTransform;
        var relativeTo = config.relativeTo;
        var minX, minY, maxX, maxY;
        var selfRect = {
            x: Infinity,
            y: Infinity,
            width: 0,
            height: 0,
        };
        var that = this;
        (_a = this.children) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {
            if (!child.visible()) {
                return;
            }
            var rect = child.getClientRect({
                relativeTo: that,
                skipShadow: config.skipShadow,
                skipStroke: config.skipStroke,
            });
            if (rect.width === 0 && rect.height === 0) {
                return;
            }
            if (minX === undefined) {
                minX = rect.x;
                minY = rect.y;
                maxX = rect.x + rect.width;
                maxY = rect.y + rect.height;
            }
            else {
                minX = Math.min(minX, rect.x);
                minY = Math.min(minY, rect.y);
                maxX = Math.max(maxX, rect.x + rect.width);
                maxY = Math.max(maxY, rect.y + rect.height);
            }
        });
        var shapes = this.find('Shape');
        var hasVisible = false;
        for (var i = 0; i < shapes.length; i++) {
            var shape = shapes[i];
            if (shape._isVisible(this)) {
                hasVisible = true;
                break;
            }
        }
        if (hasVisible && minX !== undefined) {
            selfRect = {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY,
            };
        }
        else {
            selfRect = {
                x: 0,
                y: 0,
                width: 0,
                height: 0,
            };
        }
        if (!skipTransform) {
            return this._transformedRect(selfRect, relativeTo);
        }
        return selfRect;
    }
}
Container$1.Container = Container;
Factory_1$x.Factory.addComponentsGetterSetter(Container, 'clip', [
    'x',
    'y',
    'width',
    'height',
]);
Factory_1$x.Factory.addGetterSetter(Container, 'clipX', undefined, (0, Validators_1$w.getNumberValidator)());
Factory_1$x.Factory.addGetterSetter(Container, 'clipY', undefined, (0, Validators_1$w.getNumberValidator)());
Factory_1$x.Factory.addGetterSetter(Container, 'clipWidth', undefined, (0, Validators_1$w.getNumberValidator)());
Factory_1$x.Factory.addGetterSetter(Container, 'clipHeight', undefined, (0, Validators_1$w.getNumberValidator)());
Factory_1$x.Factory.addGetterSetter(Container, 'clipFunc');

var Stage = {};

var PointerEvents = {};

Object.defineProperty(PointerEvents, "__esModule", { value: true });
PointerEvents.releaseCapture = PointerEvents.setPointerCapture = PointerEvents.hasPointerCapture = PointerEvents.createEvent = PointerEvents.getCapturedShape = void 0;
const Global_1$l = Global;
const Captures = new Map();
const SUPPORT_POINTER_EVENTS = Global_1$l.Konva._global['PointerEvent'] !== undefined;
function getCapturedShape(pointerId) {
    return Captures.get(pointerId);
}
PointerEvents.getCapturedShape = getCapturedShape;
function createEvent(evt) {
    return {
        evt,
        pointerId: evt.pointerId,
    };
}
PointerEvents.createEvent = createEvent;
function hasPointerCapture(pointerId, shape) {
    return Captures.get(pointerId) === shape;
}
PointerEvents.hasPointerCapture = hasPointerCapture;
function setPointerCapture(pointerId, shape) {
    releaseCapture(pointerId);
    const stage = shape.getStage();
    if (!stage)
        return;
    Captures.set(pointerId, shape);
    if (SUPPORT_POINTER_EVENTS) {
        shape._fire('gotpointercapture', createEvent(new PointerEvent('gotpointercapture')));
    }
}
PointerEvents.setPointerCapture = setPointerCapture;
function releaseCapture(pointerId, target) {
    const shape = Captures.get(pointerId);
    if (!shape)
        return;
    const stage = shape.getStage();
    if (stage && stage.content) ;
    Captures.delete(pointerId);
    if (SUPPORT_POINTER_EVENTS) {
        shape._fire('lostpointercapture', createEvent(new PointerEvent('lostpointercapture')));
    }
}
PointerEvents.releaseCapture = releaseCapture;

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Stage = exports.stages = void 0;
	const Util_1 = Util;
	const Factory_1 = Factory;
	const Container_1 = Container$1;
	const Global_1 = Global;
	const Canvas_1 = Canvas$2;
	const DragAndDrop_1 = DragAndDrop;
	const Global_2 = Global;
	const PointerEvents$1 = PointerEvents;
	var STAGE = 'Stage', STRING = 'string', PX = 'px', MOUSEOUT = 'mouseout', MOUSELEAVE = 'mouseleave', MOUSEOVER = 'mouseover', MOUSEENTER = 'mouseenter', MOUSEMOVE = 'mousemove', MOUSEDOWN = 'mousedown', MOUSEUP = 'mouseup', POINTERMOVE = 'pointermove', POINTERDOWN = 'pointerdown', POINTERUP = 'pointerup', POINTERCANCEL = 'pointercancel', LOSTPOINTERCAPTURE = 'lostpointercapture', POINTEROUT = 'pointerout', POINTERLEAVE = 'pointerleave', POINTEROVER = 'pointerover', POINTERENTER = 'pointerenter', CONTEXTMENU = 'contextmenu', TOUCHSTART = 'touchstart', TOUCHEND = 'touchend', TOUCHMOVE = 'touchmove', TOUCHCANCEL = 'touchcancel', WHEEL = 'wheel', MAX_LAYERS_NUMBER = 5, EVENTS = [
	    [MOUSEENTER, '_pointerenter'],
	    [MOUSEDOWN, '_pointerdown'],
	    [MOUSEMOVE, '_pointermove'],
	    [MOUSEUP, '_pointerup'],
	    [MOUSELEAVE, '_pointerleave'],
	    [TOUCHSTART, '_pointerdown'],
	    [TOUCHMOVE, '_pointermove'],
	    [TOUCHEND, '_pointerup'],
	    [TOUCHCANCEL, '_pointercancel'],
	    [MOUSEOVER, '_pointerover'],
	    [WHEEL, '_wheel'],
	    [CONTEXTMENU, '_contextmenu'],
	    [POINTERDOWN, '_pointerdown'],
	    [POINTERMOVE, '_pointermove'],
	    [POINTERUP, '_pointerup'],
	    [POINTERCANCEL, '_pointercancel'],
	    [LOSTPOINTERCAPTURE, '_lostpointercapture'],
	];
	const EVENTS_MAP = {
	    mouse: {
	        [POINTEROUT]: MOUSEOUT,
	        [POINTERLEAVE]: MOUSELEAVE,
	        [POINTEROVER]: MOUSEOVER,
	        [POINTERENTER]: MOUSEENTER,
	        [POINTERMOVE]: MOUSEMOVE,
	        [POINTERDOWN]: MOUSEDOWN,
	        [POINTERUP]: MOUSEUP,
	        [POINTERCANCEL]: 'mousecancel',
	        pointerclick: 'click',
	        pointerdblclick: 'dblclick',
	    },
	    touch: {
	        [POINTEROUT]: 'touchout',
	        [POINTERLEAVE]: 'touchleave',
	        [POINTEROVER]: 'touchover',
	        [POINTERENTER]: 'touchenter',
	        [POINTERMOVE]: TOUCHMOVE,
	        [POINTERDOWN]: TOUCHSTART,
	        [POINTERUP]: TOUCHEND,
	        [POINTERCANCEL]: TOUCHCANCEL,
	        pointerclick: 'tap',
	        pointerdblclick: 'dbltap',
	    },
	    pointer: {
	        [POINTEROUT]: POINTEROUT,
	        [POINTERLEAVE]: POINTERLEAVE,
	        [POINTEROVER]: POINTEROVER,
	        [POINTERENTER]: POINTERENTER,
	        [POINTERMOVE]: POINTERMOVE,
	        [POINTERDOWN]: POINTERDOWN,
	        [POINTERUP]: POINTERUP,
	        [POINTERCANCEL]: POINTERCANCEL,
	        pointerclick: 'pointerclick',
	        pointerdblclick: 'pointerdblclick',
	    },
	};
	const getEventType = (type) => {
	    if (type.indexOf('pointer') >= 0) {
	        return 'pointer';
	    }
	    if (type.indexOf('touch') >= 0) {
	        return 'touch';
	    }
	    return 'mouse';
	};
	const getEventsMap = (eventType) => {
	    const type = getEventType(eventType);
	    if (type === 'pointer') {
	        return Global_1.Konva.pointerEventsEnabled && EVENTS_MAP.pointer;
	    }
	    if (type === 'touch') {
	        return EVENTS_MAP.touch;
	    }
	    if (type === 'mouse') {
	        return EVENTS_MAP.mouse;
	    }
	};
	function checkNoClip(attrs = {}) {
	    if (attrs.clipFunc || attrs.clipWidth || attrs.clipHeight) {
	        Util_1.Util.warn('Stage does not support clipping. Please use clip for Layers or Groups.');
	    }
	    return attrs;
	}
	const NO_POINTERS_MESSAGE = `Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);`;
	exports.stages = [];
	class Stage extends Container_1.Container {
	    constructor(config) {
	        super(checkNoClip(config));
	        this._pointerPositions = [];
	        this._changedPointerPositions = [];
	        this._buildDOM();
	        this._bindContentEvents();
	        exports.stages.push(this);
	        this.on('widthChange.konva heightChange.konva', this._resizeDOM);
	        this.on('visibleChange.konva', this._checkVisibility);
	        this.on('clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva', () => {
	            checkNoClip(this.attrs);
	        });
	        this._checkVisibility();
	    }
	    _validateAdd(child) {
	        const isLayer = child.getType() === 'Layer';
	        const isFastLayer = child.getType() === 'FastLayer';
	        const valid = isLayer || isFastLayer;
	        if (!valid) {
	            Util_1.Util.throw('You may only add layers to the stage.');
	        }
	    }
	    _checkVisibility() {
	        if (!this.content) {
	            return;
	        }
	        const style = this.visible() ? '' : 'none';
	        this.content.style.display = style;
	    }
	    setContainer(container) {
	        if (typeof container === STRING) {
	            if (container.charAt(0) === '.') {
	                var className = container.slice(1);
	                container = document.getElementsByClassName(className)[0];
	            }
	            else {
	                var id;
	                if (container.charAt(0) !== '#') {
	                    id = container;
	                }
	                else {
	                    id = container.slice(1);
	                }
	                container = document.getElementById(id);
	            }
	            if (!container) {
	                throw 'Can not find container in document with id ' + id;
	            }
	        }
	        this._setAttr('container', container);
	        if (this.content) {
	            if (this.content.parentElement) {
	                this.content.parentElement.removeChild(this.content);
	            }
	            container.appendChild(this.content);
	        }
	        return this;
	    }
	    shouldDrawHit() {
	        return true;
	    }
	    clear() {
	        var layers = this.children, len = layers.length, n;
	        for (n = 0; n < len; n++) {
	            layers[n].clear();
	        }
	        return this;
	    }
	    clone(obj) {
	        if (!obj) {
	            obj = {};
	        }
	        obj.container =
	            typeof document !== 'undefined' && document.createElement('div');
	        return Container_1.Container.prototype.clone.call(this, obj);
	    }
	    destroy() {
	        super.destroy();
	        var content = this.content;
	        if (content && Util_1.Util._isInDocument(content)) {
	            this.container().removeChild(content);
	        }
	        var index = exports.stages.indexOf(this);
	        if (index > -1) {
	            exports.stages.splice(index, 1);
	        }
	        Util_1.Util.releaseCanvas(this.bufferCanvas._canvas, this.bufferHitCanvas._canvas);
	        return this;
	    }
	    getPointerPosition() {
	        const pos = this._pointerPositions[0] || this._changedPointerPositions[0];
	        if (!pos) {
	            Util_1.Util.warn(NO_POINTERS_MESSAGE);
	            return null;
	        }
	        return {
	            x: pos.x,
	            y: pos.y,
	        };
	    }
	    _getPointerById(id) {
	        return this._pointerPositions.find((p) => p.id === id);
	    }
	    getPointersPositions() {
	        return this._pointerPositions;
	    }
	    getStage() {
	        return this;
	    }
	    getContent() {
	        return this.content;
	    }
	    _toKonvaCanvas(config) {
	        config = config || {};
	        config.x = config.x || 0;
	        config.y = config.y || 0;
	        config.width = config.width || this.width();
	        config.height = config.height || this.height();
	        var canvas = new Canvas_1.SceneCanvas({
	            width: config.width,
	            height: config.height,
	            pixelRatio: config.pixelRatio || 1,
	        });
	        var _context = canvas.getContext()._context;
	        var layers = this.children;
	        if (config.x || config.y) {
	            _context.translate(-1 * config.x, -1 * config.y);
	        }
	        layers.forEach(function (layer) {
	            if (!layer.isVisible()) {
	                return;
	            }
	            var layerCanvas = layer._toKonvaCanvas(config);
	            _context.drawImage(layerCanvas._canvas, config.x, config.y, layerCanvas.getWidth() / layerCanvas.getPixelRatio(), layerCanvas.getHeight() / layerCanvas.getPixelRatio());
	        });
	        return canvas;
	    }
	    getIntersection(pos) {
	        if (!pos) {
	            return null;
	        }
	        var layers = this.children, len = layers.length, end = len - 1, n;
	        for (n = end; n >= 0; n--) {
	            const shape = layers[n].getIntersection(pos);
	            if (shape) {
	                return shape;
	            }
	        }
	        return null;
	    }
	    _resizeDOM() {
	        var width = this.width();
	        var height = this.height();
	        if (this.content) {
	            this.content.style.width = width + PX;
	            this.content.style.height = height + PX;
	        }
	        this.bufferCanvas.setSize(width, height);
	        this.bufferHitCanvas.setSize(width, height);
	        this.children.forEach((layer) => {
	            layer.setSize({ width, height });
	            layer.draw();
	        });
	    }
	    add(layer, ...rest) {
	        if (arguments.length > 1) {
	            for (var i = 0; i < arguments.length; i++) {
	                this.add(arguments[i]);
	            }
	            return this;
	        }
	        super.add(layer);
	        var length = this.children.length;
	        if (length > MAX_LAYERS_NUMBER) {
	            Util_1.Util.warn('The stage has ' +
	                length +
	                ' layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group.');
	        }
	        layer.setSize({ width: this.width(), height: this.height() });
	        layer.draw();
	        if (Global_1.Konva.isBrowser) {
	            this.content.appendChild(layer.canvas._canvas);
	        }
	        return this;
	    }
	    getParent() {
	        return null;
	    }
	    getLayer() {
	        return null;
	    }
	    hasPointerCapture(pointerId) {
	        return PointerEvents$1.hasPointerCapture(pointerId, this);
	    }
	    setPointerCapture(pointerId) {
	        PointerEvents$1.setPointerCapture(pointerId, this);
	    }
	    releaseCapture(pointerId) {
	        PointerEvents$1.releaseCapture(pointerId, this);
	    }
	    getLayers() {
	        return this.children;
	    }
	    _bindContentEvents() {
	        if (!Global_1.Konva.isBrowser) {
	            return;
	        }
	        EVENTS.forEach(([event, methodName]) => {
	            this.content.addEventListener(event, (evt) => {
	                this[methodName](evt);
	            }, { passive: false });
	        });
	    }
	    _pointerenter(evt) {
	        this.setPointersPositions(evt);
	        const events = getEventsMap(evt.type);
	        this._fire(events.pointerenter, {
	            evt: evt,
	            target: this,
	            currentTarget: this,
	        });
	    }
	    _pointerover(evt) {
	        this.setPointersPositions(evt);
	        const events = getEventsMap(evt.type);
	        this._fire(events.pointerover, {
	            evt: evt,
	            target: this,
	            currentTarget: this,
	        });
	    }
	    _getTargetShape(evenType) {
	        let shape = this[evenType + 'targetShape'];
	        if (shape && !shape.getStage()) {
	            shape = null;
	        }
	        return shape;
	    }
	    _pointerleave(evt) {
	        const events = getEventsMap(evt.type);
	        const eventType = getEventType(evt.type);
	        if (!events) {
	            return;
	        }
	        this.setPointersPositions(evt);
	        var targetShape = this._getTargetShape(eventType);
	        var eventsEnabled = !DragAndDrop_1.DD.isDragging || Global_1.Konva.hitOnDragEnabled;
	        if (targetShape && eventsEnabled) {
	            targetShape._fireAndBubble(events.pointerout, { evt: evt });
	            targetShape._fireAndBubble(events.pointerleave, { evt: evt });
	            this._fire(events.pointerleave, {
	                evt: evt,
	                target: this,
	                currentTarget: this,
	            });
	            this[eventType + 'targetShape'] = null;
	        }
	        else if (eventsEnabled) {
	            this._fire(events.pointerleave, {
	                evt: evt,
	                target: this,
	                currentTarget: this,
	            });
	            this._fire(events.pointerout, {
	                evt: evt,
	                target: this,
	                currentTarget: this,
	            });
	        }
	        this.pointerPos = undefined;
	        this._pointerPositions = [];
	    }
	    _pointerdown(evt) {
	        const events = getEventsMap(evt.type);
	        const eventType = getEventType(evt.type);
	        if (!events) {
	            return;
	        }
	        this.setPointersPositions(evt);
	        var triggeredOnShape = false;
	        this._changedPointerPositions.forEach((pos) => {
	            var shape = this.getIntersection(pos);
	            DragAndDrop_1.DD.justDragged = false;
	            Global_1.Konva['_' + eventType + 'ListenClick'] = true;
	            const hasShape = shape && shape.isListening();
	            if (!hasShape) {
	                return;
	            }
	            if (Global_1.Konva.capturePointerEventsEnabled) {
	                shape.setPointerCapture(pos.id);
	            }
	            this[eventType + 'ClickStartShape'] = shape;
	            shape._fireAndBubble(events.pointerdown, {
	                evt: evt,
	                pointerId: pos.id,
	            });
	            triggeredOnShape = true;
	            const isTouch = evt.type.indexOf('touch') >= 0;
	            if (shape.preventDefault() && evt.cancelable && isTouch) {
	                evt.preventDefault();
	            }
	        });
	        if (!triggeredOnShape) {
	            this._fire(events.pointerdown, {
	                evt: evt,
	                target: this,
	                currentTarget: this,
	                pointerId: this._pointerPositions[0].id,
	            });
	        }
	    }
	    _pointermove(evt) {
	        const events = getEventsMap(evt.type);
	        const eventType = getEventType(evt.type);
	        if (!events) {
	            return;
	        }
	        if (DragAndDrop_1.DD.isDragging && DragAndDrop_1.DD.node.preventDefault() && evt.cancelable) {
	            evt.preventDefault();
	        }
	        this.setPointersPositions(evt);
	        var eventsEnabled = !DragAndDrop_1.DD.isDragging || Global_1.Konva.hitOnDragEnabled;
	        if (!eventsEnabled) {
	            return;
	        }
	        var processedShapesIds = {};
	        let triggeredOnShape = false;
	        var targetShape = this._getTargetShape(eventType);
	        this._changedPointerPositions.forEach((pos) => {
	            const shape = (PointerEvents$1.getCapturedShape(pos.id) ||
	                this.getIntersection(pos));
	            const pointerId = pos.id;
	            const event = { evt: evt, pointerId };
	            var differentTarget = targetShape !== shape;
	            if (differentTarget && targetShape) {
	                targetShape._fireAndBubble(events.pointerout, Object.assign({}, event), shape);
	                targetShape._fireAndBubble(events.pointerleave, Object.assign({}, event), shape);
	            }
	            if (shape) {
	                if (processedShapesIds[shape._id]) {
	                    return;
	                }
	                processedShapesIds[shape._id] = true;
	            }
	            if (shape && shape.isListening()) {
	                triggeredOnShape = true;
	                if (differentTarget) {
	                    shape._fireAndBubble(events.pointerover, Object.assign({}, event), targetShape);
	                    shape._fireAndBubble(events.pointerenter, Object.assign({}, event), targetShape);
	                    this[eventType + 'targetShape'] = shape;
	                }
	                shape._fireAndBubble(events.pointermove, Object.assign({}, event));
	            }
	            else {
	                if (targetShape) {
	                    this._fire(events.pointerover, {
	                        evt: evt,
	                        target: this,
	                        currentTarget: this,
	                        pointerId,
	                    });
	                    this[eventType + 'targetShape'] = null;
	                }
	            }
	        });
	        if (!triggeredOnShape) {
	            this._fire(events.pointermove, {
	                evt: evt,
	                target: this,
	                currentTarget: this,
	                pointerId: this._changedPointerPositions[0].id,
	            });
	        }
	    }
	    _pointerup(evt) {
	        const events = getEventsMap(evt.type);
	        const eventType = getEventType(evt.type);
	        if (!events) {
	            return;
	        }
	        this.setPointersPositions(evt);
	        const clickStartShape = this[eventType + 'ClickStartShape'];
	        const clickEndShape = this[eventType + 'ClickEndShape'];
	        var processedShapesIds = {};
	        let triggeredOnShape = false;
	        this._changedPointerPositions.forEach((pos) => {
	            const shape = (PointerEvents$1.getCapturedShape(pos.id) ||
	                this.getIntersection(pos));
	            if (shape) {
	                shape.releaseCapture(pos.id);
	                if (processedShapesIds[shape._id]) {
	                    return;
	                }
	                processedShapesIds[shape._id] = true;
	            }
	            const pointerId = pos.id;
	            const event = { evt: evt, pointerId };
	            let fireDblClick = false;
	            if (Global_1.Konva['_' + eventType + 'InDblClickWindow']) {
	                fireDblClick = true;
	                clearTimeout(this[eventType + 'DblTimeout']);
	            }
	            else if (!DragAndDrop_1.DD.justDragged) {
	                Global_1.Konva['_' + eventType + 'InDblClickWindow'] = true;
	                clearTimeout(this[eventType + 'DblTimeout']);
	            }
	            this[eventType + 'DblTimeout'] = setTimeout(function () {
	                Global_1.Konva['_' + eventType + 'InDblClickWindow'] = false;
	            }, Global_1.Konva.dblClickWindow);
	            if (shape && shape.isListening()) {
	                triggeredOnShape = true;
	                this[eventType + 'ClickEndShape'] = shape;
	                shape._fireAndBubble(events.pointerup, Object.assign({}, event));
	                if (Global_1.Konva['_' + eventType + 'ListenClick'] &&
	                    clickStartShape &&
	                    clickStartShape === shape) {
	                    shape._fireAndBubble(events.pointerclick, Object.assign({}, event));
	                    if (fireDblClick && clickEndShape && clickEndShape === shape) {
	                        shape._fireAndBubble(events.pointerdblclick, Object.assign({}, event));
	                    }
	                }
	            }
	            else {
	                this[eventType + 'ClickEndShape'] = null;
	                if (Global_1.Konva['_' + eventType + 'ListenClick']) {
	                    this._fire(events.pointerclick, {
	                        evt: evt,
	                        target: this,
	                        currentTarget: this,
	                        pointerId,
	                    });
	                }
	                if (fireDblClick) {
	                    this._fire(events.pointerdblclick, {
	                        evt: evt,
	                        target: this,
	                        currentTarget: this,
	                        pointerId,
	                    });
	                }
	            }
	        });
	        if (!triggeredOnShape) {
	            this._fire(events.pointerup, {
	                evt: evt,
	                target: this,
	                currentTarget: this,
	                pointerId: this._changedPointerPositions[0].id,
	            });
	        }
	        Global_1.Konva['_' + eventType + 'ListenClick'] = false;
	        if (evt.cancelable && eventType !== 'touch') {
	            evt.preventDefault();
	        }
	    }
	    _contextmenu(evt) {
	        this.setPointersPositions(evt);
	        var shape = this.getIntersection(this.getPointerPosition());
	        if (shape && shape.isListening()) {
	            shape._fireAndBubble(CONTEXTMENU, { evt: evt });
	        }
	        else {
	            this._fire(CONTEXTMENU, {
	                evt: evt,
	                target: this,
	                currentTarget: this,
	            });
	        }
	    }
	    _wheel(evt) {
	        this.setPointersPositions(evt);
	        var shape = this.getIntersection(this.getPointerPosition());
	        if (shape && shape.isListening()) {
	            shape._fireAndBubble(WHEEL, { evt: evt });
	        }
	        else {
	            this._fire(WHEEL, {
	                evt: evt,
	                target: this,
	                currentTarget: this,
	            });
	        }
	    }
	    _pointercancel(evt) {
	        this.setPointersPositions(evt);
	        const shape = PointerEvents$1.getCapturedShape(evt.pointerId) ||
	            this.getIntersection(this.getPointerPosition());
	        if (shape) {
	            shape._fireAndBubble(POINTERUP, PointerEvents$1.createEvent(evt));
	        }
	        PointerEvents$1.releaseCapture(evt.pointerId);
	    }
	    _lostpointercapture(evt) {
	        PointerEvents$1.releaseCapture(evt.pointerId);
	    }
	    setPointersPositions(evt) {
	        var contentPosition = this._getContentPosition(), x = null, y = null;
	        evt = evt ? evt : window.event;
	        if (evt.touches !== undefined) {
	            this._pointerPositions = [];
	            this._changedPointerPositions = [];
	            Array.prototype.forEach.call(evt.touches, (touch) => {
	                this._pointerPositions.push({
	                    id: touch.identifier,
	                    x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,
	                    y: (touch.clientY - contentPosition.top) / contentPosition.scaleY,
	                });
	            });
	            Array.prototype.forEach.call(evt.changedTouches || evt.touches, (touch) => {
	                this._changedPointerPositions.push({
	                    id: touch.identifier,
	                    x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,
	                    y: (touch.clientY - contentPosition.top) / contentPosition.scaleY,
	                });
	            });
	        }
	        else {
	            x = (evt.clientX - contentPosition.left) / contentPosition.scaleX;
	            y = (evt.clientY - contentPosition.top) / contentPosition.scaleY;
	            this.pointerPos = {
	                x: x,
	                y: y,
	            };
	            this._pointerPositions = [{ x, y, id: Util_1.Util._getFirstPointerId(evt) }];
	            this._changedPointerPositions = [
	                { x, y, id: Util_1.Util._getFirstPointerId(evt) },
	            ];
	        }
	    }
	    _setPointerPosition(evt) {
	        Util_1.Util.warn('Method _setPointerPosition is deprecated. Use "stage.setPointersPositions(event)" instead.');
	        this.setPointersPositions(evt);
	    }
	    _getContentPosition() {
	        if (!this.content || !this.content.getBoundingClientRect) {
	            return {
	                top: 0,
	                left: 0,
	                scaleX: 1,
	                scaleY: 1,
	            };
	        }
	        var rect = this.content.getBoundingClientRect();
	        return {
	            top: rect.top,
	            left: rect.left,
	            scaleX: rect.width / this.content.clientWidth || 1,
	            scaleY: rect.height / this.content.clientHeight || 1,
	        };
	    }
	    _buildDOM() {
	        this.bufferCanvas = new Canvas_1.SceneCanvas({
	            width: this.width(),
	            height: this.height(),
	        });
	        this.bufferHitCanvas = new Canvas_1.HitCanvas({
	            pixelRatio: 1,
	            width: this.width(),
	            height: this.height(),
	        });
	        if (!Global_1.Konva.isBrowser) {
	            return;
	        }
	        var container = this.container();
	        if (!container) {
	            throw 'Stage has no container. A container is required.';
	        }
	        container.innerHTML = '';
	        this.content = document.createElement('div');
	        this.content.style.position = 'relative';
	        this.content.style.userSelect = 'none';
	        this.content.className = 'konvajs-content';
	        this.content.setAttribute('role', 'presentation');
	        container.appendChild(this.content);
	        this._resizeDOM();
	    }
	    cache() {
	        Util_1.Util.warn('Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.');
	        return this;
	    }
	    clearCache() {
	        return this;
	    }
	    batchDraw() {
	        this.getChildren().forEach(function (layer) {
	            layer.batchDraw();
	        });
	        return this;
	    }
	}
	exports.Stage = Stage;
	Stage.prototype.nodeType = STAGE;
	(0, Global_2._registerNode)(Stage);
	Factory_1.Factory.addGetterSetter(Stage, 'container'); 
} (Stage));

var Layer$1 = {};

var Shape = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Shape = exports.shapes = void 0;
	const Global_1 = Global;
	const Util_1 = Util;
	const Factory_1 = Factory;
	const Node_1 = Node$2;
	const Validators_1 = Validators;
	const Global_2 = Global;
	const PointerEvents$1 = PointerEvents;
	var HAS_SHADOW = 'hasShadow';
	var SHADOW_RGBA = 'shadowRGBA';
	var patternImage = 'patternImage';
	var linearGradient = 'linearGradient';
	var radialGradient = 'radialGradient';
	let dummyContext;
	function getDummyContext() {
	    if (dummyContext) {
	        return dummyContext;
	    }
	    dummyContext = Util_1.Util.createCanvasElement().getContext('2d');
	    return dummyContext;
	}
	exports.shapes = {};
	function _fillFunc(context) {
	    const fillRule = this.attrs.fillRule;
	    if (fillRule) {
	        context.fill(fillRule);
	    }
	    else {
	        context.fill();
	    }
	}
	function _strokeFunc(context) {
	    context.stroke();
	}
	function _fillFuncHit(context) {
	    context.fill();
	}
	function _strokeFuncHit(context) {
	    context.stroke();
	}
	function _clearHasShadowCache() {
	    this._clearCache(HAS_SHADOW);
	}
	function _clearGetShadowRGBACache() {
	    this._clearCache(SHADOW_RGBA);
	}
	function _clearFillPatternCache() {
	    this._clearCache(patternImage);
	}
	function _clearLinearGradientCache() {
	    this._clearCache(linearGradient);
	}
	function _clearRadialGradientCache() {
	    this._clearCache(radialGradient);
	}
	class Shape extends Node_1.Node {
	    constructor(config) {
	        super(config);
	        let key;
	        while (true) {
	            key = Util_1.Util.getRandomColor();
	            if (key && !(key in exports.shapes)) {
	                break;
	            }
	        }
	        this.colorKey = key;
	        exports.shapes[key] = this;
	    }
	    getContext() {
	        Util_1.Util.warn('shape.getContext() method is deprecated. Please do not use it.');
	        return this.getLayer().getContext();
	    }
	    getCanvas() {
	        Util_1.Util.warn('shape.getCanvas() method is deprecated. Please do not use it.');
	        return this.getLayer().getCanvas();
	    }
	    getSceneFunc() {
	        return this.attrs.sceneFunc || this['_sceneFunc'];
	    }
	    getHitFunc() {
	        return this.attrs.hitFunc || this['_hitFunc'];
	    }
	    hasShadow() {
	        return this._getCache(HAS_SHADOW, this._hasShadow);
	    }
	    _hasShadow() {
	        return (this.shadowEnabled() &&
	            this.shadowOpacity() !== 0 &&
	            !!(this.shadowColor() ||
	                this.shadowBlur() ||
	                this.shadowOffsetX() ||
	                this.shadowOffsetY()));
	    }
	    _getFillPattern() {
	        return this._getCache(patternImage, this.__getFillPattern);
	    }
	    __getFillPattern() {
	        if (this.fillPatternImage()) {
	            var ctx = getDummyContext();
	            const pattern = ctx.createPattern(this.fillPatternImage(), this.fillPatternRepeat() || 'repeat');
	            if (pattern && pattern.setTransform) {
	                const tr = new Util_1.Transform();
	                tr.translate(this.fillPatternX(), this.fillPatternY());
	                tr.rotate(Global_1.Konva.getAngle(this.fillPatternRotation()));
	                tr.scale(this.fillPatternScaleX(), this.fillPatternScaleY());
	                tr.translate(-1 * this.fillPatternOffsetX(), -1 * this.fillPatternOffsetY());
	                const m = tr.getMatrix();
	                const matrix = typeof DOMMatrix === 'undefined'
	                    ? {
	                        a: m[0],
	                        b: m[1],
	                        c: m[2],
	                        d: m[3],
	                        e: m[4],
	                        f: m[5],
	                    }
	                    : new DOMMatrix(m);
	                pattern.setTransform(matrix);
	            }
	            return pattern;
	        }
	    }
	    _getLinearGradient() {
	        return this._getCache(linearGradient, this.__getLinearGradient);
	    }
	    __getLinearGradient() {
	        var colorStops = this.fillLinearGradientColorStops();
	        if (colorStops) {
	            var ctx = getDummyContext();
	            var start = this.fillLinearGradientStartPoint();
	            var end = this.fillLinearGradientEndPoint();
	            var grd = ctx.createLinearGradient(start.x, start.y, end.x, end.y);
	            for (var n = 0; n < colorStops.length; n += 2) {
	                grd.addColorStop(colorStops[n], colorStops[n + 1]);
	            }
	            return grd;
	        }
	    }
	    _getRadialGradient() {
	        return this._getCache(radialGradient, this.__getRadialGradient);
	    }
	    __getRadialGradient() {
	        var colorStops = this.fillRadialGradientColorStops();
	        if (colorStops) {
	            var ctx = getDummyContext();
	            var start = this.fillRadialGradientStartPoint();
	            var end = this.fillRadialGradientEndPoint();
	            var grd = ctx.createRadialGradient(start.x, start.y, this.fillRadialGradientStartRadius(), end.x, end.y, this.fillRadialGradientEndRadius());
	            for (var n = 0; n < colorStops.length; n += 2) {
	                grd.addColorStop(colorStops[n], colorStops[n + 1]);
	            }
	            return grd;
	        }
	    }
	    getShadowRGBA() {
	        return this._getCache(SHADOW_RGBA, this._getShadowRGBA);
	    }
	    _getShadowRGBA() {
	        if (!this.hasShadow()) {
	            return;
	        }
	        var rgba = Util_1.Util.colorToRGBA(this.shadowColor());
	        if (rgba) {
	            return ('rgba(' +
	                rgba.r +
	                ',' +
	                rgba.g +
	                ',' +
	                rgba.b +
	                ',' +
	                rgba.a * (this.shadowOpacity() || 1) +
	                ')');
	        }
	    }
	    hasFill() {
	        return this._calculate('hasFill', [
	            'fillEnabled',
	            'fill',
	            'fillPatternImage',
	            'fillLinearGradientColorStops',
	            'fillRadialGradientColorStops',
	        ], () => {
	            return (this.fillEnabled() &&
	                !!(this.fill() ||
	                    this.fillPatternImage() ||
	                    this.fillLinearGradientColorStops() ||
	                    this.fillRadialGradientColorStops()));
	        });
	    }
	    hasStroke() {
	        return this._calculate('hasStroke', [
	            'strokeEnabled',
	            'strokeWidth',
	            'stroke',
	            'strokeLinearGradientColorStops',
	        ], () => {
	            return (this.strokeEnabled() &&
	                this.strokeWidth() &&
	                !!(this.stroke() || this.strokeLinearGradientColorStops()));
	        });
	    }
	    hasHitStroke() {
	        const width = this.hitStrokeWidth();
	        if (width === 'auto') {
	            return this.hasStroke();
	        }
	        return this.strokeEnabled() && !!width;
	    }
	    intersects(point) {
	        var stage = this.getStage(), bufferHitCanvas = stage.bufferHitCanvas, p;
	        bufferHitCanvas.getContext().clear();
	        this.drawHit(bufferHitCanvas, null, true);
	        p = bufferHitCanvas.context.getImageData(Math.round(point.x), Math.round(point.y), 1, 1).data;
	        return p[3] > 0;
	    }
	    destroy() {
	        Node_1.Node.prototype.destroy.call(this);
	        delete exports.shapes[this.colorKey];
	        delete this.colorKey;
	        return this;
	    }
	    _useBufferCanvas(forceFill) {
	        var _a;
	        if (!this.getStage()) {
	            return false;
	        }
	        const perfectDrawEnabled = (_a = this.attrs.perfectDrawEnabled) !== null && _a !== void 0 ? _a : true;
	        if (!perfectDrawEnabled) {
	            return false;
	        }
	        const hasFill = forceFill || this.hasFill();
	        const hasStroke = this.hasStroke();
	        const isTransparent = this.getAbsoluteOpacity() !== 1;
	        if (hasFill && hasStroke && isTransparent) {
	            return true;
	        }
	        const hasShadow = this.hasShadow();
	        const strokeForShadow = this.shadowForStrokeEnabled();
	        if (hasFill && hasStroke && hasShadow && strokeForShadow) {
	            return true;
	        }
	        return false;
	    }
	    setStrokeHitEnabled(val) {
	        Util_1.Util.warn('strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead.');
	        if (val) {
	            this.hitStrokeWidth('auto');
	        }
	        else {
	            this.hitStrokeWidth(0);
	        }
	    }
	    getStrokeHitEnabled() {
	        if (this.hitStrokeWidth() === 0) {
	            return false;
	        }
	        else {
	            return true;
	        }
	    }
	    getSelfRect() {
	        var size = this.size();
	        return {
	            x: this._centroid ? -size.width / 2 : 0,
	            y: this._centroid ? -size.height / 2 : 0,
	            width: size.width,
	            height: size.height,
	        };
	    }
	    getClientRect(config = {}) {
	        const skipTransform = config.skipTransform;
	        const relativeTo = config.relativeTo;
	        const fillRect = this.getSelfRect();
	        const applyStroke = !config.skipStroke && this.hasStroke();
	        const strokeWidth = (applyStroke && this.strokeWidth()) || 0;
	        const fillAndStrokeWidth = fillRect.width + strokeWidth;
	        const fillAndStrokeHeight = fillRect.height + strokeWidth;
	        const applyShadow = !config.skipShadow && this.hasShadow();
	        const shadowOffsetX = applyShadow ? this.shadowOffsetX() : 0;
	        const shadowOffsetY = applyShadow ? this.shadowOffsetY() : 0;
	        const preWidth = fillAndStrokeWidth + Math.abs(shadowOffsetX);
	        const preHeight = fillAndStrokeHeight + Math.abs(shadowOffsetY);
	        const blurRadius = (applyShadow && this.shadowBlur()) || 0;
	        const width = preWidth + blurRadius * 2;
	        const height = preHeight + blurRadius * 2;
	        const rect = {
	            width: width,
	            height: height,
	            x: -(strokeWidth / 2 + blurRadius) +
	                Math.min(shadowOffsetX, 0) +
	                fillRect.x,
	            y: -(strokeWidth / 2 + blurRadius) +
	                Math.min(shadowOffsetY, 0) +
	                fillRect.y,
	        };
	        if (!skipTransform) {
	            return this._transformedRect(rect, relativeTo);
	        }
	        return rect;
	    }
	    drawScene(can, top) {
	        var layer = this.getLayer(), canvas = can || layer.getCanvas(), context = canvas.getContext(), cachedCanvas = this._getCanvasCache(), drawFunc = this.getSceneFunc(), hasShadow = this.hasShadow(), stage, bufferCanvas, bufferContext;
	        var skipBuffer = canvas.isCache;
	        var cachingSelf = top === this;
	        if (!this.isVisible() && !cachingSelf) {
	            return this;
	        }
	        if (cachedCanvas) {
	            context.save();
	            var m = this.getAbsoluteTransform(top).getMatrix();
	            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
	            this._drawCachedSceneCanvas(context);
	            context.restore();
	            return this;
	        }
	        if (!drawFunc) {
	            return this;
	        }
	        context.save();
	        if (this._useBufferCanvas() && !skipBuffer) {
	            stage = this.getStage();
	            bufferCanvas = stage.bufferCanvas;
	            bufferContext = bufferCanvas.getContext();
	            bufferContext.clear();
	            bufferContext.save();
	            bufferContext._applyLineJoin(this);
	            var o = this.getAbsoluteTransform(top).getMatrix();
	            bufferContext.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
	            drawFunc.call(this, bufferContext, this);
	            bufferContext.restore();
	            var ratio = bufferCanvas.pixelRatio;
	            if (hasShadow) {
	                context._applyShadow(this);
	            }
	            context._applyOpacity(this);
	            context._applyGlobalCompositeOperation(this);
	            context.drawImage(bufferCanvas._canvas, 0, 0, bufferCanvas.width / ratio, bufferCanvas.height / ratio);
	        }
	        else {
	            context._applyLineJoin(this);
	            if (!cachingSelf) {
	                var o = this.getAbsoluteTransform(top).getMatrix();
	                context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
	                context._applyOpacity(this);
	                context._applyGlobalCompositeOperation(this);
	            }
	            if (hasShadow) {
	                context._applyShadow(this);
	            }
	            drawFunc.call(this, context, this);
	        }
	        context.restore();
	        return this;
	    }
	    drawHit(can, top, skipDragCheck = false) {
	        if (!this.shouldDrawHit(top, skipDragCheck)) {
	            return this;
	        }
	        var layer = this.getLayer(), canvas = can || layer.hitCanvas, context = canvas && canvas.getContext(), drawFunc = this.hitFunc() || this.sceneFunc(), cachedCanvas = this._getCanvasCache(), cachedHitCanvas = cachedCanvas && cachedCanvas.hit;
	        if (!this.colorKey) {
	            Util_1.Util.warn('Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()');
	        }
	        if (cachedHitCanvas) {
	            context.save();
	            var m = this.getAbsoluteTransform(top).getMatrix();
	            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
	            this._drawCachedHitCanvas(context);
	            context.restore();
	            return this;
	        }
	        if (!drawFunc) {
	            return this;
	        }
	        context.save();
	        context._applyLineJoin(this);
	        const selfCache = this === top;
	        if (!selfCache) {
	            var o = this.getAbsoluteTransform(top).getMatrix();
	            context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
	        }
	        drawFunc.call(this, context, this);
	        context.restore();
	        return this;
	    }
	    drawHitFromCache(alphaThreshold = 0) {
	        var cachedCanvas = this._getCanvasCache(), sceneCanvas = this._getCachedSceneCanvas(), hitCanvas = cachedCanvas.hit, hitContext = hitCanvas.getContext(), hitWidth = hitCanvas.getWidth(), hitHeight = hitCanvas.getHeight(), hitImageData, hitData, len, rgbColorKey, i, alpha;
	        hitContext.clear();
	        hitContext.drawImage(sceneCanvas._canvas, 0, 0, hitWidth, hitHeight);
	        try {
	            hitImageData = hitContext.getImageData(0, 0, hitWidth, hitHeight);
	            hitData = hitImageData.data;
	            len = hitData.length;
	            rgbColorKey = Util_1.Util._hexToRgb(this.colorKey);
	            for (i = 0; i < len; i += 4) {
	                alpha = hitData[i + 3];
	                if (alpha > alphaThreshold) {
	                    hitData[i] = rgbColorKey.r;
	                    hitData[i + 1] = rgbColorKey.g;
	                    hitData[i + 2] = rgbColorKey.b;
	                    hitData[i + 3] = 255;
	                }
	                else {
	                    hitData[i + 3] = 0;
	                }
	            }
	            hitContext.putImageData(hitImageData, 0, 0);
	        }
	        catch (e) {
	            Util_1.Util.error('Unable to draw hit graph from cached scene canvas. ' + e.message);
	        }
	        return this;
	    }
	    hasPointerCapture(pointerId) {
	        return PointerEvents$1.hasPointerCapture(pointerId, this);
	    }
	    setPointerCapture(pointerId) {
	        PointerEvents$1.setPointerCapture(pointerId, this);
	    }
	    releaseCapture(pointerId) {
	        PointerEvents$1.releaseCapture(pointerId, this);
	    }
	}
	exports.Shape = Shape;
	Shape.prototype._fillFunc = _fillFunc;
	Shape.prototype._strokeFunc = _strokeFunc;
	Shape.prototype._fillFuncHit = _fillFuncHit;
	Shape.prototype._strokeFuncHit = _strokeFuncHit;
	Shape.prototype._centroid = false;
	Shape.prototype.nodeType = 'Shape';
	(0, Global_2._registerNode)(Shape);
	Shape.prototype.eventListeners = {};
	Shape.prototype.on.call(Shape.prototype, 'shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearHasShadowCache);
	Shape.prototype.on.call(Shape.prototype, 'shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearGetShadowRGBACache);
	Shape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva', _clearFillPatternCache);
	Shape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva', _clearLinearGradientCache);
	Shape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva', _clearRadialGradientCache);
	Factory_1.Factory.addGetterSetter(Shape, 'stroke', undefined, (0, Validators_1.getStringOrGradientValidator)());
	Factory_1.Factory.addGetterSetter(Shape, 'strokeWidth', 2, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Shape, 'fillAfterStrokeEnabled', false);
	Factory_1.Factory.addGetterSetter(Shape, 'hitStrokeWidth', 'auto', (0, Validators_1.getNumberOrAutoValidator)());
	Factory_1.Factory.addGetterSetter(Shape, 'strokeHitEnabled', true, (0, Validators_1.getBooleanValidator)());
	Factory_1.Factory.addGetterSetter(Shape, 'perfectDrawEnabled', true, (0, Validators_1.getBooleanValidator)());
	Factory_1.Factory.addGetterSetter(Shape, 'shadowForStrokeEnabled', true, (0, Validators_1.getBooleanValidator)());
	Factory_1.Factory.addGetterSetter(Shape, 'lineJoin');
	Factory_1.Factory.addGetterSetter(Shape, 'lineCap');
	Factory_1.Factory.addGetterSetter(Shape, 'sceneFunc');
	Factory_1.Factory.addGetterSetter(Shape, 'hitFunc');
	Factory_1.Factory.addGetterSetter(Shape, 'dash');
	Factory_1.Factory.addGetterSetter(Shape, 'dashOffset', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Shape, 'shadowColor', undefined, (0, Validators_1.getStringValidator)());
	Factory_1.Factory.addGetterSetter(Shape, 'shadowBlur', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Shape, 'shadowOpacity', 1, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addComponentsGetterSetter(Shape, 'shadowOffset', ['x', 'y']);
	Factory_1.Factory.addGetterSetter(Shape, 'shadowOffsetX', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Shape, 'shadowOffsetY', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Shape, 'fillPatternImage');
	Factory_1.Factory.addGetterSetter(Shape, 'fill', undefined, (0, Validators_1.getStringOrGradientValidator)());
	Factory_1.Factory.addGetterSetter(Shape, 'fillPatternX', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Shape, 'fillPatternY', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Shape, 'fillLinearGradientColorStops');
	Factory_1.Factory.addGetterSetter(Shape, 'strokeLinearGradientColorStops');
	Factory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientStartRadius', 0);
	Factory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientEndRadius', 0);
	Factory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientColorStops');
	Factory_1.Factory.addGetterSetter(Shape, 'fillPatternRepeat', 'repeat');
	Factory_1.Factory.addGetterSetter(Shape, 'fillEnabled', true);
	Factory_1.Factory.addGetterSetter(Shape, 'strokeEnabled', true);
	Factory_1.Factory.addGetterSetter(Shape, 'shadowEnabled', true);
	Factory_1.Factory.addGetterSetter(Shape, 'dashEnabled', true);
	Factory_1.Factory.addGetterSetter(Shape, 'strokeScaleEnabled', true);
	Factory_1.Factory.addGetterSetter(Shape, 'fillPriority', 'color');
	Factory_1.Factory.addComponentsGetterSetter(Shape, 'fillPatternOffset', ['x', 'y']);
	Factory_1.Factory.addGetterSetter(Shape, 'fillPatternOffsetX', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Shape, 'fillPatternOffsetY', 0, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addComponentsGetterSetter(Shape, 'fillPatternScale', ['x', 'y']);
	Factory_1.Factory.addGetterSetter(Shape, 'fillPatternScaleX', 1, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addGetterSetter(Shape, 'fillPatternScaleY', 1, (0, Validators_1.getNumberValidator)());
	Factory_1.Factory.addComponentsGetterSetter(Shape, 'fillLinearGradientStartPoint', [
	    'x',
	    'y',
	]);
	Factory_1.Factory.addComponentsGetterSetter(Shape, 'strokeLinearGradientStartPoint', [
	    'x',
	    'y',
	]);
	Factory_1.Factory.addGetterSetter(Shape, 'fillLinearGradientStartPointX', 0);
	Factory_1.Factory.addGetterSetter(Shape, 'strokeLinearGradientStartPointX', 0);
	Factory_1.Factory.addGetterSetter(Shape, 'fillLinearGradientStartPointY', 0);
	Factory_1.Factory.addGetterSetter(Shape, 'strokeLinearGradientStartPointY', 0);
	Factory_1.Factory.addComponentsGetterSetter(Shape, 'fillLinearGradientEndPoint', [
	    'x',
	    'y',
	]);
	Factory_1.Factory.addComponentsGetterSetter(Shape, 'strokeLinearGradientEndPoint', [
	    'x',
	    'y',
	]);
	Factory_1.Factory.addGetterSetter(Shape, 'fillLinearGradientEndPointX', 0);
	Factory_1.Factory.addGetterSetter(Shape, 'strokeLinearGradientEndPointX', 0);
	Factory_1.Factory.addGetterSetter(Shape, 'fillLinearGradientEndPointY', 0);
	Factory_1.Factory.addGetterSetter(Shape, 'strokeLinearGradientEndPointY', 0);
	Factory_1.Factory.addComponentsGetterSetter(Shape, 'fillRadialGradientStartPoint', [
	    'x',
	    'y',
	]);
	Factory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientStartPointX', 0);
	Factory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientStartPointY', 0);
	Factory_1.Factory.addComponentsGetterSetter(Shape, 'fillRadialGradientEndPoint', [
	    'x',
	    'y',
	]);
	Factory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientEndPointX', 0);
	Factory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientEndPointY', 0);
	Factory_1.Factory.addGetterSetter(Shape, 'fillPatternRotation', 0);
	Factory_1.Factory.addGetterSetter(Shape, 'fillRule', undefined, (0, Validators_1.getStringValidator)());
	Factory_1.Factory.backCompat(Shape, {
	    dashArray: 'dash',
	    getDashArray: 'getDash',
	    setDashArray: 'getDash',
	    drawFunc: 'sceneFunc',
	    getDrawFunc: 'getSceneFunc',
	    setDrawFunc: 'setSceneFunc',
	    drawHitFunc: 'hitFunc',
	    getDrawHitFunc: 'getHitFunc',
	    setDrawHitFunc: 'setHitFunc',
	}); 
} (Shape));

Object.defineProperty(Layer$1, "__esModule", { value: true });
Layer$1.Layer = void 0;
const Util_1$b = Util;
const Container_1$1 = Container$1;
const Node_1$g = Node$2;
const Factory_1$w = Factory;
const Canvas_1 = Canvas$2;
const Validators_1$v = Validators;
const Shape_1$g = Shape;
const Global_1$k = Global;
var HASH = '#', BEFORE_DRAW = 'beforeDraw', DRAW = 'draw', INTERSECTION_OFFSETS = [
    { x: 0, y: 0 },
    { x: -1, y: -1 },
    { x: 1, y: -1 },
    { x: 1, y: 1 },
    { x: -1, y: 1 },
], INTERSECTION_OFFSETS_LEN = INTERSECTION_OFFSETS.length;
class Layer extends Container_1$1.Container {
    constructor(config) {
        super(config);
        this.canvas = new Canvas_1.SceneCanvas();
        this.hitCanvas = new Canvas_1.HitCanvas({
            pixelRatio: 1,
        });
        this._waitingForDraw = false;
        this.on('visibleChange.konva', this._checkVisibility);
        this._checkVisibility();
        this.on('imageSmoothingEnabledChange.konva', this._setSmoothEnabled);
        this._setSmoothEnabled();
    }
    createPNGStream() {
        const c = this.canvas._canvas;
        return c.createPNGStream();
    }
    getCanvas() {
        return this.canvas;
    }
    getNativeCanvasElement() {
        return this.canvas._canvas;
    }
    getHitCanvas() {
        return this.hitCanvas;
    }
    getContext() {
        return this.getCanvas().getContext();
    }
    clear(bounds) {
        this.getContext().clear(bounds);
        this.getHitCanvas().getContext().clear(bounds);
        return this;
    }
    setZIndex(index) {
        super.setZIndex(index);
        var stage = this.getStage();
        if (stage && stage.content) {
            stage.content.removeChild(this.getNativeCanvasElement());
            if (index < stage.children.length - 1) {
                stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[index + 1].getCanvas()._canvas);
            }
            else {
                stage.content.appendChild(this.getNativeCanvasElement());
            }
        }
        return this;
    }
    moveToTop() {
        Node_1$g.Node.prototype.moveToTop.call(this);
        var stage = this.getStage();
        if (stage && stage.content) {
            stage.content.removeChild(this.getNativeCanvasElement());
            stage.content.appendChild(this.getNativeCanvasElement());
        }
        return true;
    }
    moveUp() {
        var moved = Node_1$g.Node.prototype.moveUp.call(this);
        if (!moved) {
            return false;
        }
        var stage = this.getStage();
        if (!stage || !stage.content) {
            return false;
        }
        stage.content.removeChild(this.getNativeCanvasElement());
        if (this.index < stage.children.length - 1) {
            stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[this.index + 1].getCanvas()._canvas);
        }
        else {
            stage.content.appendChild(this.getNativeCanvasElement());
        }
        return true;
    }
    moveDown() {
        if (Node_1$g.Node.prototype.moveDown.call(this)) {
            var stage = this.getStage();
            if (stage) {
                var children = stage.children;
                if (stage.content) {
                    stage.content.removeChild(this.getNativeCanvasElement());
                    stage.content.insertBefore(this.getNativeCanvasElement(), children[this.index + 1].getCanvas()._canvas);
                }
            }
            return true;
        }
        return false;
    }
    moveToBottom() {
        if (Node_1$g.Node.prototype.moveToBottom.call(this)) {
            var stage = this.getStage();
            if (stage) {
                var children = stage.children;
                if (stage.content) {
                    stage.content.removeChild(this.getNativeCanvasElement());
                    stage.content.insertBefore(this.getNativeCanvasElement(), children[1].getCanvas()._canvas);
                }
            }
            return true;
        }
        return false;
    }
    getLayer() {
        return this;
    }
    remove() {
        var _canvas = this.getNativeCanvasElement();
        Node_1$g.Node.prototype.remove.call(this);
        if (_canvas && _canvas.parentNode && Util_1$b.Util._isInDocument(_canvas)) {
            _canvas.parentNode.removeChild(_canvas);
        }
        return this;
    }
    getStage() {
        return this.parent;
    }
    setSize({ width, height }) {
        this.canvas.setSize(width, height);
        this.hitCanvas.setSize(width, height);
        this._setSmoothEnabled();
        return this;
    }
    _validateAdd(child) {
        var type = child.getType();
        if (type !== 'Group' && type !== 'Shape') {
            Util_1$b.Util.throw('You may only add groups and shapes to a layer.');
        }
    }
    _toKonvaCanvas(config) {
        config = config || {};
        config.width = config.width || this.getWidth();
        config.height = config.height || this.getHeight();
        config.x = config.x !== undefined ? config.x : this.x();
        config.y = config.y !== undefined ? config.y : this.y();
        return Node_1$g.Node.prototype._toKonvaCanvas.call(this, config);
    }
    _checkVisibility() {
        const visible = this.visible();
        if (visible) {
            this.canvas._canvas.style.display = 'block';
        }
        else {
            this.canvas._canvas.style.display = 'none';
        }
    }
    _setSmoothEnabled() {
        this.getContext()._context.imageSmoothingEnabled =
            this.imageSmoothingEnabled();
    }
    getWidth() {
        if (this.parent) {
            return this.parent.width();
        }
    }
    setWidth() {
        Util_1$b.Util.warn('Can not change width of layer. Use "stage.width(value)" function instead.');
    }
    getHeight() {
        if (this.parent) {
            return this.parent.height();
        }
    }
    setHeight() {
        Util_1$b.Util.warn('Can not change height of layer. Use "stage.height(value)" function instead.');
    }
    batchDraw() {
        if (!this._waitingForDraw) {
            this._waitingForDraw = true;
            Util_1$b.Util.requestAnimFrame(() => {
                this.draw();
                this._waitingForDraw = false;
            });
        }
        return this;
    }
    getIntersection(pos) {
        if (!this.isListening() || !this.isVisible()) {
            return null;
        }
        var spiralSearchDistance = 1;
        var continueSearch = false;
        while (true) {
            for (let i = 0; i < INTERSECTION_OFFSETS_LEN; i++) {
                const intersectionOffset = INTERSECTION_OFFSETS[i];
                const obj = this._getIntersection({
                    x: pos.x + intersectionOffset.x * spiralSearchDistance,
                    y: pos.y + intersectionOffset.y * spiralSearchDistance,
                });
                const shape = obj.shape;
                if (shape) {
                    return shape;
                }
                continueSearch = !!obj.antialiased;
                if (!obj.antialiased) {
                    break;
                }
            }
            if (continueSearch) {
                spiralSearchDistance += 1;
            }
            else {
                return null;
            }
        }
    }
    _getIntersection(pos) {
        const ratio = this.hitCanvas.pixelRatio;
        const p = this.hitCanvas.context.getImageData(Math.round(pos.x * ratio), Math.round(pos.y * ratio), 1, 1).data;
        const p3 = p[3];
        if (p3 === 255) {
            const colorKey = Util_1$b.Util._rgbToHex(p[0], p[1], p[2]);
            const shape = Shape_1$g.shapes[HASH + colorKey];
            if (shape) {
                return {
                    shape: shape,
                };
            }
            return {
                antialiased: true,
            };
        }
        else if (p3 > 0) {
            return {
                antialiased: true,
            };
        }
        return {};
    }
    drawScene(can, top) {
        var layer = this.getLayer(), canvas = can || (layer && layer.getCanvas());
        this._fire(BEFORE_DRAW, {
            node: this,
        });
        if (this.clearBeforeDraw()) {
            canvas.getContext().clear();
        }
        Container_1$1.Container.prototype.drawScene.call(this, canvas, top);
        this._fire(DRAW, {
            node: this,
        });
        return this;
    }
    drawHit(can, top) {
        var layer = this.getLayer(), canvas = can || (layer && layer.hitCanvas);
        if (layer && layer.clearBeforeDraw()) {
            layer.getHitCanvas().getContext().clear();
        }
        Container_1$1.Container.prototype.drawHit.call(this, canvas, top);
        return this;
    }
    enableHitGraph() {
        this.hitGraphEnabled(true);
        return this;
    }
    disableHitGraph() {
        this.hitGraphEnabled(false);
        return this;
    }
    setHitGraphEnabled(val) {
        Util_1$b.Util.warn('hitGraphEnabled method is deprecated. Please use layer.listening() instead.');
        this.listening(val);
    }
    getHitGraphEnabled(val) {
        Util_1$b.Util.warn('hitGraphEnabled method is deprecated. Please use layer.listening() instead.');
        return this.listening();
    }
    toggleHitCanvas() {
        if (!this.parent || !this.parent['content']) {
            return;
        }
        var parent = this.parent;
        var added = !!this.hitCanvas._canvas.parentNode;
        if (added) {
            parent.content.removeChild(this.hitCanvas._canvas);
        }
        else {
            parent.content.appendChild(this.hitCanvas._canvas);
        }
    }
    destroy() {
        Util_1$b.Util.releaseCanvas(this.getNativeCanvasElement(), this.getHitCanvas()._canvas);
        return super.destroy();
    }
}
Layer$1.Layer = Layer;
Layer.prototype.nodeType = 'Layer';
(0, Global_1$k._registerNode)(Layer);
Factory_1$w.Factory.addGetterSetter(Layer, 'imageSmoothingEnabled', true);
Factory_1$w.Factory.addGetterSetter(Layer, 'clearBeforeDraw', true);
Factory_1$w.Factory.addGetterSetter(Layer, 'hitGraphEnabled', true, (0, Validators_1$v.getBooleanValidator)());

var FastLayer$1 = {};

Object.defineProperty(FastLayer$1, "__esModule", { value: true });
FastLayer$1.FastLayer = void 0;
const Util_1$a = Util;
const Layer_1 = Layer$1;
const Global_1$j = Global;
class FastLayer extends Layer_1.Layer {
    constructor(attrs) {
        super(attrs);
        this.listening(false);
        Util_1$a.Util.warn('Konva.Fast layer is deprecated. Please use "new Konva.Layer({ listening: false })" instead.');
    }
}
FastLayer$1.FastLayer = FastLayer;
FastLayer.prototype.nodeType = 'FastLayer';
(0, Global_1$j._registerNode)(FastLayer);

var Group$2 = {};

Object.defineProperty(Group$2, "__esModule", { value: true });
Group$2.Group = void 0;
const Util_1$9 = Util;
const Container_1 = Container$1;
const Global_1$i = Global;
let Group$1 = class Group extends Container_1.Container {
    _validateAdd(child) {
        var type = child.getType();
        if (type !== 'Group' && type !== 'Shape') {
            Util_1$9.Util.throw('You may only add groups and shapes to groups.');
        }
    }
};
Group$2.Group = Group$1;
Group$1.prototype.nodeType = 'Group';
(0, Global_1$i._registerNode)(Group$1);

var Animation$1 = {};

Object.defineProperty(Animation$1, "__esModule", { value: true });
Animation$1.Animation = void 0;
const Global_1$h = Global;
const Util_1$8 = Util;
var now$1 = (function () {
    if (Global_1$h.glob.performance && Global_1$h.glob.performance.now) {
        return function () {
            return Global_1$h.glob.performance.now();
        };
    }
    return function () {
        return new Date().getTime();
    };
})();
class Animation {
    constructor(func, layers) {
        this.id = Animation.animIdCounter++;
        this.frame = {
            time: 0,
            timeDiff: 0,
            lastTime: now$1(),
            frameRate: 0,
        };
        this.func = func;
        this.setLayers(layers);
    }
    setLayers(layers) {
        var lays = [];
        if (!layers) {
            lays = [];
        }
        else if (layers.length > 0) {
            lays = layers;
        }
        else {
            lays = [layers];
        }
        this.layers = lays;
        return this;
    }
    getLayers() {
        return this.layers;
    }
    addLayer(layer) {
        var layers = this.layers, len = layers.length, n;
        for (n = 0; n < len; n++) {
            if (layers[n]._id === layer._id) {
                return false;
            }
        }
        this.layers.push(layer);
        return true;
    }
    isRunning() {
        var a = Animation, animations = a.animations, len = animations.length, n;
        for (n = 0; n < len; n++) {
            if (animations[n].id === this.id) {
                return true;
            }
        }
        return false;
    }
    start() {
        this.stop();
        this.frame.timeDiff = 0;
        this.frame.lastTime = now$1();
        Animation._addAnimation(this);
        return this;
    }
    stop() {
        Animation._removeAnimation(this);
        return this;
    }
    _updateFrameObject(time) {
        this.frame.timeDiff = time - this.frame.lastTime;
        this.frame.lastTime = time;
        this.frame.time += this.frame.timeDiff;
        this.frame.frameRate = 1000 / this.frame.timeDiff;
    }
    static _addAnimation(anim) {
        this.animations.push(anim);
        this._handleAnimation();
    }
    static _removeAnimation(anim) {
        var id = anim.id, animations = this.animations, len = animations.length, n;
        for (n = 0; n < len; n++) {
            if (animations[n].id === id) {
                this.animations.splice(n, 1);
                break;
            }
        }
    }
    static _runFrames() {
        var layerHash = {}, animations = this.animations, anim, layers, func, n, i, layersLen, layer, key, needRedraw;
        for (n = 0; n < animations.length; n++) {
            anim = animations[n];
            layers = anim.layers;
            func = anim.func;
            anim._updateFrameObject(now$1());
            layersLen = layers.length;
            if (func) {
                needRedraw = func.call(anim, anim.frame) !== false;
            }
            else {
                needRedraw = true;
            }
            if (!needRedraw) {
                continue;
            }
            for (i = 0; i < layersLen; i++) {
                layer = layers[i];
                if (layer._id !== undefined) {
                    layerHash[layer._id] = layer;
                }
            }
        }
        for (key in layerHash) {
            if (!layerHash.hasOwnProperty(key)) {
                continue;
            }
            layerHash[key].batchDraw();
        }
    }
    static _animationLoop() {
        var Anim = Animation;
        if (Anim.animations.length) {
            Anim._runFrames();
            Util_1$8.Util.requestAnimFrame(Anim._animationLoop);
        }
        else {
            Anim.animRunning = false;
        }
    }
    static _handleAnimation() {
        if (!this.animRunning) {
            this.animRunning = true;
            Util_1$8.Util.requestAnimFrame(this._animationLoop);
        }
    }
}
Animation$1.Animation = Animation;
Animation.animations = [];
Animation.animIdCounter = 0;
Animation.animRunning = false;

var Tween = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Easings = exports.Tween = void 0;
	const Util_1 = Util;
	const Animation_1 = Animation$1;
	const Node_1 = Node$2;
	const Global_1 = Global;
	var blacklist = {
	    node: 1,
	    duration: 1,
	    easing: 1,
	    onFinish: 1,
	    yoyo: 1,
	}, PAUSED = 1, PLAYING = 2, REVERSING = 3, idCounter = 0, colorAttrs = ['fill', 'stroke', 'shadowColor'];
	class TweenEngine {
	    constructor(prop, propFunc, func, begin, finish, duration, yoyo) {
	        this.prop = prop;
	        this.propFunc = propFunc;
	        this.begin = begin;
	        this._pos = begin;
	        this.duration = duration;
	        this._change = 0;
	        this.prevPos = 0;
	        this.yoyo = yoyo;
	        this._time = 0;
	        this._position = 0;
	        this._startTime = 0;
	        this._finish = 0;
	        this.func = func;
	        this._change = finish - this.begin;
	        this.pause();
	    }
	    fire(str) {
	        var handler = this[str];
	        if (handler) {
	            handler();
	        }
	    }
	    setTime(t) {
	        if (t > this.duration) {
	            if (this.yoyo) {
	                this._time = this.duration;
	                this.reverse();
	            }
	            else {
	                this.finish();
	            }
	        }
	        else if (t < 0) {
	            if (this.yoyo) {
	                this._time = 0;
	                this.play();
	            }
	            else {
	                this.reset();
	            }
	        }
	        else {
	            this._time = t;
	            this.update();
	        }
	    }
	    getTime() {
	        return this._time;
	    }
	    setPosition(p) {
	        this.prevPos = this._pos;
	        this.propFunc(p);
	        this._pos = p;
	    }
	    getPosition(t) {
	        if (t === undefined) {
	            t = this._time;
	        }
	        return this.func(t, this.begin, this._change, this.duration);
	    }
	    play() {
	        this.state = PLAYING;
	        this._startTime = this.getTimer() - this._time;
	        this.onEnterFrame();
	        this.fire('onPlay');
	    }
	    reverse() {
	        this.state = REVERSING;
	        this._time = this.duration - this._time;
	        this._startTime = this.getTimer() - this._time;
	        this.onEnterFrame();
	        this.fire('onReverse');
	    }
	    seek(t) {
	        this.pause();
	        this._time = t;
	        this.update();
	        this.fire('onSeek');
	    }
	    reset() {
	        this.pause();
	        this._time = 0;
	        this.update();
	        this.fire('onReset');
	    }
	    finish() {
	        this.pause();
	        this._time = this.duration;
	        this.update();
	        this.fire('onFinish');
	    }
	    update() {
	        this.setPosition(this.getPosition(this._time));
	        this.fire('onUpdate');
	    }
	    onEnterFrame() {
	        var t = this.getTimer() - this._startTime;
	        if (this.state === PLAYING) {
	            this.setTime(t);
	        }
	        else if (this.state === REVERSING) {
	            this.setTime(this.duration - t);
	        }
	    }
	    pause() {
	        this.state = PAUSED;
	        this.fire('onPause');
	    }
	    getTimer() {
	        return new Date().getTime();
	    }
	}
	class Tween {
	    constructor(config) {
	        var that = this, node = config.node, nodeId = node._id, duration, easing = config.easing || exports.Easings.Linear, yoyo = !!config.yoyo, key;
	        if (typeof config.duration === 'undefined') {
	            duration = 0.3;
	        }
	        else if (config.duration === 0) {
	            duration = 0.001;
	        }
	        else {
	            duration = config.duration;
	        }
	        this.node = node;
	        this._id = idCounter++;
	        var layers = node.getLayer() ||
	            (node instanceof Global_1.Konva['Stage'] ? node.getLayers() : null);
	        if (!layers) {
	            Util_1.Util.error('Tween constructor have `node` that is not in a layer. Please add node into layer first.');
	        }
	        this.anim = new Animation_1.Animation(function () {
	            that.tween.onEnterFrame();
	        }, layers);
	        this.tween = new TweenEngine(key, function (i) {
	            that._tweenFunc(i);
	        }, easing, 0, 1, duration * 1000, yoyo);
	        this._addListeners();
	        if (!Tween.attrs[nodeId]) {
	            Tween.attrs[nodeId] = {};
	        }
	        if (!Tween.attrs[nodeId][this._id]) {
	            Tween.attrs[nodeId][this._id] = {};
	        }
	        if (!Tween.tweens[nodeId]) {
	            Tween.tweens[nodeId] = {};
	        }
	        for (key in config) {
	            if (blacklist[key] === undefined) {
	                this._addAttr(key, config[key]);
	            }
	        }
	        this.reset();
	        this.onFinish = config.onFinish;
	        this.onReset = config.onReset;
	        this.onUpdate = config.onUpdate;
	    }
	    _addAttr(key, end) {
	        var node = this.node, nodeId = node._id, start, diff, tweenId, n, len, trueEnd, trueStart, endRGBA;
	        tweenId = Tween.tweens[nodeId][key];
	        if (tweenId) {
	            delete Tween.attrs[nodeId][tweenId][key];
	        }
	        start = node.getAttr(key);
	        if (Util_1.Util._isArray(end)) {
	            diff = [];
	            len = Math.max(end.length, start.length);
	            if (key === 'points' && end.length !== start.length) {
	                if (end.length > start.length) {
	                    trueStart = start;
	                    start = Util_1.Util._prepareArrayForTween(start, end, node.closed());
	                }
	                else {
	                    trueEnd = end;
	                    end = Util_1.Util._prepareArrayForTween(end, start, node.closed());
	                }
	            }
	            if (key.indexOf('fill') === 0) {
	                for (n = 0; n < len; n++) {
	                    if (n % 2 === 0) {
	                        diff.push(end[n] - start[n]);
	                    }
	                    else {
	                        var startRGBA = Util_1.Util.colorToRGBA(start[n]);
	                        endRGBA = Util_1.Util.colorToRGBA(end[n]);
	                        start[n] = startRGBA;
	                        diff.push({
	                            r: endRGBA.r - startRGBA.r,
	                            g: endRGBA.g - startRGBA.g,
	                            b: endRGBA.b - startRGBA.b,
	                            a: endRGBA.a - startRGBA.a,
	                        });
	                    }
	                }
	            }
	            else {
	                for (n = 0; n < len; n++) {
	                    diff.push(end[n] - start[n]);
	                }
	            }
	        }
	        else if (colorAttrs.indexOf(key) !== -1) {
	            start = Util_1.Util.colorToRGBA(start);
	            endRGBA = Util_1.Util.colorToRGBA(end);
	            diff = {
	                r: endRGBA.r - start.r,
	                g: endRGBA.g - start.g,
	                b: endRGBA.b - start.b,
	                a: endRGBA.a - start.a,
	            };
	        }
	        else {
	            diff = end - start;
	        }
	        Tween.attrs[nodeId][this._id][key] = {
	            start: start,
	            diff: diff,
	            end: end,
	            trueEnd: trueEnd,
	            trueStart: trueStart,
	        };
	        Tween.tweens[nodeId][key] = this._id;
	    }
	    _tweenFunc(i) {
	        var node = this.node, attrs = Tween.attrs[node._id][this._id], key, attr, start, diff, newVal, n, len, end;
	        for (key in attrs) {
	            attr = attrs[key];
	            start = attr.start;
	            diff = attr.diff;
	            end = attr.end;
	            if (Util_1.Util._isArray(start)) {
	                newVal = [];
	                len = Math.max(start.length, end.length);
	                if (key.indexOf('fill') === 0) {
	                    for (n = 0; n < len; n++) {
	                        if (n % 2 === 0) {
	                            newVal.push((start[n] || 0) + diff[n] * i);
	                        }
	                        else {
	                            newVal.push('rgba(' +
	                                Math.round(start[n].r + diff[n].r * i) +
	                                ',' +
	                                Math.round(start[n].g + diff[n].g * i) +
	                                ',' +
	                                Math.round(start[n].b + diff[n].b * i) +
	                                ',' +
	                                (start[n].a + diff[n].a * i) +
	                                ')');
	                        }
	                    }
	                }
	                else {
	                    for (n = 0; n < len; n++) {
	                        newVal.push((start[n] || 0) + diff[n] * i);
	                    }
	                }
	            }
	            else if (colorAttrs.indexOf(key) !== -1) {
	                newVal =
	                    'rgba(' +
	                        Math.round(start.r + diff.r * i) +
	                        ',' +
	                        Math.round(start.g + diff.g * i) +
	                        ',' +
	                        Math.round(start.b + diff.b * i) +
	                        ',' +
	                        (start.a + diff.a * i) +
	                        ')';
	            }
	            else {
	                newVal = start + diff * i;
	            }
	            node.setAttr(key, newVal);
	        }
	    }
	    _addListeners() {
	        this.tween.onPlay = () => {
	            this.anim.start();
	        };
	        this.tween.onReverse = () => {
	            this.anim.start();
	        };
	        this.tween.onPause = () => {
	            this.anim.stop();
	        };
	        this.tween.onFinish = () => {
	            var node = this.node;
	            var attrs = Tween.attrs[node._id][this._id];
	            if (attrs.points && attrs.points.trueEnd) {
	                node.setAttr('points', attrs.points.trueEnd);
	            }
	            if (this.onFinish) {
	                this.onFinish.call(this);
	            }
	        };
	        this.tween.onReset = () => {
	            var node = this.node;
	            var attrs = Tween.attrs[node._id][this._id];
	            if (attrs.points && attrs.points.trueStart) {
	                node.points(attrs.points.trueStart);
	            }
	            if (this.onReset) {
	                this.onReset();
	            }
	        };
	        this.tween.onUpdate = () => {
	            if (this.onUpdate) {
	                this.onUpdate.call(this);
	            }
	        };
	    }
	    play() {
	        this.tween.play();
	        return this;
	    }
	    reverse() {
	        this.tween.reverse();
	        return this;
	    }
	    reset() {
	        this.tween.reset();
	        return this;
	    }
	    seek(t) {
	        this.tween.seek(t * 1000);
	        return this;
	    }
	    pause() {
	        this.tween.pause();
	        return this;
	    }
	    finish() {
	        this.tween.finish();
	        return this;
	    }
	    destroy() {
	        var nodeId = this.node._id, thisId = this._id, attrs = Tween.tweens[nodeId], key;
	        this.pause();
	        for (key in attrs) {
	            delete Tween.tweens[nodeId][key];
	        }
	        delete Tween.attrs[nodeId][thisId];
	    }
	}
	exports.Tween = Tween;
	Tween.attrs = {};
	Tween.tweens = {};
	Node_1.Node.prototype.to = function (params) {
	    var onFinish = params.onFinish;
	    params.node = this;
	    params.onFinish = function () {
	        this.destroy();
	        if (onFinish) {
	            onFinish();
	        }
	    };
	    var tween = new Tween(params);
	    tween.play();
	};
	exports.Easings = {
	    BackEaseIn(t, b, c, d) {
	        var s = 1.70158;
	        return c * (t /= d) * t * ((s + 1) * t - s) + b;
	    },
	    BackEaseOut(t, b, c, d) {
	        var s = 1.70158;
	        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
	    },
	    BackEaseInOut(t, b, c, d) {
	        var s = 1.70158;
	        if ((t /= d / 2) < 1) {
	            return (c / 2) * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
	        }
	        return (c / 2) * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
	    },
	    ElasticEaseIn(t, b, c, d, a, p) {
	        var s = 0;
	        if (t === 0) {
	            return b;
	        }
	        if ((t /= d) === 1) {
	            return b + c;
	        }
	        if (!p) {
	            p = d * 0.3;
	        }
	        if (!a || a < Math.abs(c)) {
	            a = c;
	            s = p / 4;
	        }
	        else {
	            s = (p / (2 * Math.PI)) * Math.asin(c / a);
	        }
	        return (-(a *
	            Math.pow(2, 10 * (t -= 1)) *
	            Math.sin(((t * d - s) * (2 * Math.PI)) / p)) + b);
	    },
	    ElasticEaseOut(t, b, c, d, a, p) {
	        var s = 0;
	        if (t === 0) {
	            return b;
	        }
	        if ((t /= d) === 1) {
	            return b + c;
	        }
	        if (!p) {
	            p = d * 0.3;
	        }
	        if (!a || a < Math.abs(c)) {
	            a = c;
	            s = p / 4;
	        }
	        else {
	            s = (p / (2 * Math.PI)) * Math.asin(c / a);
	        }
	        return (a * Math.pow(2, -10 * t) * Math.sin(((t * d - s) * (2 * Math.PI)) / p) +
	            c +
	            b);
	    },
	    ElasticEaseInOut(t, b, c, d, a, p) {
	        var s = 0;
	        if (t === 0) {
	            return b;
	        }
	        if ((t /= d / 2) === 2) {
	            return b + c;
	        }
	        if (!p) {
	            p = d * (0.3 * 1.5);
	        }
	        if (!a || a < Math.abs(c)) {
	            a = c;
	            s = p / 4;
	        }
	        else {
	            s = (p / (2 * Math.PI)) * Math.asin(c / a);
	        }
	        if (t < 1) {
	            return (-0.5 *
	                (a *
	                    Math.pow(2, 10 * (t -= 1)) *
	                    Math.sin(((t * d - s) * (2 * Math.PI)) / p)) +
	                b);
	        }
	        return (a *
	            Math.pow(2, -10 * (t -= 1)) *
	            Math.sin(((t * d - s) * (2 * Math.PI)) / p) *
	            0.5 +
	            c +
	            b);
	    },
	    BounceEaseOut(t, b, c, d) {
	        if ((t /= d) < 1 / 2.75) {
	            return c * (7.5625 * t * t) + b;
	        }
	        else if (t < 2 / 2.75) {
	            return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
	        }
	        else if (t < 2.5 / 2.75) {
	            return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
	        }
	        else {
	            return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
	        }
	    },
	    BounceEaseIn(t, b, c, d) {
	        return c - exports.Easings.BounceEaseOut(d - t, 0, c, d) + b;
	    },
	    BounceEaseInOut(t, b, c, d) {
	        if (t < d / 2) {
	            return exports.Easings.BounceEaseIn(t * 2, 0, c, d) * 0.5 + b;
	        }
	        else {
	            return exports.Easings.BounceEaseOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
	        }
	    },
	    EaseIn(t, b, c, d) {
	        return c * (t /= d) * t + b;
	    },
	    EaseOut(t, b, c, d) {
	        return -c * (t /= d) * (t - 2) + b;
	    },
	    EaseInOut(t, b, c, d) {
	        if ((t /= d / 2) < 1) {
	            return (c / 2) * t * t + b;
	        }
	        return (-c / 2) * (--t * (t - 2) - 1) + b;
	    },
	    StrongEaseIn(t, b, c, d) {
	        return c * (t /= d) * t * t * t * t + b;
	    },
	    StrongEaseOut(t, b, c, d) {
	        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
	    },
	    StrongEaseInOut(t, b, c, d) {
	        if ((t /= d / 2) < 1) {
	            return (c / 2) * t * t * t * t * t + b;
	        }
	        return (c / 2) * ((t -= 2) * t * t * t * t + 2) + b;
	    },
	    Linear(t, b, c, d) {
	        return (c * t) / d + b;
	    },
	}; 
} (Tween));

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Konva = void 0;
	const Global_1 = Global;
	const Util_1 = Util;
	const Node_1 = Node$2;
	const Container_1 = Container$1;
	const Stage_1 = Stage;
	const Layer_1 = Layer$1;
	const FastLayer_1 = FastLayer$1;
	const Group_1 = Group$2;
	const DragAndDrop_1 = DragAndDrop;
	const Shape_1 = Shape;
	const Animation_1 = Animation$1;
	const Tween_1 = Tween;
	const Context_1 = Context$2;
	const Canvas_1 = Canvas$2;
	exports.Konva = Util_1.Util._assign(Global_1.Konva, {
	    Util: Util_1.Util,
	    Transform: Util_1.Transform,
	    Node: Node_1.Node,
	    Container: Container_1.Container,
	    Stage: Stage_1.Stage,
	    stages: Stage_1.stages,
	    Layer: Layer_1.Layer,
	    FastLayer: FastLayer_1.FastLayer,
	    Group: Group_1.Group,
	    DD: DragAndDrop_1.DD,
	    Shape: Shape_1.Shape,
	    shapes: Shape_1.shapes,
	    Animation: Animation_1.Animation,
	    Tween: Tween_1.Tween,
	    Easings: Tween_1.Easings,
	    Context: Context_1.Context,
	    Canvas: Canvas_1.Canvas,
	});
	exports.default = exports.Konva; 
} (_CoreInternals));

var Arc$1 = {};

Object.defineProperty(Arc$1, "__esModule", { value: true });
Arc$1.Arc = void 0;
const Factory_1$v = Factory;
const Shape_1$f = Shape;
const Global_1$g = Global;
const Validators_1$u = Validators;
const Global_2$2 = Global;
class Arc extends Shape_1$f.Shape {
    _sceneFunc(context) {
        var angle = Global_1$g.Konva.getAngle(this.angle()), clockwise = this.clockwise();
        context.beginPath();
        context.arc(0, 0, this.outerRadius(), 0, angle, clockwise);
        context.arc(0, 0, this.innerRadius(), angle, 0, !clockwise);
        context.closePath();
        context.fillStrokeShape(this);
    }
    getWidth() {
        return this.outerRadius() * 2;
    }
    getHeight() {
        return this.outerRadius() * 2;
    }
    setWidth(width) {
        this.outerRadius(width / 2);
    }
    setHeight(height) {
        this.outerRadius(height / 2);
    }
    getSelfRect() {
        const innerRadius = this.innerRadius();
        const outerRadius = this.outerRadius();
        const clockwise = this.clockwise();
        const angle = Global_1$g.Konva.getAngle(clockwise ? 360 - this.angle() : this.angle());
        const boundLeftRatio = Math.cos(Math.min(angle, Math.PI));
        const boundRightRatio = 1;
        const boundTopRatio = Math.sin(Math.min(Math.max(Math.PI, angle), (3 * Math.PI) / 2));
        const boundBottomRatio = Math.sin(Math.min(angle, Math.PI / 2));
        const boundLeft = boundLeftRatio * (boundLeftRatio > 0 ? innerRadius : outerRadius);
        const boundRight = boundRightRatio * (outerRadius );
        const boundTop = boundTopRatio * (boundTopRatio > 0 ? innerRadius : outerRadius);
        const boundBottom = boundBottomRatio * (boundBottomRatio > 0 ? outerRadius : innerRadius);
        return {
            x: boundLeft,
            y: clockwise ? -1 * boundBottom : boundTop,
            width: boundRight - boundLeft,
            height: boundBottom - boundTop,
        };
    }
}
Arc$1.Arc = Arc;
Arc.prototype._centroid = true;
Arc.prototype.className = 'Arc';
Arc.prototype._attrsAffectingSize = ['innerRadius', 'outerRadius'];
(0, Global_2$2._registerNode)(Arc);
Factory_1$v.Factory.addGetterSetter(Arc, 'innerRadius', 0, (0, Validators_1$u.getNumberValidator)());
Factory_1$v.Factory.addGetterSetter(Arc, 'outerRadius', 0, (0, Validators_1$u.getNumberValidator)());
Factory_1$v.Factory.addGetterSetter(Arc, 'angle', 0, (0, Validators_1$u.getNumberValidator)());
Factory_1$v.Factory.addGetterSetter(Arc, 'clockwise', false, (0, Validators_1$u.getBooleanValidator)());

var Arrow$1 = {};

var Line$3 = {};

Object.defineProperty(Line$3, "__esModule", { value: true });
Line$3.Line = void 0;
const Factory_1$u = Factory;
const Shape_1$e = Shape;
const Validators_1$t = Validators;
const Global_1$f = Global;
function getControlPoints(x0, y0, x1, y1, x2, y2, t) {
    var d01 = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2)), d12 = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)), fa = (t * d01) / (d01 + d12), fb = (t * d12) / (d01 + d12), p1x = x1 - fa * (x2 - x0), p1y = y1 - fa * (y2 - y0), p2x = x1 + fb * (x2 - x0), p2y = y1 + fb * (y2 - y0);
    return [p1x, p1y, p2x, p2y];
}
function expandPoints(p, tension) {
    var len = p.length, allPoints = [], n, cp;
    for (n = 2; n < len - 2; n += 2) {
        cp = getControlPoints(p[n - 2], p[n - 1], p[n], p[n + 1], p[n + 2], p[n + 3], tension);
        if (isNaN(cp[0])) {
            continue;
        }
        allPoints.push(cp[0]);
        allPoints.push(cp[1]);
        allPoints.push(p[n]);
        allPoints.push(p[n + 1]);
        allPoints.push(cp[2]);
        allPoints.push(cp[3]);
    }
    return allPoints;
}
let Line$2 = class Line extends Shape_1$e.Shape {
    constructor(config) {
        super(config);
        this.on('pointsChange.konva tensionChange.konva closedChange.konva bezierChange.konva', function () {
            this._clearCache('tensionPoints');
        });
    }
    _sceneFunc(context) {
        var points = this.points(), length = points.length, tension = this.tension(), closed = this.closed(), bezier = this.bezier(), tp, len, n;
        if (!length) {
            return;
        }
        context.beginPath();
        context.moveTo(points[0], points[1]);
        if (tension !== 0 && length > 4) {
            tp = this.getTensionPoints();
            len = tp.length;
            n = closed ? 0 : 4;
            if (!closed) {
                context.quadraticCurveTo(tp[0], tp[1], tp[2], tp[3]);
            }
            while (n < len - 2) {
                context.bezierCurveTo(tp[n++], tp[n++], tp[n++], tp[n++], tp[n++], tp[n++]);
            }
            if (!closed) {
                context.quadraticCurveTo(tp[len - 2], tp[len - 1], points[length - 2], points[length - 1]);
            }
        }
        else if (bezier) {
            n = 2;
            while (n < length) {
                context.bezierCurveTo(points[n++], points[n++], points[n++], points[n++], points[n++], points[n++]);
            }
        }
        else {
            for (n = 2; n < length; n += 2) {
                context.lineTo(points[n], points[n + 1]);
            }
        }
        if (closed) {
            context.closePath();
            context.fillStrokeShape(this);
        }
        else {
            context.strokeShape(this);
        }
    }
    getTensionPoints() {
        return this._getCache('tensionPoints', this._getTensionPoints);
    }
    _getTensionPoints() {
        if (this.closed()) {
            return this._getTensionPointsClosed();
        }
        else {
            return expandPoints(this.points(), this.tension());
        }
    }
    _getTensionPointsClosed() {
        var p = this.points(), len = p.length, tension = this.tension(), firstControlPoints = getControlPoints(p[len - 2], p[len - 1], p[0], p[1], p[2], p[3], tension), lastControlPoints = getControlPoints(p[len - 4], p[len - 3], p[len - 2], p[len - 1], p[0], p[1], tension), middle = expandPoints(p, tension), tp = [firstControlPoints[2], firstControlPoints[3]]
            .concat(middle)
            .concat([
            lastControlPoints[0],
            lastControlPoints[1],
            p[len - 2],
            p[len - 1],
            lastControlPoints[2],
            lastControlPoints[3],
            firstControlPoints[0],
            firstControlPoints[1],
            p[0],
            p[1],
        ]);
        return tp;
    }
    getWidth() {
        return this.getSelfRect().width;
    }
    getHeight() {
        return this.getSelfRect().height;
    }
    getSelfRect() {
        var points = this.points();
        if (points.length < 4) {
            return {
                x: points[0] || 0,
                y: points[1] || 0,
                width: 0,
                height: 0,
            };
        }
        if (this.tension() !== 0) {
            points = [
                points[0],
                points[1],
                ...this._getTensionPoints(),
                points[points.length - 2],
                points[points.length - 1],
            ];
        }
        else {
            points = this.points();
        }
        var minX = points[0];
        var maxX = points[0];
        var minY = points[1];
        var maxY = points[1];
        var x, y;
        for (var i = 0; i < points.length / 2; i++) {
            x = points[i * 2];
            y = points[i * 2 + 1];
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
        }
        return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY,
        };
    }
};
Line$3.Line = Line$2;
Line$2.prototype.className = 'Line';
Line$2.prototype._attrsAffectingSize = ['points', 'bezier', 'tension'];
(0, Global_1$f._registerNode)(Line$2);
Factory_1$u.Factory.addGetterSetter(Line$2, 'closed', false);
Factory_1$u.Factory.addGetterSetter(Line$2, 'bezier', false);
Factory_1$u.Factory.addGetterSetter(Line$2, 'tension', 0, (0, Validators_1$t.getNumberValidator)());
Factory_1$u.Factory.addGetterSetter(Line$2, 'points', [], (0, Validators_1$t.getNumberArrayValidator)());

var Path$1 = {};

var BezierFunctions = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.t2length = exports.getQuadraticArcLength = exports.getCubicArcLength = exports.binomialCoefficients = exports.cValues = exports.tValues = void 0;
	exports.tValues = [
	    [],
	    [],
	    [
	        -0.5773502691896257645091487805019574556476,
	        0.5773502691896257645091487805019574556476,
	    ],
	    [
	        0, -0.7745966692414833770358530799564799221665,
	        0.7745966692414833770358530799564799221665,
	    ],
	    [
	        -0.3399810435848562648026657591032446872005,
	        0.3399810435848562648026657591032446872005,
	        -0.8611363115940525752239464888928095050957,
	        0.8611363115940525752239464888928095050957,
	    ],
	    [
	        0, -0.5384693101056830910363144207002088049672,
	        0.5384693101056830910363144207002088049672,
	        -0.9061798459386639927976268782993929651256,
	        0.9061798459386639927976268782993929651256,
	    ],
	    [
	        0.6612093864662645136613995950199053470064,
	        -0.6612093864662645136613995950199053470064,
	        -0.2386191860831969086305017216807119354186,
	        0.2386191860831969086305017216807119354186,
	        -0.9324695142031520278123015544939946091347,
	        0.9324695142031520278123015544939946091347,
	    ],
	    [
	        0, 0.4058451513773971669066064120769614633473,
	        -0.4058451513773971669066064120769614633473,
	        -0.7415311855993944398638647732807884070741,
	        0.7415311855993944398638647732807884070741,
	        -0.9491079123427585245261896840478512624007,
	        0.9491079123427585245261896840478512624007,
	    ],
	    [
	        -0.1834346424956498049394761423601839806667,
	        0.1834346424956498049394761423601839806667,
	        -0.5255324099163289858177390491892463490419,
	        0.5255324099163289858177390491892463490419,
	        -0.7966664774136267395915539364758304368371,
	        0.7966664774136267395915539364758304368371,
	        -0.9602898564975362316835608685694729904282,
	        0.9602898564975362316835608685694729904282,
	    ],
	    [
	        0, -0.8360311073266357942994297880697348765441,
	        0.8360311073266357942994297880697348765441,
	        -0.9681602395076260898355762029036728700494,
	        0.9681602395076260898355762029036728700494,
	        -0.3242534234038089290385380146433366085719,
	        0.3242534234038089290385380146433366085719,
	        -0.6133714327005903973087020393414741847857,
	        0.6133714327005903973087020393414741847857,
	    ],
	    [
	        -0.1488743389816312108848260011297199846175,
	        0.1488743389816312108848260011297199846175,
	        -0.4333953941292471907992659431657841622,
	        0.4333953941292471907992659431657841622,
	        -0.6794095682990244062343273651148735757692,
	        0.6794095682990244062343273651148735757692,
	        -0.8650633666889845107320966884234930485275,
	        0.8650633666889845107320966884234930485275,
	        -0.9739065285171717200779640120844520534282,
	        0.9739065285171717200779640120844520534282,
	    ],
	    [
	        0, -0.2695431559523449723315319854008615246796,
	        0.2695431559523449723315319854008615246796,
	        -0.5190961292068118159257256694586095544802,
	        0.5190961292068118159257256694586095544802,
	        -0.7301520055740493240934162520311534580496,
	        0.7301520055740493240934162520311534580496,
	        -0.8870625997680952990751577693039272666316,
	        0.8870625997680952990751577693039272666316,
	        -0.9782286581460569928039380011228573907714,
	        0.9782286581460569928039380011228573907714,
	    ],
	    [
	        -0.1252334085114689154724413694638531299833,
	        0.1252334085114689154724413694638531299833,
	        -0.3678314989981801937526915366437175612563,
	        0.3678314989981801937526915366437175612563,
	        -0.587317954286617447296702418940534280369,
	        0.587317954286617447296702418940534280369,
	        -0.7699026741943046870368938332128180759849,
	        0.7699026741943046870368938332128180759849,
	        -0.9041172563704748566784658661190961925375,
	        0.9041172563704748566784658661190961925375,
	        -0.9815606342467192506905490901492808229601,
	        0.9815606342467192506905490901492808229601,
	    ],
	    [
	        0, -0.2304583159551347940655281210979888352115,
	        0.2304583159551347940655281210979888352115,
	        -0.4484927510364468528779128521276398678019,
	        0.4484927510364468528779128521276398678019,
	        -0.6423493394403402206439846069955156500716,
	        0.6423493394403402206439846069955156500716,
	        -0.8015780907333099127942064895828598903056,
	        0.8015780907333099127942064895828598903056,
	        -0.9175983992229779652065478365007195123904,
	        0.9175983992229779652065478365007195123904,
	        -0.9841830547185881494728294488071096110649,
	        0.9841830547185881494728294488071096110649,
	    ],
	    [
	        -0.1080549487073436620662446502198347476119,
	        0.1080549487073436620662446502198347476119,
	        -0.3191123689278897604356718241684754668342,
	        0.3191123689278897604356718241684754668342,
	        -0.5152486363581540919652907185511886623088,
	        0.5152486363581540919652907185511886623088,
	        -0.6872929048116854701480198030193341375384,
	        0.6872929048116854701480198030193341375384,
	        -0.8272013150697649931897947426503949610397,
	        0.8272013150697649931897947426503949610397,
	        -0.928434883663573517336391139377874264477,
	        0.928434883663573517336391139377874264477,
	        -0.986283808696812338841597266704052801676,
	        0.986283808696812338841597266704052801676,
	    ],
	    [
	        0, -0.2011940939974345223006283033945962078128,
	        0.2011940939974345223006283033945962078128,
	        -0.3941513470775633698972073709810454683627,
	        0.3941513470775633698972073709810454683627,
	        -0.5709721726085388475372267372539106412383,
	        0.5709721726085388475372267372539106412383,
	        -0.7244177313601700474161860546139380096308,
	        0.7244177313601700474161860546139380096308,
	        -0.8482065834104272162006483207742168513662,
	        0.8482065834104272162006483207742168513662,
	        -0.9372733924007059043077589477102094712439,
	        0.9372733924007059043077589477102094712439,
	        -0.9879925180204854284895657185866125811469,
	        0.9879925180204854284895657185866125811469,
	    ],
	    [
	        -0.0950125098376374401853193354249580631303,
	        0.0950125098376374401853193354249580631303,
	        -0.281603550779258913230460501460496106486,
	        0.281603550779258913230460501460496106486,
	        -0.45801677765722738634241944298357757354,
	        0.45801677765722738634241944298357757354,
	        -0.6178762444026437484466717640487910189918,
	        0.6178762444026437484466717640487910189918,
	        -0.7554044083550030338951011948474422683538,
	        0.7554044083550030338951011948474422683538,
	        -0.8656312023878317438804678977123931323873,
	        0.8656312023878317438804678977123931323873,
	        -0.9445750230732325760779884155346083450911,
	        0.9445750230732325760779884155346083450911,
	        -0.9894009349916499325961541734503326274262,
	        0.9894009349916499325961541734503326274262,
	    ],
	    [
	        0, -0.1784841814958478558506774936540655574754,
	        0.1784841814958478558506774936540655574754,
	        -0.3512317634538763152971855170953460050405,
	        0.3512317634538763152971855170953460050405,
	        -0.5126905370864769678862465686295518745829,
	        0.5126905370864769678862465686295518745829,
	        -0.6576711592166907658503022166430023351478,
	        0.6576711592166907658503022166430023351478,
	        -0.7815140038968014069252300555204760502239,
	        0.7815140038968014069252300555204760502239,
	        -0.8802391537269859021229556944881556926234,
	        0.8802391537269859021229556944881556926234,
	        -0.9506755217687677612227169578958030214433,
	        0.9506755217687677612227169578958030214433,
	        -0.9905754753144173356754340199406652765077,
	        0.9905754753144173356754340199406652765077,
	    ],
	    [
	        -0.0847750130417353012422618529357838117333,
	        0.0847750130417353012422618529357838117333,
	        -0.2518862256915055095889728548779112301628,
	        0.2518862256915055095889728548779112301628,
	        -0.4117511614628426460359317938330516370789,
	        0.4117511614628426460359317938330516370789,
	        -0.5597708310739475346078715485253291369276,
	        0.5597708310739475346078715485253291369276,
	        -0.6916870430603532078748910812888483894522,
	        0.6916870430603532078748910812888483894522,
	        -0.8037049589725231156824174550145907971032,
	        0.8037049589725231156824174550145907971032,
	        -0.8926024664975557392060605911271455154078,
	        0.8926024664975557392060605911271455154078,
	        -0.9558239495713977551811958929297763099728,
	        0.9558239495713977551811958929297763099728,
	        -0.9915651684209309467300160047061507702525,
	        0.9915651684209309467300160047061507702525,
	    ],
	    [
	        0, -0.1603586456402253758680961157407435495048,
	        0.1603586456402253758680961157407435495048,
	        -0.3165640999636298319901173288498449178922,
	        0.3165640999636298319901173288498449178922,
	        -0.4645707413759609457172671481041023679762,
	        0.4645707413759609457172671481041023679762,
	        -0.6005453046616810234696381649462392798683,
	        0.6005453046616810234696381649462392798683,
	        -0.7209661773352293786170958608237816296571,
	        0.7209661773352293786170958608237816296571,
	        -0.8227146565371428249789224867127139017745,
	        0.8227146565371428249789224867127139017745,
	        -0.9031559036148179016426609285323124878093,
	        0.9031559036148179016426609285323124878093,
	        -0.960208152134830030852778840687651526615,
	        0.960208152134830030852778840687651526615,
	        -0.9924068438435844031890176702532604935893,
	        0.9924068438435844031890176702532604935893,
	    ],
	    [
	        -0.0765265211334973337546404093988382110047,
	        0.0765265211334973337546404093988382110047,
	        -0.227785851141645078080496195368574624743,
	        0.227785851141645078080496195368574624743,
	        -0.3737060887154195606725481770249272373957,
	        0.3737060887154195606725481770249272373957,
	        -0.5108670019508270980043640509552509984254,
	        0.5108670019508270980043640509552509984254,
	        -0.6360536807265150254528366962262859367433,
	        0.6360536807265150254528366962262859367433,
	        -0.7463319064601507926143050703556415903107,
	        0.7463319064601507926143050703556415903107,
	        -0.8391169718222188233945290617015206853296,
	        0.8391169718222188233945290617015206853296,
	        -0.9122344282513259058677524412032981130491,
	        0.9122344282513259058677524412032981130491,
	        -0.963971927277913791267666131197277221912,
	        0.963971927277913791267666131197277221912,
	        -0.9931285991850949247861223884713202782226,
	        0.9931285991850949247861223884713202782226,
	    ],
	    [
	        0, -0.1455618541608950909370309823386863301163,
	        0.1455618541608950909370309823386863301163,
	        -0.288021316802401096600792516064600319909,
	        0.288021316802401096600792516064600319909,
	        -0.4243421202074387835736688885437880520964,
	        0.4243421202074387835736688885437880520964,
	        -0.551618835887219807059018796724313286622,
	        0.551618835887219807059018796724313286622,
	        -0.667138804197412319305966669990339162597,
	        0.667138804197412319305966669990339162597,
	        -0.7684399634756779086158778513062280348209,
	        0.7684399634756779086158778513062280348209,
	        -0.8533633645833172836472506385875676702761,
	        0.8533633645833172836472506385875676702761,
	        -0.9200993341504008287901871337149688941591,
	        0.9200993341504008287901871337149688941591,
	        -0.9672268385663062943166222149076951614246,
	        0.9672268385663062943166222149076951614246,
	        -0.9937521706203895002602420359379409291933,
	        0.9937521706203895002602420359379409291933,
	    ],
	    [
	        -0.0697392733197222212138417961186280818222,
	        0.0697392733197222212138417961186280818222,
	        -0.2078604266882212854788465339195457342156,
	        0.2078604266882212854788465339195457342156,
	        -0.3419358208920842251581474204273796195591,
	        0.3419358208920842251581474204273796195591,
	        -0.4693558379867570264063307109664063460953,
	        0.4693558379867570264063307109664063460953,
	        -0.5876404035069115929588769276386473488776,
	        0.5876404035069115929588769276386473488776,
	        -0.6944872631866827800506898357622567712673,
	        0.6944872631866827800506898357622567712673,
	        -0.7878168059792081620042779554083515213881,
	        0.7878168059792081620042779554083515213881,
	        -0.8658125777203001365364256370193787290847,
	        0.8658125777203001365364256370193787290847,
	        -0.9269567721871740005206929392590531966353,
	        0.9269567721871740005206929392590531966353,
	        -0.9700604978354287271239509867652687108059,
	        0.9700604978354287271239509867652687108059,
	        -0.994294585482399292073031421161298980393,
	        0.994294585482399292073031421161298980393,
	    ],
	    [
	        0, -0.1332568242984661109317426822417661370104,
	        0.1332568242984661109317426822417661370104,
	        -0.264135680970344930533869538283309602979,
	        0.264135680970344930533869538283309602979,
	        -0.390301038030290831421488872880605458578,
	        0.390301038030290831421488872880605458578,
	        -0.5095014778460075496897930478668464305448,
	        0.5095014778460075496897930478668464305448,
	        -0.6196098757636461563850973116495956533871,
	        0.6196098757636461563850973116495956533871,
	        -0.7186613631319501944616244837486188483299,
	        0.7186613631319501944616244837486188483299,
	        -0.8048884016188398921511184069967785579414,
	        0.8048884016188398921511184069967785579414,
	        -0.8767523582704416673781568859341456716389,
	        0.8767523582704416673781568859341456716389,
	        -0.9329710868260161023491969890384229782357,
	        0.9329710868260161023491969890384229782357,
	        -0.9725424712181152319560240768207773751816,
	        0.9725424712181152319560240768207773751816,
	        -0.9947693349975521235239257154455743605736,
	        0.9947693349975521235239257154455743605736,
	    ],
	    [
	        -0.0640568928626056260850430826247450385909,
	        0.0640568928626056260850430826247450385909,
	        -0.1911188674736163091586398207570696318404,
	        0.1911188674736163091586398207570696318404,
	        -0.3150426796961633743867932913198102407864,
	        0.3150426796961633743867932913198102407864,
	        -0.4337935076260451384870842319133497124524,
	        0.4337935076260451384870842319133497124524,
	        -0.5454214713888395356583756172183723700107,
	        0.5454214713888395356583756172183723700107,
	        -0.6480936519369755692524957869107476266696,
	        0.6480936519369755692524957869107476266696,
	        -0.7401241915785543642438281030999784255232,
	        0.7401241915785543642438281030999784255232,
	        -0.8200019859739029219539498726697452080761,
	        0.8200019859739029219539498726697452080761,
	        -0.8864155270044010342131543419821967550873,
	        0.8864155270044010342131543419821967550873,
	        -0.9382745520027327585236490017087214496548,
	        0.9382745520027327585236490017087214496548,
	        -0.9747285559713094981983919930081690617411,
	        0.9747285559713094981983919930081690617411,
	        -0.9951872199970213601799974097007368118745,
	        0.9951872199970213601799974097007368118745,
	    ],
	];
	exports.cValues = [
	    [],
	    [],
	    [1.0, 1.0],
	    [
	        0.8888888888888888888888888888888888888888,
	        0.5555555555555555555555555555555555555555,
	        0.5555555555555555555555555555555555555555,
	    ],
	    [
	        0.6521451548625461426269360507780005927646,
	        0.6521451548625461426269360507780005927646,
	        0.3478548451374538573730639492219994072353,
	        0.3478548451374538573730639492219994072353,
	    ],
	    [
	        0.5688888888888888888888888888888888888888,
	        0.4786286704993664680412915148356381929122,
	        0.4786286704993664680412915148356381929122,
	        0.2369268850561890875142640407199173626432,
	        0.2369268850561890875142640407199173626432,
	    ],
	    [
	        0.3607615730481386075698335138377161116615,
	        0.3607615730481386075698335138377161116615,
	        0.4679139345726910473898703439895509948116,
	        0.4679139345726910473898703439895509948116,
	        0.1713244923791703450402961421727328935268,
	        0.1713244923791703450402961421727328935268,
	    ],
	    [
	        0.4179591836734693877551020408163265306122,
	        0.3818300505051189449503697754889751338783,
	        0.3818300505051189449503697754889751338783,
	        0.2797053914892766679014677714237795824869,
	        0.2797053914892766679014677714237795824869,
	        0.1294849661688696932706114326790820183285,
	        0.1294849661688696932706114326790820183285,
	    ],
	    [
	        0.3626837833783619829651504492771956121941,
	        0.3626837833783619829651504492771956121941,
	        0.3137066458778872873379622019866013132603,
	        0.3137066458778872873379622019866013132603,
	        0.2223810344533744705443559944262408844301,
	        0.2223810344533744705443559944262408844301,
	        0.1012285362903762591525313543099621901153,
	        0.1012285362903762591525313543099621901153,
	    ],
	    [
	        0.3302393550012597631645250692869740488788,
	        0.1806481606948574040584720312429128095143,
	        0.1806481606948574040584720312429128095143,
	        0.0812743883615744119718921581105236506756,
	        0.0812743883615744119718921581105236506756,
	        0.3123470770400028400686304065844436655987,
	        0.3123470770400028400686304065844436655987,
	        0.2606106964029354623187428694186328497718,
	        0.2606106964029354623187428694186328497718,
	    ],
	    [
	        0.295524224714752870173892994651338329421,
	        0.295524224714752870173892994651338329421,
	        0.2692667193099963550912269215694693528597,
	        0.2692667193099963550912269215694693528597,
	        0.2190863625159820439955349342281631924587,
	        0.2190863625159820439955349342281631924587,
	        0.1494513491505805931457763396576973324025,
	        0.1494513491505805931457763396576973324025,
	        0.0666713443086881375935688098933317928578,
	        0.0666713443086881375935688098933317928578,
	    ],
	    [
	        0.272925086777900630714483528336342189156,
	        0.2628045445102466621806888698905091953727,
	        0.2628045445102466621806888698905091953727,
	        0.2331937645919904799185237048431751394317,
	        0.2331937645919904799185237048431751394317,
	        0.1862902109277342514260976414316558916912,
	        0.1862902109277342514260976414316558916912,
	        0.1255803694649046246346942992239401001976,
	        0.1255803694649046246346942992239401001976,
	        0.0556685671161736664827537204425485787285,
	        0.0556685671161736664827537204425485787285,
	    ],
	    [
	        0.2491470458134027850005624360429512108304,
	        0.2491470458134027850005624360429512108304,
	        0.2334925365383548087608498989248780562594,
	        0.2334925365383548087608498989248780562594,
	        0.2031674267230659217490644558097983765065,
	        0.2031674267230659217490644558097983765065,
	        0.160078328543346226334652529543359071872,
	        0.160078328543346226334652529543359071872,
	        0.1069393259953184309602547181939962242145,
	        0.1069393259953184309602547181939962242145,
	        0.047175336386511827194615961485017060317,
	        0.047175336386511827194615961485017060317,
	    ],
	    [
	        0.2325515532308739101945895152688359481566,
	        0.2262831802628972384120901860397766184347,
	        0.2262831802628972384120901860397766184347,
	        0.2078160475368885023125232193060527633865,
	        0.2078160475368885023125232193060527633865,
	        0.1781459807619457382800466919960979955128,
	        0.1781459807619457382800466919960979955128,
	        0.1388735102197872384636017768688714676218,
	        0.1388735102197872384636017768688714676218,
	        0.0921214998377284479144217759537971209236,
	        0.0921214998377284479144217759537971209236,
	        0.0404840047653158795200215922009860600419,
	        0.0404840047653158795200215922009860600419,
	    ],
	    [
	        0.2152638534631577901958764433162600352749,
	        0.2152638534631577901958764433162600352749,
	        0.2051984637212956039659240656612180557103,
	        0.2051984637212956039659240656612180557103,
	        0.1855383974779378137417165901251570362489,
	        0.1855383974779378137417165901251570362489,
	        0.1572031671581935345696019386238421566056,
	        0.1572031671581935345696019386238421566056,
	        0.1215185706879031846894148090724766259566,
	        0.1215185706879031846894148090724766259566,
	        0.0801580871597602098056332770628543095836,
	        0.0801580871597602098056332770628543095836,
	        0.0351194603317518630318328761381917806197,
	        0.0351194603317518630318328761381917806197,
	    ],
	    [
	        0.2025782419255612728806201999675193148386,
	        0.1984314853271115764561183264438393248186,
	        0.1984314853271115764561183264438393248186,
	        0.1861610000155622110268005618664228245062,
	        0.1861610000155622110268005618664228245062,
	        0.1662692058169939335532008604812088111309,
	        0.1662692058169939335532008604812088111309,
	        0.1395706779261543144478047945110283225208,
	        0.1395706779261543144478047945110283225208,
	        0.1071592204671719350118695466858693034155,
	        0.1071592204671719350118695466858693034155,
	        0.0703660474881081247092674164506673384667,
	        0.0703660474881081247092674164506673384667,
	        0.0307532419961172683546283935772044177217,
	        0.0307532419961172683546283935772044177217,
	    ],
	    [
	        0.1894506104550684962853967232082831051469,
	        0.1894506104550684962853967232082831051469,
	        0.1826034150449235888667636679692199393835,
	        0.1826034150449235888667636679692199393835,
	        0.1691565193950025381893120790303599622116,
	        0.1691565193950025381893120790303599622116,
	        0.1495959888165767320815017305474785489704,
	        0.1495959888165767320815017305474785489704,
	        0.1246289712555338720524762821920164201448,
	        0.1246289712555338720524762821920164201448,
	        0.0951585116824927848099251076022462263552,
	        0.0951585116824927848099251076022462263552,
	        0.0622535239386478928628438369943776942749,
	        0.0622535239386478928628438369943776942749,
	        0.0271524594117540948517805724560181035122,
	        0.0271524594117540948517805724560181035122,
	    ],
	    [
	        0.1794464703562065254582656442618856214487,
	        0.1765627053669926463252709901131972391509,
	        0.1765627053669926463252709901131972391509,
	        0.1680041021564500445099706637883231550211,
	        0.1680041021564500445099706637883231550211,
	        0.1540457610768102880814315948019586119404,
	        0.1540457610768102880814315948019586119404,
	        0.1351363684685254732863199817023501973721,
	        0.1351363684685254732863199817023501973721,
	        0.1118838471934039710947883856263559267358,
	        0.1118838471934039710947883856263559267358,
	        0.0850361483171791808835353701910620738504,
	        0.0850361483171791808835353701910620738504,
	        0.0554595293739872011294401653582446605128,
	        0.0554595293739872011294401653582446605128,
	        0.0241483028685479319601100262875653246916,
	        0.0241483028685479319601100262875653246916,
	    ],
	    [
	        0.1691423829631435918406564701349866103341,
	        0.1691423829631435918406564701349866103341,
	        0.1642764837458327229860537764659275904123,
	        0.1642764837458327229860537764659275904123,
	        0.1546846751262652449254180038363747721932,
	        0.1546846751262652449254180038363747721932,
	        0.1406429146706506512047313037519472280955,
	        0.1406429146706506512047313037519472280955,
	        0.1225552067114784601845191268002015552281,
	        0.1225552067114784601845191268002015552281,
	        0.1009420441062871655628139849248346070628,
	        0.1009420441062871655628139849248346070628,
	        0.0764257302548890565291296776166365256053,
	        0.0764257302548890565291296776166365256053,
	        0.0497145488949697964533349462026386416808,
	        0.0497145488949697964533349462026386416808,
	        0.0216160135264833103133427102664524693876,
	        0.0216160135264833103133427102664524693876,
	    ],
	    [
	        0.1610544498487836959791636253209167350399,
	        0.1589688433939543476499564394650472016787,
	        0.1589688433939543476499564394650472016787,
	        0.152766042065859666778855400897662998461,
	        0.152766042065859666778855400897662998461,
	        0.1426067021736066117757461094419029724756,
	        0.1426067021736066117757461094419029724756,
	        0.1287539625393362276755157848568771170558,
	        0.1287539625393362276755157848568771170558,
	        0.1115666455473339947160239016817659974813,
	        0.1115666455473339947160239016817659974813,
	        0.0914900216224499994644620941238396526609,
	        0.0914900216224499994644620941238396526609,
	        0.0690445427376412265807082580060130449618,
	        0.0690445427376412265807082580060130449618,
	        0.0448142267656996003328381574019942119517,
	        0.0448142267656996003328381574019942119517,
	        0.0194617882297264770363120414644384357529,
	        0.0194617882297264770363120414644384357529,
	    ],
	    [
	        0.1527533871307258506980843319550975934919,
	        0.1527533871307258506980843319550975934919,
	        0.1491729864726037467878287370019694366926,
	        0.1491729864726037467878287370019694366926,
	        0.1420961093183820513292983250671649330345,
	        0.1420961093183820513292983250671649330345,
	        0.1316886384491766268984944997481631349161,
	        0.1316886384491766268984944997481631349161,
	        0.118194531961518417312377377711382287005,
	        0.118194531961518417312377377711382287005,
	        0.1019301198172404350367501354803498761666,
	        0.1019301198172404350367501354803498761666,
	        0.0832767415767047487247581432220462061001,
	        0.0832767415767047487247581432220462061001,
	        0.0626720483341090635695065351870416063516,
	        0.0626720483341090635695065351870416063516,
	        0.040601429800386941331039952274932109879,
	        0.040601429800386941331039952274932109879,
	        0.0176140071391521183118619623518528163621,
	        0.0176140071391521183118619623518528163621,
	    ],
	    [
	        0.1460811336496904271919851476833711882448,
	        0.1445244039899700590638271665537525436099,
	        0.1445244039899700590638271665537525436099,
	        0.1398873947910731547221334238675831108927,
	        0.1398873947910731547221334238675831108927,
	        0.132268938633337461781052574496775604329,
	        0.132268938633337461781052574496775604329,
	        0.1218314160537285341953671771257335983563,
	        0.1218314160537285341953671771257335983563,
	        0.1087972991671483776634745780701056420336,
	        0.1087972991671483776634745780701056420336,
	        0.0934444234560338615532897411139320884835,
	        0.0934444234560338615532897411139320884835,
	        0.0761001136283793020170516533001831792261,
	        0.0761001136283793020170516533001831792261,
	        0.0571344254268572082836358264724479574912,
	        0.0571344254268572082836358264724479574912,
	        0.0369537897708524937999506682993296661889,
	        0.0369537897708524937999506682993296661889,
	        0.0160172282577743333242246168584710152658,
	        0.0160172282577743333242246168584710152658,
	    ],
	    [
	        0.1392518728556319933754102483418099578739,
	        0.1392518728556319933754102483418099578739,
	        0.1365414983460151713525738312315173965863,
	        0.1365414983460151713525738312315173965863,
	        0.1311735047870623707329649925303074458757,
	        0.1311735047870623707329649925303074458757,
	        0.1232523768105124242855609861548144719594,
	        0.1232523768105124242855609861548144719594,
	        0.1129322960805392183934006074217843191142,
	        0.1129322960805392183934006074217843191142,
	        0.1004141444428809649320788378305362823508,
	        0.1004141444428809649320788378305362823508,
	        0.0859416062170677274144436813727028661891,
	        0.0859416062170677274144436813727028661891,
	        0.0697964684245204880949614189302176573987,
	        0.0697964684245204880949614189302176573987,
	        0.0522933351526832859403120512732112561121,
	        0.0522933351526832859403120512732112561121,
	        0.0337749015848141547933022468659129013491,
	        0.0337749015848141547933022468659129013491,
	        0.0146279952982722006849910980471854451902,
	        0.0146279952982722006849910980471854451902,
	    ],
	    [
	        0.1336545721861061753514571105458443385831,
	        0.132462039404696617371642464703316925805,
	        0.132462039404696617371642464703316925805,
	        0.1289057221880821499785953393997936532597,
	        0.1289057221880821499785953393997936532597,
	        0.1230490843067295304675784006720096548158,
	        0.1230490843067295304675784006720096548158,
	        0.1149966402224113649416435129339613014914,
	        0.1149966402224113649416435129339613014914,
	        0.1048920914645414100740861850147438548584,
	        0.1048920914645414100740861850147438548584,
	        0.0929157660600351474770186173697646486034,
	        0.0929157660600351474770186173697646486034,
	        0.0792814117767189549228925247420432269137,
	        0.0792814117767189549228925247420432269137,
	        0.0642324214085258521271696151589109980391,
	        0.0642324214085258521271696151589109980391,
	        0.0480376717310846685716410716320339965612,
	        0.0480376717310846685716410716320339965612,
	        0.0309880058569794443106942196418845053837,
	        0.0309880058569794443106942196418845053837,
	        0.0134118594871417720813094934586150649766,
	        0.0134118594871417720813094934586150649766,
	    ],
	    [
	        0.1279381953467521569740561652246953718517,
	        0.1279381953467521569740561652246953718517,
	        0.1258374563468282961213753825111836887264,
	        0.1258374563468282961213753825111836887264,
	        0.121670472927803391204463153476262425607,
	        0.121670472927803391204463153476262425607,
	        0.1155056680537256013533444839067835598622,
	        0.1155056680537256013533444839067835598622,
	        0.1074442701159656347825773424466062227946,
	        0.1074442701159656347825773424466062227946,
	        0.0976186521041138882698806644642471544279,
	        0.0976186521041138882698806644642471544279,
	        0.086190161531953275917185202983742667185,
	        0.086190161531953275917185202983742667185,
	        0.0733464814110803057340336152531165181193,
	        0.0733464814110803057340336152531165181193,
	        0.0592985849154367807463677585001085845412,
	        0.0592985849154367807463677585001085845412,
	        0.0442774388174198061686027482113382288593,
	        0.0442774388174198061686027482113382288593,
	        0.0285313886289336631813078159518782864491,
	        0.0285313886289336631813078159518782864491,
	        0.0123412297999871995468056670700372915759,
	        0.0123412297999871995468056670700372915759,
	    ],
	];
	exports.binomialCoefficients = [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]];
	const getCubicArcLength = (xs, ys, t) => {
	    let z;
	    let sum;
	    let correctedT;
	    const n = 20;
	    z = t / 2;
	    sum = 0;
	    for (let i = 0; i < n; i++) {
	        correctedT = z * exports.tValues[n][i] + z;
	        sum += exports.cValues[n][i] * BFunc(xs, ys, correctedT);
	    }
	    return z * sum;
	};
	exports.getCubicArcLength = getCubicArcLength;
	const getQuadraticArcLength = (xs, ys, t) => {
	    if (t === undefined) {
	        t = 1;
	    }
	    const ax = xs[0] - 2 * xs[1] + xs[2];
	    const ay = ys[0] - 2 * ys[1] + ys[2];
	    const bx = 2 * xs[1] - 2 * xs[0];
	    const by = 2 * ys[1] - 2 * ys[0];
	    const A = 4 * (ax * ax + ay * ay);
	    const B = 4 * (ax * bx + ay * by);
	    const C = bx * bx + by * by;
	    if (A === 0) {
	        return (t * Math.sqrt(Math.pow(xs[2] - xs[0], 2) + Math.pow(ys[2] - ys[0], 2)));
	    }
	    const b = B / (2 * A);
	    const c = C / A;
	    const u = t + b;
	    const k = c - b * b;
	    const uuk = u * u + k > 0 ? Math.sqrt(u * u + k) : 0;
	    const bbk = b * b + k > 0 ? Math.sqrt(b * b + k) : 0;
	    const term = b + Math.sqrt(b * b + k) !== 0
	        ? k * Math.log(Math.abs((u + uuk) / (b + bbk)))
	        : 0;
	    return (Math.sqrt(A) / 2) * (u * uuk - b * bbk + term);
	};
	exports.getQuadraticArcLength = getQuadraticArcLength;
	function BFunc(xs, ys, t) {
	    const xbase = getDerivative(1, t, xs);
	    const ybase = getDerivative(1, t, ys);
	    const combined = xbase * xbase + ybase * ybase;
	    return Math.sqrt(combined);
	}
	const getDerivative = (derivative, t, vs) => {
	    const n = vs.length - 1;
	    let _vs;
	    let value;
	    if (n === 0) {
	        return 0;
	    }
	    if (derivative === 0) {
	        value = 0;
	        for (let k = 0; k <= n; k++) {
	            value +=
	                exports.binomialCoefficients[n][k] *
	                    Math.pow(1 - t, n - k) *
	                    Math.pow(t, k) *
	                    vs[k];
	        }
	        return value;
	    }
	    else {
	        _vs = new Array(n);
	        for (let k = 0; k < n; k++) {
	            _vs[k] = n * (vs[k + 1] - vs[k]);
	        }
	        return getDerivative(derivative - 1, t, _vs);
	    }
	};
	const t2length = (length, totalLength, func) => {
	    let error = 1;
	    let t = length / totalLength;
	    let step = (length - func(t)) / totalLength;
	    let numIterations = 0;
	    while (error > 0.001) {
	        const increasedTLength = func(t + step);
	        const increasedTError = Math.abs(length - increasedTLength) / totalLength;
	        if (increasedTError < error) {
	            error = increasedTError;
	            t += step;
	        }
	        else {
	            const decreasedTLength = func(t - step);
	            const decreasedTError = Math.abs(length - decreasedTLength) / totalLength;
	            if (decreasedTError < error) {
	                error = decreasedTError;
	                t -= step;
	            }
	            else {
	                step /= 2;
	            }
	        }
	        numIterations++;
	        if (numIterations > 500) {
	            break;
	        }
	    }
	    return t;
	};
	exports.t2length = t2length; 
} (BezierFunctions));

Object.defineProperty(Path$1, "__esModule", { value: true });
Path$1.Path = void 0;
const Factory_1$t = Factory;
const Shape_1$d = Shape;
const Global_1$e = Global;
const BezierFunctions_1 = BezierFunctions;
class Path extends Shape_1$d.Shape {
    constructor(config) {
        super(config);
        this.dataArray = [];
        this.pathLength = 0;
        this._readDataAttribute();
        this.on('dataChange.konva', function () {
            this._readDataAttribute();
        });
    }
    _readDataAttribute() {
        this.dataArray = Path.parsePathData(this.data());
        this.pathLength = Path.getPathLength(this.dataArray);
    }
    _sceneFunc(context) {
        var ca = this.dataArray;
        context.beginPath();
        var isClosed = false;
        for (var n = 0; n < ca.length; n++) {
            var c = ca[n].command;
            var p = ca[n].points;
            switch (c) {
                case 'L':
                    context.lineTo(p[0], p[1]);
                    break;
                case 'M':
                    context.moveTo(p[0], p[1]);
                    break;
                case 'C':
                    context.bezierCurveTo(p[0], p[1], p[2], p[3], p[4], p[5]);
                    break;
                case 'Q':
                    context.quadraticCurveTo(p[0], p[1], p[2], p[3]);
                    break;
                case 'A':
                    var cx = p[0], cy = p[1], rx = p[2], ry = p[3], theta = p[4], dTheta = p[5], psi = p[6], fs = p[7];
                    var r = rx > ry ? rx : ry;
                    var scaleX = rx > ry ? 1 : rx / ry;
                    var scaleY = rx > ry ? ry / rx : 1;
                    context.translate(cx, cy);
                    context.rotate(psi);
                    context.scale(scaleX, scaleY);
                    context.arc(0, 0, r, theta, theta + dTheta, 1 - fs);
                    context.scale(1 / scaleX, 1 / scaleY);
                    context.rotate(-psi);
                    context.translate(-cx, -cy);
                    break;
                case 'z':
                    isClosed = true;
                    context.closePath();
                    break;
            }
        }
        if (!isClosed && !this.hasFill()) {
            context.strokeShape(this);
        }
        else {
            context.fillStrokeShape(this);
        }
    }
    getSelfRect() {
        var points = [];
        this.dataArray.forEach(function (data) {
            if (data.command === 'A') {
                var start = data.points[4];
                var dTheta = data.points[5];
                var end = data.points[4] + dTheta;
                var inc = Math.PI / 180.0;
                if (Math.abs(start - end) < inc) {
                    inc = Math.abs(start - end);
                }
                if (dTheta < 0) {
                    for (let t = start - inc; t > end; t -= inc) {
                        const point = Path.getPointOnEllipticalArc(data.points[0], data.points[1], data.points[2], data.points[3], t, 0);
                        points.push(point.x, point.y);
                    }
                }
                else {
                    for (let t = start + inc; t < end; t += inc) {
                        const point = Path.getPointOnEllipticalArc(data.points[0], data.points[1], data.points[2], data.points[3], t, 0);
                        points.push(point.x, point.y);
                    }
                }
            }
            else if (data.command === 'C') {
                for (let t = 0.0; t <= 1; t += 0.01) {
                    const point = Path.getPointOnCubicBezier(t, data.start.x, data.start.y, data.points[0], data.points[1], data.points[2], data.points[3], data.points[4], data.points[5]);
                    points.push(point.x, point.y);
                }
            }
            else {
                points = points.concat(data.points);
            }
        });
        var minX = points[0];
        var maxX = points[0];
        var minY = points[1];
        var maxY = points[1];
        var x, y;
        for (var i = 0; i < points.length / 2; i++) {
            x = points[i * 2];
            y = points[i * 2 + 1];
            if (!isNaN(x)) {
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
            }
            if (!isNaN(y)) {
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            }
        }
        return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY,
        };
    }
    getLength() {
        return this.pathLength;
    }
    getPointAtLength(length) {
        return Path.getPointAtLengthOfDataArray(length, this.dataArray);
    }
    static getLineLength(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    }
    static getPathLength(dataArray) {
        let pathLength = 0;
        for (var i = 0; i < dataArray.length; ++i) {
            pathLength += dataArray[i].pathLength;
        }
        return pathLength;
    }
    static getPointAtLengthOfDataArray(length, dataArray) {
        var point, i = 0, ii = dataArray.length;
        if (!ii) {
            return null;
        }
        while (i < ii && length > dataArray[i].pathLength) {
            length -= dataArray[i].pathLength;
            ++i;
        }
        if (i === ii) {
            point = dataArray[i - 1].points.slice(-2);
            return {
                x: point[0],
                y: point[1],
            };
        }
        if (length < 0.01) {
            point = dataArray[i].points.slice(0, 2);
            return {
                x: point[0],
                y: point[1],
            };
        }
        var cp = dataArray[i];
        var p = cp.points;
        switch (cp.command) {
            case 'L':
                return Path.getPointOnLine(length, cp.start.x, cp.start.y, p[0], p[1]);
            case 'C':
                return Path.getPointOnCubicBezier((0, BezierFunctions_1.t2length)(length, Path.getPathLength(dataArray), (i) => {
                    return (0, BezierFunctions_1.getCubicArcLength)([cp.start.x, p[0], p[2], p[4]], [cp.start.y, p[1], p[3], p[5]], i);
                }), cp.start.x, cp.start.y, p[0], p[1], p[2], p[3], p[4], p[5]);
            case 'Q':
                return Path.getPointOnQuadraticBezier((0, BezierFunctions_1.t2length)(length, Path.getPathLength(dataArray), (i) => {
                    return (0, BezierFunctions_1.getQuadraticArcLength)([cp.start.x, p[0], p[2]], [cp.start.y, p[1], p[3]], i);
                }), cp.start.x, cp.start.y, p[0], p[1], p[2], p[3]);
            case 'A':
                var cx = p[0], cy = p[1], rx = p[2], ry = p[3], theta = p[4], dTheta = p[5], psi = p[6];
                theta += (dTheta * length) / cp.pathLength;
                return Path.getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi);
        }
        return null;
    }
    static getPointOnLine(dist, P1x, P1y, P2x, P2y, fromX, fromY) {
        if (fromX === undefined) {
            fromX = P1x;
        }
        if (fromY === undefined) {
            fromY = P1y;
        }
        var m = (P2y - P1y) / (P2x - P1x + 0.00000001);
        var run = Math.sqrt((dist * dist) / (1 + m * m));
        if (P2x < P1x) {
            run *= -1;
        }
        var rise = m * run;
        var pt;
        if (P2x === P1x) {
            pt = {
                x: fromX,
                y: fromY + rise,
            };
        }
        else if ((fromY - P1y) / (fromX - P1x + 0.00000001) === m) {
            pt = {
                x: fromX + run,
                y: fromY + rise,
            };
        }
        else {
            var ix, iy;
            var len = this.getLineLength(P1x, P1y, P2x, P2y);
            var u = (fromX - P1x) * (P2x - P1x) + (fromY - P1y) * (P2y - P1y);
            u = u / (len * len);
            ix = P1x + u * (P2x - P1x);
            iy = P1y + u * (P2y - P1y);
            var pRise = this.getLineLength(fromX, fromY, ix, iy);
            var pRun = Math.sqrt(dist * dist - pRise * pRise);
            run = Math.sqrt((pRun * pRun) / (1 + m * m));
            if (P2x < P1x) {
                run *= -1;
            }
            rise = m * run;
            pt = {
                x: ix + run,
                y: iy + rise,
            };
        }
        return pt;
    }
    static getPointOnCubicBezier(pct, P1x, P1y, P2x, P2y, P3x, P3y, P4x, P4y) {
        function CB1(t) {
            return t * t * t;
        }
        function CB2(t) {
            return 3 * t * t * (1 - t);
        }
        function CB3(t) {
            return 3 * t * (1 - t) * (1 - t);
        }
        function CB4(t) {
            return (1 - t) * (1 - t) * (1 - t);
        }
        var x = P4x * CB1(pct) + P3x * CB2(pct) + P2x * CB3(pct) + P1x * CB4(pct);
        var y = P4y * CB1(pct) + P3y * CB2(pct) + P2y * CB3(pct) + P1y * CB4(pct);
        return {
            x: x,
            y: y,
        };
    }
    static getPointOnQuadraticBezier(pct, P1x, P1y, P2x, P2y, P3x, P3y) {
        function QB1(t) {
            return t * t;
        }
        function QB2(t) {
            return 2 * t * (1 - t);
        }
        function QB3(t) {
            return (1 - t) * (1 - t);
        }
        var x = P3x * QB1(pct) + P2x * QB2(pct) + P1x * QB3(pct);
        var y = P3y * QB1(pct) + P2y * QB2(pct) + P1y * QB3(pct);
        return {
            x: x,
            y: y,
        };
    }
    static getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {
        var cosPsi = Math.cos(psi), sinPsi = Math.sin(psi);
        var pt = {
            x: rx * Math.cos(theta),
            y: ry * Math.sin(theta),
        };
        return {
            x: cx + (pt.x * cosPsi - pt.y * sinPsi),
            y: cy + (pt.x * sinPsi + pt.y * cosPsi),
        };
    }
    static parsePathData(data) {
        if (!data) {
            return [];
        }
        var cs = data;
        var cc = [
            'm',
            'M',
            'l',
            'L',
            'v',
            'V',
            'h',
            'H',
            'z',
            'Z',
            'c',
            'C',
            'q',
            'Q',
            't',
            'T',
            's',
            'S',
            'a',
            'A',
        ];
        cs = cs.replace(new RegExp(' ', 'g'), ',');
        for (var n = 0; n < cc.length; n++) {
            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
        }
        var arr = cs.split('|');
        var ca = [];
        var coords = [];
        var cpx = 0;
        var cpy = 0;
        var re = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/gi;
        var match;
        for (n = 1; n < arr.length; n++) {
            var str = arr[n];
            var c = str.charAt(0);
            str = str.slice(1);
            coords.length = 0;
            while ((match = re.exec(str))) {
                coords.push(match[0]);
            }
            var p = [];
            for (var j = 0, jlen = coords.length; j < jlen; j++) {
                if (coords[j] === '00') {
                    p.push(0, 0);
                    continue;
                }
                var parsed = parseFloat(coords[j]);
                if (!isNaN(parsed)) {
                    p.push(parsed);
                }
                else {
                    p.push(0);
                }
            }
            while (p.length > 0) {
                if (isNaN(p[0])) {
                    break;
                }
                var cmd = null;
                var points = [];
                var startX = cpx, startY = cpy;
                var prevCmd, ctlPtx, ctlPty;
                var rx, ry, psi, fa, fs, x1, y1;
                switch (c) {
                    case 'l':
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'L':
                        cpx = p.shift();
                        cpy = p.shift();
                        points.push(cpx, cpy);
                        break;
                    case 'm':
                        var dx = p.shift();
                        var dy = p.shift();
                        cpx += dx;
                        cpy += dy;
                        cmd = 'M';
                        if (ca.length > 2 && ca[ca.length - 1].command === 'z') {
                            for (var idx = ca.length - 2; idx >= 0; idx--) {
                                if (ca[idx].command === 'M') {
                                    cpx = ca[idx].points[0] + dx;
                                    cpy = ca[idx].points[1] + dy;
                                    break;
                                }
                            }
                        }
                        points.push(cpx, cpy);
                        c = 'l';
                        break;
                    case 'M':
                        cpx = p.shift();
                        cpy = p.shift();
                        cmd = 'M';
                        points.push(cpx, cpy);
                        c = 'L';
                        break;
                    case 'h':
                        cpx += p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'H':
                        cpx = p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'v':
                        cpy += p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'V':
                        cpy = p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'C':
                        points.push(p.shift(), p.shift(), p.shift(), p.shift());
                        cpx = p.shift();
                        cpy = p.shift();
                        points.push(cpx, cpy);
                        break;
                    case 'c':
                        points.push(cpx + p.shift(), cpy + p.shift(), cpx + p.shift(), cpy + p.shift());
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'C';
                        points.push(cpx, cpy);
                        break;
                    case 'S':
                        ctlPtx = cpx;
                        ctlPty = cpy;
                        prevCmd = ca[ca.length - 1];
                        if (prevCmd.command === 'C') {
                            ctlPtx = cpx + (cpx - prevCmd.points[2]);
                            ctlPty = cpy + (cpy - prevCmd.points[3]);
                        }
                        points.push(ctlPtx, ctlPty, p.shift(), p.shift());
                        cpx = p.shift();
                        cpy = p.shift();
                        cmd = 'C';
                        points.push(cpx, cpy);
                        break;
                    case 's':
                        ctlPtx = cpx;
                        ctlPty = cpy;
                        prevCmd = ca[ca.length - 1];
                        if (prevCmd.command === 'C') {
                            ctlPtx = cpx + (cpx - prevCmd.points[2]);
                            ctlPty = cpy + (cpy - prevCmd.points[3]);
                        }
                        points.push(ctlPtx, ctlPty, cpx + p.shift(), cpy + p.shift());
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'C';
                        points.push(cpx, cpy);
                        break;
                    case 'Q':
                        points.push(p.shift(), p.shift());
                        cpx = p.shift();
                        cpy = p.shift();
                        points.push(cpx, cpy);
                        break;
                    case 'q':
                        points.push(cpx + p.shift(), cpy + p.shift());
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'Q';
                        points.push(cpx, cpy);
                        break;
                    case 'T':
                        ctlPtx = cpx;
                        ctlPty = cpy;
                        prevCmd = ca[ca.length - 1];
                        if (prevCmd.command === 'Q') {
                            ctlPtx = cpx + (cpx - prevCmd.points[0]);
                            ctlPty = cpy + (cpy - prevCmd.points[1]);
                        }
                        cpx = p.shift();
                        cpy = p.shift();
                        cmd = 'Q';
                        points.push(ctlPtx, ctlPty, cpx, cpy);
                        break;
                    case 't':
                        ctlPtx = cpx;
                        ctlPty = cpy;
                        prevCmd = ca[ca.length - 1];
                        if (prevCmd.command === 'Q') {
                            ctlPtx = cpx + (cpx - prevCmd.points[0]);
                            ctlPty = cpy + (cpy - prevCmd.points[1]);
                        }
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'Q';
                        points.push(ctlPtx, ctlPty, cpx, cpy);
                        break;
                    case 'A':
                        rx = p.shift();
                        ry = p.shift();
                        psi = p.shift();
                        fa = p.shift();
                        fs = p.shift();
                        x1 = cpx;
                        y1 = cpy;
                        cpx = p.shift();
                        cpy = p.shift();
                        cmd = 'A';
                        points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
                        break;
                    case 'a':
                        rx = p.shift();
                        ry = p.shift();
                        psi = p.shift();
                        fa = p.shift();
                        fs = p.shift();
                        x1 = cpx;
                        y1 = cpy;
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'A';
                        points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
                        break;
                }
                ca.push({
                    command: cmd || c,
                    points: points,
                    start: {
                        x: startX,
                        y: startY,
                    },
                    pathLength: this.calcLength(startX, startY, cmd || c, points),
                });
            }
            if (c === 'z' || c === 'Z') {
                ca.push({
                    command: 'z',
                    points: [],
                    start: undefined,
                    pathLength: 0,
                });
            }
        }
        return ca;
    }
    static calcLength(x, y, cmd, points) {
        var len, p1, p2, t;
        var path = Path;
        switch (cmd) {
            case 'L':
                return path.getLineLength(x, y, points[0], points[1]);
            case 'C':
                return (0, BezierFunctions_1.getCubicArcLength)([x, points[0], points[2], points[4]], [y, points[1], points[3], points[5]], 1);
            case 'Q':
                return (0, BezierFunctions_1.getQuadraticArcLength)([x, points[0], points[2]], [y, points[1], points[3]], 1);
            case 'A':
                len = 0.0;
                var start = points[4];
                var dTheta = points[5];
                var end = points[4] + dTheta;
                var inc = Math.PI / 180.0;
                if (Math.abs(start - end) < inc) {
                    inc = Math.abs(start - end);
                }
                p1 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);
                if (dTheta < 0) {
                    for (t = start - inc; t > end; t -= inc) {
                        p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
                        len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                        p1 = p2;
                    }
                }
                else {
                    for (t = start + inc; t < end; t += inc) {
                        p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
                        len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                        p1 = p2;
                    }
                }
                p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);
                len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                return len;
        }
        return 0;
    }
    static convertEndpointToCenterParameterization(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg) {
        var psi = psiDeg * (Math.PI / 180.0);
        var xp = (Math.cos(psi) * (x1 - x2)) / 2.0 + (Math.sin(psi) * (y1 - y2)) / 2.0;
        var yp = (-1 * Math.sin(psi) * (x1 - x2)) / 2.0 +
            (Math.cos(psi) * (y1 - y2)) / 2.0;
        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);
        if (lambda > 1) {
            rx *= Math.sqrt(lambda);
            ry *= Math.sqrt(lambda);
        }
        var f = Math.sqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) /
            (rx * rx * (yp * yp) + ry * ry * (xp * xp)));
        if (fa === fs) {
            f *= -1;
        }
        if (isNaN(f)) {
            f = 0;
        }
        var cxp = (f * rx * yp) / ry;
        var cyp = (f * -ry * xp) / rx;
        var cx = (x1 + x2) / 2.0 + Math.cos(psi) * cxp - Math.sin(psi) * cyp;
        var cy = (y1 + y2) / 2.0 + Math.sin(psi) * cxp + Math.cos(psi) * cyp;
        var vMag = function (v) {
            return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
        };
        var vRatio = function (u, v) {
            return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
        };
        var vAngle = function (u, v) {
            return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
        };
        var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
        var u = [(xp - cxp) / rx, (yp - cyp) / ry];
        var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
        var dTheta = vAngle(u, v);
        if (vRatio(u, v) <= -1) {
            dTheta = Math.PI;
        }
        if (vRatio(u, v) >= 1) {
            dTheta = 0;
        }
        if (fs === 0 && dTheta > 0) {
            dTheta = dTheta - 2 * Math.PI;
        }
        if (fs === 1 && dTheta < 0) {
            dTheta = dTheta + 2 * Math.PI;
        }
        return [cx, cy, rx, ry, theta, dTheta, psi, fs];
    }
}
Path$1.Path = Path;
Path.prototype.className = 'Path';
Path.prototype._attrsAffectingSize = ['data'];
(0, Global_1$e._registerNode)(Path);
Factory_1$t.Factory.addGetterSetter(Path, 'data');

Object.defineProperty(Arrow$1, "__esModule", { value: true });
Arrow$1.Arrow = void 0;
const Factory_1$s = Factory;
const Line_1$1 = Line$3;
const Validators_1$s = Validators;
const Global_1$d = Global;
const Path_1$2 = Path$1;
class Arrow extends Line_1$1.Line {
    _sceneFunc(ctx) {
        super._sceneFunc(ctx);
        var PI2 = Math.PI * 2;
        var points = this.points();
        var tp = points;
        var fromTension = this.tension() !== 0 && points.length > 4;
        if (fromTension) {
            tp = this.getTensionPoints();
        }
        var length = this.pointerLength();
        var n = points.length;
        var dx, dy;
        if (fromTension) {
            const lp = [
                tp[tp.length - 4],
                tp[tp.length - 3],
                tp[tp.length - 2],
                tp[tp.length - 1],
                points[n - 2],
                points[n - 1],
            ];
            const lastLength = Path_1$2.Path.calcLength(tp[tp.length - 4], tp[tp.length - 3], 'C', lp);
            const previous = Path_1$2.Path.getPointOnQuadraticBezier(Math.min(1, 1 - length / lastLength), lp[0], lp[1], lp[2], lp[3], lp[4], lp[5]);
            dx = points[n - 2] - previous.x;
            dy = points[n - 1] - previous.y;
        }
        else {
            dx = points[n - 2] - points[n - 4];
            dy = points[n - 1] - points[n - 3];
        }
        var radians = (Math.atan2(dy, dx) + PI2) % PI2;
        var width = this.pointerWidth();
        if (this.pointerAtEnding()) {
            ctx.save();
            ctx.beginPath();
            ctx.translate(points[n - 2], points[n - 1]);
            ctx.rotate(radians);
            ctx.moveTo(0, 0);
            ctx.lineTo(-length, width / 2);
            ctx.lineTo(-length, -width / 2);
            ctx.closePath();
            ctx.restore();
            this.__fillStroke(ctx);
        }
        if (this.pointerAtBeginning()) {
            ctx.save();
            ctx.beginPath();
            ctx.translate(points[0], points[1]);
            if (fromTension) {
                dx = (tp[0] + tp[2]) / 2 - points[0];
                dy = (tp[1] + tp[3]) / 2 - points[1];
            }
            else {
                dx = points[2] - points[0];
                dy = points[3] - points[1];
            }
            ctx.rotate((Math.atan2(-dy, -dx) + PI2) % PI2);
            ctx.moveTo(0, 0);
            ctx.lineTo(-length, width / 2);
            ctx.lineTo(-length, -width / 2);
            ctx.closePath();
            ctx.restore();
            this.__fillStroke(ctx);
        }
    }
    __fillStroke(ctx) {
        var isDashEnabled = this.dashEnabled();
        if (isDashEnabled) {
            this.attrs.dashEnabled = false;
            ctx.setLineDash([]);
        }
        ctx.fillStrokeShape(this);
        if (isDashEnabled) {
            this.attrs.dashEnabled = true;
        }
    }
    getSelfRect() {
        const lineRect = super.getSelfRect();
        const offset = this.pointerWidth() / 2;
        return {
            x: lineRect.x - offset,
            y: lineRect.y - offset,
            width: lineRect.width + offset * 2,
            height: lineRect.height + offset * 2,
        };
    }
}
Arrow$1.Arrow = Arrow;
Arrow.prototype.className = 'Arrow';
(0, Global_1$d._registerNode)(Arrow);
Factory_1$s.Factory.addGetterSetter(Arrow, 'pointerLength', 10, (0, Validators_1$s.getNumberValidator)());
Factory_1$s.Factory.addGetterSetter(Arrow, 'pointerWidth', 10, (0, Validators_1$s.getNumberValidator)());
Factory_1$s.Factory.addGetterSetter(Arrow, 'pointerAtBeginning', false);
Factory_1$s.Factory.addGetterSetter(Arrow, 'pointerAtEnding', true);

var Circle$4 = {};

Object.defineProperty(Circle$4, "__esModule", { value: true });
Circle$4.Circle = void 0;
const Factory_1$r = Factory;
const Shape_1$c = Shape;
const Validators_1$r = Validators;
const Global_1$c = Global;
let Circle$3 = class Circle extends Shape_1$c.Shape {
    _sceneFunc(context) {
        context.beginPath();
        context.arc(0, 0, this.attrs.radius || 0, 0, Math.PI * 2, false);
        context.closePath();
        context.fillStrokeShape(this);
    }
    getWidth() {
        return this.radius() * 2;
    }
    getHeight() {
        return this.radius() * 2;
    }
    setWidth(width) {
        if (this.radius() !== width / 2) {
            this.radius(width / 2);
        }
    }
    setHeight(height) {
        if (this.radius() !== height / 2) {
            this.radius(height / 2);
        }
    }
};
Circle$4.Circle = Circle$3;
Circle$3.prototype._centroid = true;
Circle$3.prototype.className = 'Circle';
Circle$3.prototype._attrsAffectingSize = ['radius'];
(0, Global_1$c._registerNode)(Circle$3);
Factory_1$r.Factory.addGetterSetter(Circle$3, 'radius', 0, (0, Validators_1$r.getNumberValidator)());

var Ellipse$1 = {};

Object.defineProperty(Ellipse$1, "__esModule", { value: true });
Ellipse$1.Ellipse = void 0;
const Factory_1$q = Factory;
const Shape_1$b = Shape;
const Validators_1$q = Validators;
const Global_1$b = Global;
class Ellipse extends Shape_1$b.Shape {
    _sceneFunc(context) {
        var rx = this.radiusX(), ry = this.radiusY();
        context.beginPath();
        context.save();
        if (rx !== ry) {
            context.scale(1, ry / rx);
        }
        context.arc(0, 0, rx, 0, Math.PI * 2, false);
        context.restore();
        context.closePath();
        context.fillStrokeShape(this);
    }
    getWidth() {
        return this.radiusX() * 2;
    }
    getHeight() {
        return this.radiusY() * 2;
    }
    setWidth(width) {
        this.radiusX(width / 2);
    }
    setHeight(height) {
        this.radiusY(height / 2);
    }
}
Ellipse$1.Ellipse = Ellipse;
Ellipse.prototype.className = 'Ellipse';
Ellipse.prototype._centroid = true;
Ellipse.prototype._attrsAffectingSize = ['radiusX', 'radiusY'];
(0, Global_1$b._registerNode)(Ellipse);
Factory_1$q.Factory.addComponentsGetterSetter(Ellipse, 'radius', ['x', 'y']);
Factory_1$q.Factory.addGetterSetter(Ellipse, 'radiusX', 0, (0, Validators_1$q.getNumberValidator)());
Factory_1$q.Factory.addGetterSetter(Ellipse, 'radiusY', 0, (0, Validators_1$q.getNumberValidator)());

var Image$3 = {};

Object.defineProperty(Image$3, "__esModule", { value: true });
Image$3.Image = void 0;
const Util_1$7 = Util;
const Factory_1$p = Factory;
const Shape_1$a = Shape;
const Global_1$a = Global;
const Validators_1$p = Validators;
let Image$2 = class Image extends Shape_1$a.Shape {
    constructor(attrs) {
        super(attrs);
        this.on('imageChange.konva', () => {
            this._setImageLoad();
        });
        this._setImageLoad();
    }
    _setImageLoad() {
        const image = this.image();
        if (image && image.complete) {
            return;
        }
        if (image && image.readyState === 4) {
            return;
        }
        if (image && image['addEventListener']) {
            image['addEventListener']('load', () => {
                this._requestDraw();
            });
        }
    }
    _useBufferCanvas() {
        return super._useBufferCanvas(true);
    }
    _sceneFunc(context) {
        const width = this.getWidth();
        const height = this.getHeight();
        const cornerRadius = this.cornerRadius();
        const image = this.attrs.image;
        let params;
        if (image) {
            const cropWidth = this.attrs.cropWidth;
            const cropHeight = this.attrs.cropHeight;
            if (cropWidth && cropHeight) {
                params = [
                    image,
                    this.cropX(),
                    this.cropY(),
                    cropWidth,
                    cropHeight,
                    0,
                    0,
                    width,
                    height,
                ];
            }
            else {
                params = [image, 0, 0, width, height];
            }
        }
        if (this.hasFill() || this.hasStroke() || cornerRadius) {
            context.beginPath();
            cornerRadius
                ? Util_1$7.Util.drawRoundedRectPath(context, width, height, cornerRadius)
                : context.rect(0, 0, width, height);
            context.closePath();
            context.fillStrokeShape(this);
        }
        if (image) {
            if (cornerRadius) {
                context.clip();
            }
            context.drawImage.apply(context, params);
        }
    }
    _hitFunc(context) {
        var width = this.width(), height = this.height(), cornerRadius = this.cornerRadius();
        context.beginPath();
        if (!cornerRadius) {
            context.rect(0, 0, width, height);
        }
        else {
            Util_1$7.Util.drawRoundedRectPath(context, width, height, cornerRadius);
        }
        context.closePath();
        context.fillStrokeShape(this);
    }
    getWidth() {
        var _a, _b;
        return (_a = this.attrs.width) !== null && _a !== void 0 ? _a : (_b = this.image()) === null || _b === void 0 ? void 0 : _b.width;
    }
    getHeight() {
        var _a, _b;
        return (_a = this.attrs.height) !== null && _a !== void 0 ? _a : (_b = this.image()) === null || _b === void 0 ? void 0 : _b.height;
    }
    static fromURL(url, callback, onError = null) {
        var img = Util_1$7.Util.createImageElement();
        img.onload = function () {
            var image = new Image({
                image: img,
            });
            callback(image);
        };
        img.onerror = onError;
        img.crossOrigin = 'Anonymous';
        img.src = url;
    }
};
Image$3.Image = Image$2;
Image$2.prototype.className = 'Image';
(0, Global_1$a._registerNode)(Image$2);
Factory_1$p.Factory.addGetterSetter(Image$2, 'cornerRadius', 0, (0, Validators_1$p.getNumberOrArrayOfNumbersValidator)(4));
Factory_1$p.Factory.addGetterSetter(Image$2, 'image');
Factory_1$p.Factory.addComponentsGetterSetter(Image$2, 'crop', ['x', 'y', 'width', 'height']);
Factory_1$p.Factory.addGetterSetter(Image$2, 'cropX', 0, (0, Validators_1$p.getNumberValidator)());
Factory_1$p.Factory.addGetterSetter(Image$2, 'cropY', 0, (0, Validators_1$p.getNumberValidator)());
Factory_1$p.Factory.addGetterSetter(Image$2, 'cropWidth', 0, (0, Validators_1$p.getNumberValidator)());
Factory_1$p.Factory.addGetterSetter(Image$2, 'cropHeight', 0, (0, Validators_1$p.getNumberValidator)());

var Label$1 = {};

Object.defineProperty(Label$1, "__esModule", { value: true });
Label$1.Tag = Label$1.Label = void 0;
const Factory_1$o = Factory;
const Shape_1$9 = Shape;
const Group_1$1 = Group$2;
const Validators_1$o = Validators;
const Global_1$9 = Global;
var ATTR_CHANGE_LIST$2 = [
    'fontFamily',
    'fontSize',
    'fontStyle',
    'padding',
    'lineHeight',
    'text',
    'width',
    'height',
    'pointerDirection',
    'pointerWidth',
    'pointerHeight',
], CHANGE_KONVA$1 = 'Change.konva', NONE$1 = 'none', UP = 'up', RIGHT$1 = 'right', DOWN = 'down', LEFT$2 = 'left', attrChangeListLen$1 = ATTR_CHANGE_LIST$2.length;
class Label extends Group_1$1.Group {
    constructor(config) {
        super(config);
        this.on('add.konva', function (evt) {
            this._addListeners(evt.child);
            this._sync();
        });
    }
    getText() {
        return this.find('Text')[0];
    }
    getTag() {
        return this.find('Tag')[0];
    }
    _addListeners(text) {
        var that = this, n;
        var func = function () {
            that._sync();
        };
        for (n = 0; n < attrChangeListLen$1; n++) {
            text.on(ATTR_CHANGE_LIST$2[n] + CHANGE_KONVA$1, func);
        }
    }
    getWidth() {
        return this.getText().width();
    }
    getHeight() {
        return this.getText().height();
    }
    _sync() {
        var text = this.getText(), tag = this.getTag(), width, height, pointerDirection, pointerWidth, x, y, pointerHeight;
        if (text && tag) {
            width = text.width();
            height = text.height();
            pointerDirection = tag.pointerDirection();
            pointerWidth = tag.pointerWidth();
            pointerHeight = tag.pointerHeight();
            x = 0;
            y = 0;
            switch (pointerDirection) {
                case UP:
                    x = width / 2;
                    y = -1 * pointerHeight;
                    break;
                case RIGHT$1:
                    x = width + pointerWidth;
                    y = height / 2;
                    break;
                case DOWN:
                    x = width / 2;
                    y = height + pointerHeight;
                    break;
                case LEFT$2:
                    x = -1 * pointerWidth;
                    y = height / 2;
                    break;
            }
            tag.setAttrs({
                x: -1 * x,
                y: -1 * y,
                width: width,
                height: height,
            });
            text.setAttrs({
                x: -1 * x,
                y: -1 * y,
            });
        }
    }
}
Label$1.Label = Label;
Label.prototype.className = 'Label';
(0, Global_1$9._registerNode)(Label);
class Tag extends Shape_1$9.Shape {
    _sceneFunc(context) {
        var width = this.width(), height = this.height(), pointerDirection = this.pointerDirection(), pointerWidth = this.pointerWidth(), pointerHeight = this.pointerHeight(), cornerRadius = this.cornerRadius();
        let topLeft = 0;
        let topRight = 0;
        let bottomLeft = 0;
        let bottomRight = 0;
        if (typeof cornerRadius === 'number') {
            topLeft =
                topRight =
                    bottomLeft =
                        bottomRight =
                            Math.min(cornerRadius, width / 2, height / 2);
        }
        else {
            topLeft = Math.min(cornerRadius[0] || 0, width / 2, height / 2);
            topRight = Math.min(cornerRadius[1] || 0, width / 2, height / 2);
            bottomRight = Math.min(cornerRadius[2] || 0, width / 2, height / 2);
            bottomLeft = Math.min(cornerRadius[3] || 0, width / 2, height / 2);
        }
        context.beginPath();
        context.moveTo(topLeft, 0);
        if (pointerDirection === UP) {
            context.lineTo((width - pointerWidth) / 2, 0);
            context.lineTo(width / 2, -1 * pointerHeight);
            context.lineTo((width + pointerWidth) / 2, 0);
        }
        context.lineTo(width - topRight, 0);
        context.arc(width - topRight, topRight, topRight, (Math.PI * 3) / 2, 0, false);
        if (pointerDirection === RIGHT$1) {
            context.lineTo(width, (height - pointerHeight) / 2);
            context.lineTo(width + pointerWidth, height / 2);
            context.lineTo(width, (height + pointerHeight) / 2);
        }
        context.lineTo(width, height - bottomRight);
        context.arc(width - bottomRight, height - bottomRight, bottomRight, 0, Math.PI / 2, false);
        if (pointerDirection === DOWN) {
            context.lineTo((width + pointerWidth) / 2, height);
            context.lineTo(width / 2, height + pointerHeight);
            context.lineTo((width - pointerWidth) / 2, height);
        }
        context.lineTo(bottomLeft, height);
        context.arc(bottomLeft, height - bottomLeft, bottomLeft, Math.PI / 2, Math.PI, false);
        if (pointerDirection === LEFT$2) {
            context.lineTo(0, (height + pointerHeight) / 2);
            context.lineTo(-1 * pointerWidth, height / 2);
            context.lineTo(0, (height - pointerHeight) / 2);
        }
        context.lineTo(0, topLeft);
        context.arc(topLeft, topLeft, topLeft, Math.PI, (Math.PI * 3) / 2, false);
        context.closePath();
        context.fillStrokeShape(this);
    }
    getSelfRect() {
        var x = 0, y = 0, pointerWidth = this.pointerWidth(), pointerHeight = this.pointerHeight(), direction = this.pointerDirection(), width = this.width(), height = this.height();
        if (direction === UP) {
            y -= pointerHeight;
            height += pointerHeight;
        }
        else if (direction === DOWN) {
            height += pointerHeight;
        }
        else if (direction === LEFT$2) {
            x -= pointerWidth * 1.5;
            width += pointerWidth;
        }
        else if (direction === RIGHT$1) {
            width += pointerWidth * 1.5;
        }
        return {
            x: x,
            y: y,
            width: width,
            height: height,
        };
    }
}
Label$1.Tag = Tag;
Tag.prototype.className = 'Tag';
(0, Global_1$9._registerNode)(Tag);
Factory_1$o.Factory.addGetterSetter(Tag, 'pointerDirection', NONE$1);
Factory_1$o.Factory.addGetterSetter(Tag, 'pointerWidth', 0, (0, Validators_1$o.getNumberValidator)());
Factory_1$o.Factory.addGetterSetter(Tag, 'pointerHeight', 0, (0, Validators_1$o.getNumberValidator)());
Factory_1$o.Factory.addGetterSetter(Tag, 'cornerRadius', 0, (0, Validators_1$o.getNumberOrArrayOfNumbersValidator)(4));

var Rect$1 = {};

Object.defineProperty(Rect$1, "__esModule", { value: true });
var Rect_2 = Rect$1.Rect = void 0;
const Factory_1$n = Factory;
const Shape_1$8 = Shape;
const Global_1$8 = Global;
const Util_1$6 = Util;
const Validators_1$n = Validators;
class Rect extends Shape_1$8.Shape {
    _sceneFunc(context) {
        var cornerRadius = this.cornerRadius(), width = this.width(), height = this.height();
        context.beginPath();
        if (!cornerRadius) {
            context.rect(0, 0, width, height);
        }
        else {
            Util_1$6.Util.drawRoundedRectPath(context, width, height, cornerRadius);
        }
        context.closePath();
        context.fillStrokeShape(this);
    }
}
Rect_2 = Rect$1.Rect = Rect;
Rect.prototype.className = 'Rect';
(0, Global_1$8._registerNode)(Rect);
Factory_1$n.Factory.addGetterSetter(Rect, 'cornerRadius', 0, (0, Validators_1$n.getNumberOrArrayOfNumbersValidator)(4));

var RegularPolygon$1 = {};

Object.defineProperty(RegularPolygon$1, "__esModule", { value: true });
RegularPolygon$1.RegularPolygon = void 0;
const Factory_1$m = Factory;
const Shape_1$7 = Shape;
const Validators_1$m = Validators;
const Global_1$7 = Global;
class RegularPolygon extends Shape_1$7.Shape {
    _sceneFunc(context) {
        const points = this._getPoints();
        context.beginPath();
        context.moveTo(points[0].x, points[0].y);
        for (var n = 1; n < points.length; n++) {
            context.lineTo(points[n].x, points[n].y);
        }
        context.closePath();
        context.fillStrokeShape(this);
    }
    _getPoints() {
        const sides = this.attrs.sides;
        const radius = this.attrs.radius || 0;
        const points = [];
        for (var n = 0; n < sides; n++) {
            points.push({
                x: radius * Math.sin((n * 2 * Math.PI) / sides),
                y: -1 * radius * Math.cos((n * 2 * Math.PI) / sides),
            });
        }
        return points;
    }
    getSelfRect() {
        const points = this._getPoints();
        var minX = points[0].x;
        var maxX = points[0].y;
        var minY = points[0].x;
        var maxY = points[0].y;
        points.forEach((point) => {
            minX = Math.min(minX, point.x);
            maxX = Math.max(maxX, point.x);
            minY = Math.min(minY, point.y);
            maxY = Math.max(maxY, point.y);
        });
        return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY,
        };
    }
    getWidth() {
        return this.radius() * 2;
    }
    getHeight() {
        return this.radius() * 2;
    }
    setWidth(width) {
        this.radius(width / 2);
    }
    setHeight(height) {
        this.radius(height / 2);
    }
}
RegularPolygon$1.RegularPolygon = RegularPolygon;
RegularPolygon.prototype.className = 'RegularPolygon';
RegularPolygon.prototype._centroid = true;
RegularPolygon.prototype._attrsAffectingSize = ['radius'];
(0, Global_1$7._registerNode)(RegularPolygon);
Factory_1$m.Factory.addGetterSetter(RegularPolygon, 'radius', 0, (0, Validators_1$m.getNumberValidator)());
Factory_1$m.Factory.addGetterSetter(RegularPolygon, 'sides', 0, (0, Validators_1$m.getNumberValidator)());

var Ring$1 = {};

Object.defineProperty(Ring$1, "__esModule", { value: true });
Ring$1.Ring = void 0;
const Factory_1$l = Factory;
const Shape_1$6 = Shape;
const Validators_1$l = Validators;
const Global_1$6 = Global;
var PIx2 = Math.PI * 2;
class Ring extends Shape_1$6.Shape {
    _sceneFunc(context) {
        context.beginPath();
        context.arc(0, 0, this.innerRadius(), 0, PIx2, false);
        context.moveTo(this.outerRadius(), 0);
        context.arc(0, 0, this.outerRadius(), PIx2, 0, true);
        context.closePath();
        context.fillStrokeShape(this);
    }
    getWidth() {
        return this.outerRadius() * 2;
    }
    getHeight() {
        return this.outerRadius() * 2;
    }
    setWidth(width) {
        this.outerRadius(width / 2);
    }
    setHeight(height) {
        this.outerRadius(height / 2);
    }
}
Ring$1.Ring = Ring;
Ring.prototype.className = 'Ring';
Ring.prototype._centroid = true;
Ring.prototype._attrsAffectingSize = ['innerRadius', 'outerRadius'];
(0, Global_1$6._registerNode)(Ring);
Factory_1$l.Factory.addGetterSetter(Ring, 'innerRadius', 0, (0, Validators_1$l.getNumberValidator)());
Factory_1$l.Factory.addGetterSetter(Ring, 'outerRadius', 0, (0, Validators_1$l.getNumberValidator)());

var Sprite$1 = {};

Object.defineProperty(Sprite$1, "__esModule", { value: true });
Sprite$1.Sprite = void 0;
const Factory_1$k = Factory;
const Shape_1$5 = Shape;
const Animation_1 = Animation$1;
const Validators_1$k = Validators;
const Global_1$5 = Global;
class Sprite extends Shape_1$5.Shape {
    constructor(config) {
        super(config);
        this._updated = true;
        this.anim = new Animation_1.Animation(() => {
            var updated = this._updated;
            this._updated = false;
            return updated;
        });
        this.on('animationChange.konva', function () {
            this.frameIndex(0);
        });
        this.on('frameIndexChange.konva', function () {
            this._updated = true;
        });
        this.on('frameRateChange.konva', function () {
            if (!this.anim.isRunning()) {
                return;
            }
            clearInterval(this.interval);
            this._setInterval();
        });
    }
    _sceneFunc(context) {
        var anim = this.animation(), index = this.frameIndex(), ix4 = index * 4, set = this.animations()[anim], offsets = this.frameOffsets(), x = set[ix4 + 0], y = set[ix4 + 1], width = set[ix4 + 2], height = set[ix4 + 3], image = this.image();
        if (this.hasFill() || this.hasStroke()) {
            context.beginPath();
            context.rect(0, 0, width, height);
            context.closePath();
            context.fillStrokeShape(this);
        }
        if (image) {
            if (offsets) {
                var offset = offsets[anim], ix2 = index * 2;
                context.drawImage(image, x, y, width, height, offset[ix2 + 0], offset[ix2 + 1], width, height);
            }
            else {
                context.drawImage(image, x, y, width, height, 0, 0, width, height);
            }
        }
    }
    _hitFunc(context) {
        var anim = this.animation(), index = this.frameIndex(), ix4 = index * 4, set = this.animations()[anim], offsets = this.frameOffsets(), width = set[ix4 + 2], height = set[ix4 + 3];
        context.beginPath();
        if (offsets) {
            var offset = offsets[anim];
            var ix2 = index * 2;
            context.rect(offset[ix2 + 0], offset[ix2 + 1], width, height);
        }
        else {
            context.rect(0, 0, width, height);
        }
        context.closePath();
        context.fillShape(this);
    }
    _useBufferCanvas() {
        return super._useBufferCanvas(true);
    }
    _setInterval() {
        var that = this;
        this.interval = setInterval(function () {
            that._updateIndex();
        }, 1000 / this.frameRate());
    }
    start() {
        if (this.isRunning()) {
            return;
        }
        var layer = this.getLayer();
        this.anim.setLayers(layer);
        this._setInterval();
        this.anim.start();
    }
    stop() {
        this.anim.stop();
        clearInterval(this.interval);
    }
    isRunning() {
        return this.anim.isRunning();
    }
    _updateIndex() {
        var index = this.frameIndex(), animation = this.animation(), animations = this.animations(), anim = animations[animation], len = anim.length / 4;
        if (index < len - 1) {
            this.frameIndex(index + 1);
        }
        else {
            this.frameIndex(0);
        }
    }
}
Sprite$1.Sprite = Sprite;
Sprite.prototype.className = 'Sprite';
(0, Global_1$5._registerNode)(Sprite);
Factory_1$k.Factory.addGetterSetter(Sprite, 'animation');
Factory_1$k.Factory.addGetterSetter(Sprite, 'animations');
Factory_1$k.Factory.addGetterSetter(Sprite, 'frameOffsets');
Factory_1$k.Factory.addGetterSetter(Sprite, 'image');
Factory_1$k.Factory.addGetterSetter(Sprite, 'frameIndex', 0, (0, Validators_1$k.getNumberValidator)());
Factory_1$k.Factory.addGetterSetter(Sprite, 'frameRate', 17, (0, Validators_1$k.getNumberValidator)());
Factory_1$k.Factory.backCompat(Sprite, {
    index: 'frameIndex',
    getIndex: 'getFrameIndex',
    setIndex: 'setFrameIndex',
});

var Star$1 = {};

Object.defineProperty(Star$1, "__esModule", { value: true });
Star$1.Star = void 0;
const Factory_1$j = Factory;
const Shape_1$4 = Shape;
const Validators_1$j = Validators;
const Global_1$4 = Global;
class Star extends Shape_1$4.Shape {
    _sceneFunc(context) {
        var innerRadius = this.innerRadius(), outerRadius = this.outerRadius(), numPoints = this.numPoints();
        context.beginPath();
        context.moveTo(0, 0 - outerRadius);
        for (var n = 1; n < numPoints * 2; n++) {
            var radius = n % 2 === 0 ? outerRadius : innerRadius;
            var x = radius * Math.sin((n * Math.PI) / numPoints);
            var y = -1 * radius * Math.cos((n * Math.PI) / numPoints);
            context.lineTo(x, y);
        }
        context.closePath();
        context.fillStrokeShape(this);
    }
    getWidth() {
        return this.outerRadius() * 2;
    }
    getHeight() {
        return this.outerRadius() * 2;
    }
    setWidth(width) {
        this.outerRadius(width / 2);
    }
    setHeight(height) {
        this.outerRadius(height / 2);
    }
}
Star$1.Star = Star;
Star.prototype.className = 'Star';
Star.prototype._centroid = true;
Star.prototype._attrsAffectingSize = ['innerRadius', 'outerRadius'];
(0, Global_1$4._registerNode)(Star);
Factory_1$j.Factory.addGetterSetter(Star, 'numPoints', 5, (0, Validators_1$j.getNumberValidator)());
Factory_1$j.Factory.addGetterSetter(Star, 'innerRadius', 0, (0, Validators_1$j.getNumberValidator)());
Factory_1$j.Factory.addGetterSetter(Star, 'outerRadius', 0, (0, Validators_1$j.getNumberValidator)());

var Text$1 = {};

Object.defineProperty(Text$1, "__esModule", { value: true });
Text$1.Text = Text$1.stringToArray = void 0;
const Util_1$5 = Util;
const Factory_1$i = Factory;
const Shape_1$3 = Shape;
const Validators_1$i = Validators;
const Global_1$3 = Global;
function stringToArray$2(string) {
    return Array.from(string);
}
Text$1.stringToArray = stringToArray$2;
var AUTO = 'auto', CENTER = 'center', JUSTIFY = 'justify', CHANGE_KONVA = 'Change.konva', CONTEXT_2D = '2d', DASH = '-', LEFT$1 = 'left', TEXT = 'text', TEXT_UPPER = 'Text', TOP = 'top', BOTTOM = 'bottom', MIDDLE = 'middle', NORMAL$1 = 'normal', PX_SPACE = 'px ', SPACE = ' ', RIGHT = 'right', WORD = 'word', CHAR = 'char', NONE = 'none', ELLIPSIS = '…', ATTR_CHANGE_LIST$1 = [
    'fontFamily',
    'fontSize',
    'fontStyle',
    'fontVariant',
    'padding',
    'align',
    'verticalAlign',
    'lineHeight',
    'text',
    'width',
    'height',
    'wrap',
    'ellipsis',
    'letterSpacing',
], attrChangeListLen = ATTR_CHANGE_LIST$1.length;
function normalizeFontFamily(fontFamily) {
    return fontFamily
        .split(',')
        .map((family) => {
        family = family.trim();
        const hasSpace = family.indexOf(' ') >= 0;
        const hasQuotes = family.indexOf('"') >= 0 || family.indexOf("'") >= 0;
        if (hasSpace && !hasQuotes) {
            family = `"${family}"`;
        }
        return family;
    })
        .join(', ');
}
var dummyContext;
function getDummyContext() {
    if (dummyContext) {
        return dummyContext;
    }
    dummyContext = Util_1$5.Util.createCanvasElement().getContext(CONTEXT_2D);
    return dummyContext;
}
function _fillFunc$1(context) {
    context.fillText(this._partialText, this._partialTextX, this._partialTextY);
}
function _strokeFunc$1(context) {
    context.setAttr('miterLimit', 2);
    context.strokeText(this._partialText, this._partialTextX, this._partialTextY);
}
function checkDefaultFill(config) {
    config = config || {};
    if (!config.fillLinearGradientColorStops &&
        !config.fillRadialGradientColorStops &&
        !config.fillPatternImage) {
        config.fill = config.fill || 'black';
    }
    return config;
}
class Text extends Shape_1$3.Shape {
    constructor(config) {
        super(checkDefaultFill(config));
        this._partialTextX = 0;
        this._partialTextY = 0;
        for (var n = 0; n < attrChangeListLen; n++) {
            this.on(ATTR_CHANGE_LIST$1[n] + CHANGE_KONVA, this._setTextData);
        }
        this._setTextData();
    }
    _sceneFunc(context) {
        var textArr = this.textArr, textArrLen = textArr.length;
        if (!this.text()) {
            return;
        }
        var padding = this.padding(), fontSize = this.fontSize(), lineHeightPx = this.lineHeight() * fontSize, verticalAlign = this.verticalAlign(), alignY = 0, align = this.align(), totalWidth = this.getWidth(), letterSpacing = this.letterSpacing(), fill = this.fill(), textDecoration = this.textDecoration(), shouldUnderline = textDecoration.indexOf('underline') !== -1, shouldLineThrough = textDecoration.indexOf('line-through') !== -1, n;
        var translateY = 0;
        var translateY = lineHeightPx / 2;
        var lineTranslateX = 0;
        var lineTranslateY = 0;
        context.setAttr('font', this._getContextFont());
        context.setAttr('textBaseline', MIDDLE);
        context.setAttr('textAlign', LEFT$1);
        if (verticalAlign === MIDDLE) {
            alignY = (this.getHeight() - textArrLen * lineHeightPx - padding * 2) / 2;
        }
        else if (verticalAlign === BOTTOM) {
            alignY = this.getHeight() - textArrLen * lineHeightPx - padding * 2;
        }
        context.translate(padding, alignY + padding);
        for (n = 0; n < textArrLen; n++) {
            var lineTranslateX = 0;
            var lineTranslateY = 0;
            var obj = textArr[n], text = obj.text, width = obj.width, lastLine = obj.lastInParagraph, spacesNumber, oneWord, lineWidth;
            context.save();
            if (align === RIGHT) {
                lineTranslateX += totalWidth - width - padding * 2;
            }
            else if (align === CENTER) {
                lineTranslateX += (totalWidth - width - padding * 2) / 2;
            }
            if (shouldUnderline) {
                context.save();
                context.beginPath();
                context.moveTo(lineTranslateX, translateY + lineTranslateY + Math.round(fontSize / 2));
                spacesNumber = text.split(' ').length - 1;
                oneWord = spacesNumber === 0;
                lineWidth =
                    align === JUSTIFY && !lastLine ? totalWidth - padding * 2 : width;
                context.lineTo(lineTranslateX + Math.round(lineWidth), translateY + lineTranslateY + Math.round(fontSize / 2));
                context.lineWidth = fontSize / 15;
                const gradient = this._getLinearGradient();
                context.strokeStyle = gradient || fill;
                context.stroke();
                context.restore();
            }
            if (shouldLineThrough) {
                context.save();
                context.beginPath();
                context.moveTo(lineTranslateX, translateY + lineTranslateY);
                spacesNumber = text.split(' ').length - 1;
                oneWord = spacesNumber === 0;
                lineWidth =
                    align === JUSTIFY && lastLine && !oneWord
                        ? totalWidth - padding * 2
                        : width;
                context.lineTo(lineTranslateX + Math.round(lineWidth), translateY + lineTranslateY);
                context.lineWidth = fontSize / 15;
                const gradient = this._getLinearGradient();
                context.strokeStyle = gradient || fill;
                context.stroke();
                context.restore();
            }
            if (letterSpacing !== 0 || align === JUSTIFY) {
                spacesNumber = text.split(' ').length - 1;
                var array = stringToArray$2(text);
                for (var li = 0; li < array.length; li++) {
                    var letter = array[li];
                    if (letter === ' ' && !lastLine && align === JUSTIFY) {
                        lineTranslateX += (totalWidth - padding * 2 - width) / spacesNumber;
                    }
                    this._partialTextX = lineTranslateX;
                    this._partialTextY = translateY + lineTranslateY;
                    this._partialText = letter;
                    context.fillStrokeShape(this);
                    lineTranslateX += this.measureSize(letter).width + letterSpacing;
                }
            }
            else {
                this._partialTextX = lineTranslateX;
                this._partialTextY = translateY + lineTranslateY;
                this._partialText = text;
                context.fillStrokeShape(this);
            }
            context.restore();
            if (textArrLen > 1) {
                translateY += lineHeightPx;
            }
        }
    }
    _hitFunc(context) {
        var width = this.getWidth(), height = this.getHeight();
        context.beginPath();
        context.rect(0, 0, width, height);
        context.closePath();
        context.fillStrokeShape(this);
    }
    setText(text) {
        var str = Util_1$5.Util._isString(text)
            ? text
            : text === null || text === undefined
                ? ''
                : text + '';
        this._setAttr(TEXT, str);
        return this;
    }
    getWidth() {
        var isAuto = this.attrs.width === AUTO || this.attrs.width === undefined;
        return isAuto ? this.getTextWidth() + this.padding() * 2 : this.attrs.width;
    }
    getHeight() {
        var isAuto = this.attrs.height === AUTO || this.attrs.height === undefined;
        return isAuto
            ? this.fontSize() * this.textArr.length * this.lineHeight() +
                this.padding() * 2
            : this.attrs.height;
    }
    getTextWidth() {
        return this.textWidth;
    }
    getTextHeight() {
        Util_1$5.Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');
        return this.textHeight;
    }
    measureSize(text) {
        var _context = getDummyContext(), fontSize = this.fontSize(), metrics;
        _context.save();
        _context.font = this._getContextFont();
        metrics = _context.measureText(text);
        _context.restore();
        return {
            width: metrics.width,
            height: fontSize,
        };
    }
    _getContextFont() {
        return (this.fontStyle() +
            SPACE +
            this.fontVariant() +
            SPACE +
            (this.fontSize() + PX_SPACE) +
            normalizeFontFamily(this.fontFamily()));
    }
    _addTextLine(line) {
        const align = this.align();
        if (align === JUSTIFY) {
            line = line.trim();
        }
        var width = this._getTextWidth(line);
        return this.textArr.push({
            text: line,
            width: width,
            lastInParagraph: false,
        });
    }
    _getTextWidth(text) {
        var letterSpacing = this.letterSpacing();
        var length = text.length;
        return (getDummyContext().measureText(text).width +
            (length ? letterSpacing * (length - 1) : 0));
    }
    _setTextData() {
        var lines = this.text().split('\n'), fontSize = +this.fontSize(), textWidth = 0, lineHeightPx = this.lineHeight() * fontSize, width = this.attrs.width, height = this.attrs.height, fixedWidth = width !== AUTO && width !== undefined, fixedHeight = height !== AUTO && height !== undefined, padding = this.padding(), maxWidth = width - padding * 2, maxHeightPx = height - padding * 2, currentHeightPx = 0, wrap = this.wrap(), shouldWrap = wrap !== NONE, wrapAtWord = wrap !== CHAR && shouldWrap, shouldAddEllipsis = this.ellipsis();
        this.textArr = [];
        getDummyContext().font = this._getContextFont();
        var additionalWidth = shouldAddEllipsis ? this._getTextWidth(ELLIPSIS) : 0;
        for (var i = 0, max = lines.length; i < max; ++i) {
            var line = lines[i];
            var lineWidth = this._getTextWidth(line);
            if (fixedWidth && lineWidth > maxWidth) {
                while (line.length > 0) {
                    var low = 0, high = line.length, match = '', matchWidth = 0;
                    while (low < high) {
                        var mid = (low + high) >>> 1, substr = line.slice(0, mid + 1), substrWidth = this._getTextWidth(substr) + additionalWidth;
                        if (substrWidth <= maxWidth) {
                            low = mid + 1;
                            match = substr;
                            matchWidth = substrWidth;
                        }
                        else {
                            high = mid;
                        }
                    }
                    if (match) {
                        if (wrapAtWord) {
                            var wrapIndex;
                            var nextChar = line[match.length];
                            var nextIsSpaceOrDash = nextChar === SPACE || nextChar === DASH;
                            if (nextIsSpaceOrDash && matchWidth <= maxWidth) {
                                wrapIndex = match.length;
                            }
                            else {
                                wrapIndex =
                                    Math.max(match.lastIndexOf(SPACE), match.lastIndexOf(DASH)) +
                                        1;
                            }
                            if (wrapIndex > 0) {
                                low = wrapIndex;
                                match = match.slice(0, low);
                                matchWidth = this._getTextWidth(match);
                            }
                        }
                        match = match.trimRight();
                        this._addTextLine(match);
                        textWidth = Math.max(textWidth, matchWidth);
                        currentHeightPx += lineHeightPx;
                        var shouldHandleEllipsis = this._shouldHandleEllipsis(currentHeightPx);
                        if (shouldHandleEllipsis) {
                            this._tryToAddEllipsisToLastLine();
                            break;
                        }
                        line = line.slice(low);
                        line = line.trimLeft();
                        if (line.length > 0) {
                            lineWidth = this._getTextWidth(line);
                            if (lineWidth <= maxWidth) {
                                this._addTextLine(line);
                                currentHeightPx += lineHeightPx;
                                textWidth = Math.max(textWidth, lineWidth);
                                break;
                            }
                        }
                    }
                    else {
                        break;
                    }
                }
            }
            else {
                this._addTextLine(line);
                currentHeightPx += lineHeightPx;
                textWidth = Math.max(textWidth, lineWidth);
                if (this._shouldHandleEllipsis(currentHeightPx) && i < max - 1) {
                    this._tryToAddEllipsisToLastLine();
                }
            }
            if (this.textArr[this.textArr.length - 1]) {
                this.textArr[this.textArr.length - 1].lastInParagraph = true;
            }
            if (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx) {
                break;
            }
        }
        this.textHeight = fontSize;
        this.textWidth = textWidth;
    }
    _shouldHandleEllipsis(currentHeightPx) {
        var fontSize = +this.fontSize(), lineHeightPx = this.lineHeight() * fontSize, height = this.attrs.height, fixedHeight = height !== AUTO && height !== undefined, padding = this.padding(), maxHeightPx = height - padding * 2, wrap = this.wrap(), shouldWrap = wrap !== NONE;
        return (!shouldWrap ||
            (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx));
    }
    _tryToAddEllipsisToLastLine() {
        var width = this.attrs.width, fixedWidth = width !== AUTO && width !== undefined, padding = this.padding(), maxWidth = width - padding * 2, shouldAddEllipsis = this.ellipsis();
        var lastLine = this.textArr[this.textArr.length - 1];
        if (!lastLine || !shouldAddEllipsis) {
            return;
        }
        if (fixedWidth) {
            var haveSpace = this._getTextWidth(lastLine.text + ELLIPSIS) < maxWidth;
            if (!haveSpace) {
                lastLine.text = lastLine.text.slice(0, lastLine.text.length - 3);
            }
        }
        this.textArr.splice(this.textArr.length - 1, 1);
        this._addTextLine(lastLine.text + ELLIPSIS);
    }
    getStrokeScaleEnabled() {
        return true;
    }
}
Text$1.Text = Text;
Text.prototype._fillFunc = _fillFunc$1;
Text.prototype._strokeFunc = _strokeFunc$1;
Text.prototype.className = TEXT_UPPER;
Text.prototype._attrsAffectingSize = [
    'text',
    'fontSize',
    'padding',
    'wrap',
    'lineHeight',
    'letterSpacing',
];
(0, Global_1$3._registerNode)(Text);
Factory_1$i.Factory.overWriteSetter(Text, 'width', (0, Validators_1$i.getNumberOrAutoValidator)());
Factory_1$i.Factory.overWriteSetter(Text, 'height', (0, Validators_1$i.getNumberOrAutoValidator)());
Factory_1$i.Factory.addGetterSetter(Text, 'fontFamily', 'Arial');
Factory_1$i.Factory.addGetterSetter(Text, 'fontSize', 12, (0, Validators_1$i.getNumberValidator)());
Factory_1$i.Factory.addGetterSetter(Text, 'fontStyle', NORMAL$1);
Factory_1$i.Factory.addGetterSetter(Text, 'fontVariant', NORMAL$1);
Factory_1$i.Factory.addGetterSetter(Text, 'padding', 0, (0, Validators_1$i.getNumberValidator)());
Factory_1$i.Factory.addGetterSetter(Text, 'align', LEFT$1);
Factory_1$i.Factory.addGetterSetter(Text, 'verticalAlign', TOP);
Factory_1$i.Factory.addGetterSetter(Text, 'lineHeight', 1, (0, Validators_1$i.getNumberValidator)());
Factory_1$i.Factory.addGetterSetter(Text, 'wrap', WORD);
Factory_1$i.Factory.addGetterSetter(Text, 'ellipsis', false, (0, Validators_1$i.getBooleanValidator)());
Factory_1$i.Factory.addGetterSetter(Text, 'letterSpacing', 0, (0, Validators_1$i.getNumberValidator)());
Factory_1$i.Factory.addGetterSetter(Text, 'text', '', (0, Validators_1$i.getStringValidator)());
Factory_1$i.Factory.addGetterSetter(Text, 'textDecoration', '');

var TextPath$1 = {};

Object.defineProperty(TextPath$1, "__esModule", { value: true });
TextPath$1.TextPath = void 0;
const Util_1$4 = Util;
const Factory_1$h = Factory;
const Shape_1$2 = Shape;
const Path_1$1 = Path$1;
const Text_1$1 = Text$1;
const Validators_1$h = Validators;
const Global_1$2 = Global;
var EMPTY_STRING = '', NORMAL = 'normal';
function _fillFunc(context) {
    context.fillText(this.partialText, 0, 0);
}
function _strokeFunc(context) {
    context.strokeText(this.partialText, 0, 0);
}
class TextPath extends Shape_1$2.Shape {
    constructor(config) {
        super(config);
        this.dummyCanvas = Util_1$4.Util.createCanvasElement();
        this.dataArray = [];
        this._readDataAttribute();
        this.on('dataChange.konva', function () {
            this._readDataAttribute();
            this._setTextData();
        });
        this.on('textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva fontFamilyChange.konva', this._setTextData);
        this._setTextData();
    }
    _getTextPathLength() {
        return Path_1$1.Path.getPathLength(this.dataArray);
    }
    _getPointAtLength(length) {
        if (!this.attrs.data) {
            return null;
        }
        const totalLength = this.pathLength;
        if (length - 1 > totalLength) {
            return null;
        }
        return Path_1$1.Path.getPointAtLengthOfDataArray(length, this.dataArray);
    }
    _readDataAttribute() {
        this.dataArray = Path_1$1.Path.parsePathData(this.attrs.data);
        this.pathLength = this._getTextPathLength();
    }
    _sceneFunc(context) {
        context.setAttr('font', this._getContextFont());
        context.setAttr('textBaseline', this.textBaseline());
        context.setAttr('textAlign', 'left');
        context.save();
        var textDecoration = this.textDecoration();
        var fill = this.fill();
        var fontSize = this.fontSize();
        var glyphInfo = this.glyphInfo;
        if (textDecoration === 'underline') {
            context.beginPath();
        }
        for (var i = 0; i < glyphInfo.length; i++) {
            context.save();
            var p0 = glyphInfo[i].p0;
            context.translate(p0.x, p0.y);
            context.rotate(glyphInfo[i].rotation);
            this.partialText = glyphInfo[i].text;
            context.fillStrokeShape(this);
            if (textDecoration === 'underline') {
                if (i === 0) {
                    context.moveTo(0, fontSize / 2 + 1);
                }
                context.lineTo(fontSize, fontSize / 2 + 1);
            }
            context.restore();
        }
        if (textDecoration === 'underline') {
            context.strokeStyle = fill;
            context.lineWidth = fontSize / 20;
            context.stroke();
        }
        context.restore();
    }
    _hitFunc(context) {
        context.beginPath();
        var glyphInfo = this.glyphInfo;
        if (glyphInfo.length >= 1) {
            var p0 = glyphInfo[0].p0;
            context.moveTo(p0.x, p0.y);
        }
        for (var i = 0; i < glyphInfo.length; i++) {
            var p1 = glyphInfo[i].p1;
            context.lineTo(p1.x, p1.y);
        }
        context.setAttr('lineWidth', this.fontSize());
        context.setAttr('strokeStyle', this.colorKey);
        context.stroke();
    }
    getTextWidth() {
        return this.textWidth;
    }
    getTextHeight() {
        Util_1$4.Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');
        return this.textHeight;
    }
    setText(text) {
        return Text_1$1.Text.prototype.setText.call(this, text);
    }
    _getContextFont() {
        return Text_1$1.Text.prototype._getContextFont.call(this);
    }
    _getTextSize(text) {
        var dummyCanvas = this.dummyCanvas;
        var _context = dummyCanvas.getContext('2d');
        _context.save();
        _context.font = this._getContextFont();
        var metrics = _context.measureText(text);
        _context.restore();
        return {
            width: metrics.width,
            height: parseInt(`${this.fontSize()}`, 10),
        };
    }
    _setTextData() {
        const { width, height } = this._getTextSize(this.attrs.text);
        this.textWidth = width;
        this.textHeight = height;
        this.glyphInfo = [];
        if (!this.attrs.data) {
            return null;
        }
        const letterSpacing = this.letterSpacing();
        const align = this.align();
        const kerningFunc = this.kerningFunc();
        const textWidth = Math.max(this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing, 0);
        let offset = 0;
        if (align === 'center') {
            offset = Math.max(0, this.pathLength / 2 - textWidth / 2);
        }
        if (align === 'right') {
            offset = Math.max(0, this.pathLength - textWidth);
        }
        const charArr = (0, Text_1$1.stringToArray)(this.text());
        let offsetToGlyph = offset;
        for (var i = 0; i < charArr.length; i++) {
            const charStartPoint = this._getPointAtLength(offsetToGlyph);
            if (!charStartPoint)
                return;
            let glyphWidth = this._getTextSize(charArr[i]).width + letterSpacing;
            if (charArr[i] === ' ' && align === 'justify') {
                const numberOfSpaces = this.text().split(' ').length - 1;
                glyphWidth += (this.pathLength - textWidth) / numberOfSpaces;
            }
            const charEndPoint = this._getPointAtLength(offsetToGlyph + glyphWidth);
            if (!charEndPoint)
                return;
            const width = Path_1$1.Path.getLineLength(charStartPoint.x, charStartPoint.y, charEndPoint.x, charEndPoint.y);
            let kern = 0;
            if (kerningFunc) {
                try {
                    kern = kerningFunc(charArr[i - 1], charArr[i]) * this.fontSize();
                }
                catch (e) {
                    kern = 0;
                }
            }
            charStartPoint.x += kern;
            charEndPoint.x += kern;
            this.textWidth += kern;
            const midpoint = Path_1$1.Path.getPointOnLine(kern + width / 2.0, charStartPoint.x, charStartPoint.y, charEndPoint.x, charEndPoint.y);
            const rotation = Math.atan2(charEndPoint.y - charStartPoint.y, charEndPoint.x - charStartPoint.x);
            this.glyphInfo.push({
                transposeX: midpoint.x,
                transposeY: midpoint.y,
                text: charArr[i],
                rotation: rotation,
                p0: charStartPoint,
                p1: charEndPoint,
            });
            offsetToGlyph += glyphWidth;
        }
    }
    getSelfRect() {
        if (!this.glyphInfo.length) {
            return {
                x: 0,
                y: 0,
                width: 0,
                height: 0,
            };
        }
        var points = [];
        this.glyphInfo.forEach(function (info) {
            points.push(info.p0.x);
            points.push(info.p0.y);
            points.push(info.p1.x);
            points.push(info.p1.y);
        });
        var minX = points[0] || 0;
        var maxX = points[0] || 0;
        var minY = points[1] || 0;
        var maxY = points[1] || 0;
        var x, y;
        for (var i = 0; i < points.length / 2; i++) {
            x = points[i * 2];
            y = points[i * 2 + 1];
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
        }
        var fontSize = this.fontSize();
        return {
            x: minX - fontSize / 2,
            y: minY - fontSize / 2,
            width: maxX - minX + fontSize,
            height: maxY - minY + fontSize,
        };
    }
    destroy() {
        Util_1$4.Util.releaseCanvas(this.dummyCanvas);
        return super.destroy();
    }
}
TextPath$1.TextPath = TextPath;
TextPath.prototype._fillFunc = _fillFunc;
TextPath.prototype._strokeFunc = _strokeFunc;
TextPath.prototype._fillFuncHit = _fillFunc;
TextPath.prototype._strokeFuncHit = _strokeFunc;
TextPath.prototype.className = 'TextPath';
TextPath.prototype._attrsAffectingSize = ['text', 'fontSize', 'data'];
(0, Global_1$2._registerNode)(TextPath);
Factory_1$h.Factory.addGetterSetter(TextPath, 'data');
Factory_1$h.Factory.addGetterSetter(TextPath, 'fontFamily', 'Arial');
Factory_1$h.Factory.addGetterSetter(TextPath, 'fontSize', 12, (0, Validators_1$h.getNumberValidator)());
Factory_1$h.Factory.addGetterSetter(TextPath, 'fontStyle', NORMAL);
Factory_1$h.Factory.addGetterSetter(TextPath, 'align', 'left');
Factory_1$h.Factory.addGetterSetter(TextPath, 'letterSpacing', 0, (0, Validators_1$h.getNumberValidator)());
Factory_1$h.Factory.addGetterSetter(TextPath, 'textBaseline', 'middle');
Factory_1$h.Factory.addGetterSetter(TextPath, 'fontVariant', NORMAL);
Factory_1$h.Factory.addGetterSetter(TextPath, 'text', EMPTY_STRING);
Factory_1$h.Factory.addGetterSetter(TextPath, 'textDecoration', null);
Factory_1$h.Factory.addGetterSetter(TextPath, 'kerningFunc', null);

var Transformer$1 = {};

Object.defineProperty(Transformer$1, "__esModule", { value: true });
Transformer$1.Transformer = void 0;
const Util_1$3 = Util;
const Factory_1$g = Factory;
const Node_1$f = Node$2;
const Shape_1$1 = Shape;
const Rect_1$1 = Rect$1;
const Group_1 = Group$2;
const Global_1$1 = Global;
const Validators_1$g = Validators;
const Global_2$1 = Global;
var EVENTS_NAME = 'tr-konva';
var ATTR_CHANGE_LIST = [
    'resizeEnabledChange',
    'rotateAnchorOffsetChange',
    'rotateEnabledChange',
    'enabledAnchorsChange',
    'anchorSizeChange',
    'borderEnabledChange',
    'borderStrokeChange',
    'borderStrokeWidthChange',
    'borderDashChange',
    'anchorStrokeChange',
    'anchorStrokeWidthChange',
    'anchorFillChange',
    'anchorCornerRadiusChange',
    'ignoreStrokeChange',
    'anchorStyleFuncChange',
]
    .map((e) => e + `.${EVENTS_NAME}`)
    .join(' ');
var NODES_RECT = 'nodesRect';
var TRANSFORM_CHANGE_STR = [
    'widthChange',
    'heightChange',
    'scaleXChange',
    'scaleYChange',
    'skewXChange',
    'skewYChange',
    'rotationChange',
    'offsetXChange',
    'offsetYChange',
    'transformsEnabledChange',
    'strokeWidthChange',
];
var ANGLES = {
    'top-left': -45,
    'top-center': 0,
    'top-right': 45,
    'middle-right': -90,
    'middle-left': 90,
    'bottom-left': -135,
    'bottom-center': 180,
    'bottom-right': 135,
};
const TOUCH_DEVICE = 'ontouchstart' in Global_1$1.Konva._global;
function getCursor(anchorName, rad) {
    if (anchorName === 'rotater') {
        return 'crosshair';
    }
    rad += Util_1$3.Util.degToRad(ANGLES[anchorName] || 0);
    var angle = ((Util_1$3.Util.radToDeg(rad) % 360) + 360) % 360;
    if (Util_1$3.Util._inRange(angle, 315 + 22.5, 360) || Util_1$3.Util._inRange(angle, 0, 22.5)) {
        return 'ns-resize';
    }
    else if (Util_1$3.Util._inRange(angle, 45 - 22.5, 45 + 22.5)) {
        return 'nesw-resize';
    }
    else if (Util_1$3.Util._inRange(angle, 90 - 22.5, 90 + 22.5)) {
        return 'ew-resize';
    }
    else if (Util_1$3.Util._inRange(angle, 135 - 22.5, 135 + 22.5)) {
        return 'nwse-resize';
    }
    else if (Util_1$3.Util._inRange(angle, 180 - 22.5, 180 + 22.5)) {
        return 'ns-resize';
    }
    else if (Util_1$3.Util._inRange(angle, 225 - 22.5, 225 + 22.5)) {
        return 'nesw-resize';
    }
    else if (Util_1$3.Util._inRange(angle, 270 - 22.5, 270 + 22.5)) {
        return 'ew-resize';
    }
    else if (Util_1$3.Util._inRange(angle, 315 - 22.5, 315 + 22.5)) {
        return 'nwse-resize';
    }
    else {
        Util_1$3.Util.error('Transformer has unknown angle for cursor detection: ' + angle);
        return 'pointer';
    }
}
var ANCHORS_NAMES = [
    'top-left',
    'top-center',
    'top-right',
    'middle-right',
    'middle-left',
    'bottom-left',
    'bottom-center',
    'bottom-right',
];
var MAX_SAFE_INTEGER = 100000000;
function getCenter(shape) {
    return {
        x: shape.x +
            (shape.width / 2) * Math.cos(shape.rotation) +
            (shape.height / 2) * Math.sin(-shape.rotation),
        y: shape.y +
            (shape.height / 2) * Math.cos(shape.rotation) +
            (shape.width / 2) * Math.sin(shape.rotation),
    };
}
function rotateAroundPoint(shape, angleRad, point) {
    const x = point.x +
        (shape.x - point.x) * Math.cos(angleRad) -
        (shape.y - point.y) * Math.sin(angleRad);
    const y = point.y +
        (shape.x - point.x) * Math.sin(angleRad) +
        (shape.y - point.y) * Math.cos(angleRad);
    return Object.assign(Object.assign({}, shape), { rotation: shape.rotation + angleRad, x,
        y });
}
function rotateAroundCenter(shape, deltaRad) {
    const center = getCenter(shape);
    return rotateAroundPoint(shape, deltaRad, center);
}
function getSnap(snaps, newRotationRad, tol) {
    let snapped = newRotationRad;
    for (let i = 0; i < snaps.length; i++) {
        const angle = Global_1$1.Konva.getAngle(snaps[i]);
        const absDiff = Math.abs(angle - newRotationRad) % (Math.PI * 2);
        const dif = Math.min(absDiff, Math.PI * 2 - absDiff);
        if (dif < tol) {
            snapped = angle;
        }
    }
    return snapped;
}
class Transformer extends Group_1.Group {
    constructor(config) {
        super(config);
        this._transforming = false;
        this._createElements();
        this._handleMouseMove = this._handleMouseMove.bind(this);
        this._handleMouseUp = this._handleMouseUp.bind(this);
        this.update = this.update.bind(this);
        this.on(ATTR_CHANGE_LIST, this.update);
        if (this.getNode()) {
            this.update();
        }
    }
    attachTo(node) {
        this.setNode(node);
        return this;
    }
    setNode(node) {
        Util_1$3.Util.warn('tr.setNode(shape), tr.node(shape) and tr.attachTo(shape) methods are deprecated. Please use tr.nodes(nodesArray) instead.');
        return this.setNodes([node]);
    }
    getNode() {
        return this._nodes && this._nodes[0];
    }
    _getEventNamespace() {
        return EVENTS_NAME + this._id;
    }
    setNodes(nodes = []) {
        if (this._nodes && this._nodes.length) {
            this.detach();
        }
        const filteredNodes = nodes.filter((node) => {
            if (node.isAncestorOf(this)) {
                Util_1$3.Util.error('Konva.Transformer cannot be an a child of the node you are trying to attach');
                return false;
            }
            return true;
        });
        this._nodes = nodes = filteredNodes;
        if (nodes.length === 1 && this.useSingleNodeRotation()) {
            this.rotation(nodes[0].getAbsoluteRotation());
        }
        else {
            this.rotation(0);
        }
        this._nodes.forEach((node) => {
            const onChange = () => {
                if (this.nodes().length === 1 && this.useSingleNodeRotation()) {
                    this.rotation(this.nodes()[0].getAbsoluteRotation());
                }
                this._resetTransformCache();
                if (!this._transforming && !this.isDragging()) {
                    this.update();
                }
            };
            const additionalEvents = node._attrsAffectingSize
                .map((prop) => prop + 'Change.' + this._getEventNamespace())
                .join(' ');
            node.on(additionalEvents, onChange);
            node.on(TRANSFORM_CHANGE_STR.map((e) => e + `.${this._getEventNamespace()}`).join(' '), onChange);
            node.on(`absoluteTransformChange.${this._getEventNamespace()}`, onChange);
            this._proxyDrag(node);
        });
        this._resetTransformCache();
        var elementsCreated = !!this.findOne('.top-left');
        if (elementsCreated) {
            this.update();
        }
        return this;
    }
    _proxyDrag(node) {
        let lastPos;
        node.on(`dragstart.${this._getEventNamespace()}`, (e) => {
            lastPos = node.getAbsolutePosition();
            if (!this.isDragging() && node !== this.findOne('.back')) {
                this.startDrag(e, false);
            }
        });
        node.on(`dragmove.${this._getEventNamespace()}`, (e) => {
            if (!lastPos) {
                return;
            }
            const abs = node.getAbsolutePosition();
            const dx = abs.x - lastPos.x;
            const dy = abs.y - lastPos.y;
            this.nodes().forEach((otherNode) => {
                if (otherNode === node) {
                    return;
                }
                if (otherNode.isDragging()) {
                    return;
                }
                const otherAbs = otherNode.getAbsolutePosition();
                otherNode.setAbsolutePosition({
                    x: otherAbs.x + dx,
                    y: otherAbs.y + dy,
                });
                otherNode.startDrag(e);
            });
            lastPos = null;
        });
    }
    getNodes() {
        return this._nodes || [];
    }
    getActiveAnchor() {
        return this._movingAnchorName;
    }
    detach() {
        if (this._nodes) {
            this._nodes.forEach((node) => {
                node.off('.' + this._getEventNamespace());
            });
        }
        this._nodes = [];
        this._resetTransformCache();
    }
    _resetTransformCache() {
        this._clearCache(NODES_RECT);
        this._clearCache('transform');
        this._clearSelfAndDescendantCache('absoluteTransform');
    }
    _getNodeRect() {
        return this._getCache(NODES_RECT, this.__getNodeRect);
    }
    __getNodeShape(node, rot = this.rotation(), relative) {
        var rect = node.getClientRect({
            skipTransform: true,
            skipShadow: true,
            skipStroke: this.ignoreStroke(),
        });
        var absScale = node.getAbsoluteScale(relative);
        var absPos = node.getAbsolutePosition(relative);
        var dx = rect.x * absScale.x - node.offsetX() * absScale.x;
        var dy = rect.y * absScale.y - node.offsetY() * absScale.y;
        const rotation = (Global_1$1.Konva.getAngle(node.getAbsoluteRotation()) + Math.PI * 2) %
            (Math.PI * 2);
        const box = {
            x: absPos.x + dx * Math.cos(rotation) + dy * Math.sin(-rotation),
            y: absPos.y + dy * Math.cos(rotation) + dx * Math.sin(rotation),
            width: rect.width * absScale.x,
            height: rect.height * absScale.y,
            rotation: rotation,
        };
        return rotateAroundPoint(box, -Global_1$1.Konva.getAngle(rot), {
            x: 0,
            y: 0,
        });
    }
    __getNodeRect() {
        var node = this.getNode();
        if (!node) {
            return {
                x: -MAX_SAFE_INTEGER,
                y: -MAX_SAFE_INTEGER,
                width: 0,
                height: 0,
                rotation: 0,
            };
        }
        const totalPoints = [];
        this.nodes().map((node) => {
            const box = node.getClientRect({
                skipTransform: true,
                skipShadow: true,
                skipStroke: this.ignoreStroke(),
            });
            var points = [
                { x: box.x, y: box.y },
                { x: box.x + box.width, y: box.y },
                { x: box.x + box.width, y: box.y + box.height },
                { x: box.x, y: box.y + box.height },
            ];
            var trans = node.getAbsoluteTransform();
            points.forEach(function (point) {
                var transformed = trans.point(point);
                totalPoints.push(transformed);
            });
        });
        const tr = new Util_1$3.Transform();
        tr.rotate(-Global_1$1.Konva.getAngle(this.rotation()));
        var minX, minY, maxX, maxY;
        totalPoints.forEach(function (point) {
            var transformed = tr.point(point);
            if (minX === undefined) {
                minX = maxX = transformed.x;
                minY = maxY = transformed.y;
            }
            minX = Math.min(minX, transformed.x);
            minY = Math.min(minY, transformed.y);
            maxX = Math.max(maxX, transformed.x);
            maxY = Math.max(maxY, transformed.y);
        });
        tr.invert();
        const p = tr.point({ x: minX, y: minY });
        return {
            x: p.x,
            y: p.y,
            width: maxX - minX,
            height: maxY - minY,
            rotation: Global_1$1.Konva.getAngle(this.rotation()),
        };
    }
    getX() {
        return this._getNodeRect().x;
    }
    getY() {
        return this._getNodeRect().y;
    }
    getWidth() {
        return this._getNodeRect().width;
    }
    getHeight() {
        return this._getNodeRect().height;
    }
    _createElements() {
        this._createBack();
        ANCHORS_NAMES.forEach(function (name) {
            this._createAnchor(name);
        }.bind(this));
        this._createAnchor('rotater');
    }
    _createAnchor(name) {
        var anchor = new Rect_1$1.Rect({
            stroke: 'rgb(0, 161, 255)',
            fill: 'white',
            strokeWidth: 1,
            name: name + ' _anchor',
            dragDistance: 0,
            draggable: true,
            hitStrokeWidth: TOUCH_DEVICE ? 10 : 'auto',
        });
        var self = this;
        anchor.on('mousedown touchstart', function (e) {
            self._handleMouseDown(e);
        });
        anchor.on('dragstart', (e) => {
            anchor.stopDrag();
            e.cancelBubble = true;
        });
        anchor.on('dragend', (e) => {
            e.cancelBubble = true;
        });
        anchor.on('mouseenter', () => {
            var rad = Global_1$1.Konva.getAngle(this.rotation());
            var cursor = getCursor(name, rad);
            anchor.getStage().content &&
                (anchor.getStage().content.style.cursor = cursor);
            this._cursorChange = true;
        });
        anchor.on('mouseout', () => {
            anchor.getStage().content &&
                (anchor.getStage().content.style.cursor = '');
            this._cursorChange = false;
        });
        this.add(anchor);
    }
    _createBack() {
        var back = new Shape_1$1.Shape({
            name: 'back',
            width: 0,
            height: 0,
            draggable: true,
            sceneFunc(ctx) {
                var tr = this.getParent();
                var padding = tr.padding();
                ctx.beginPath();
                ctx.rect(-padding, -padding, this.width() + padding * 2, this.height() + padding * 2);
                ctx.moveTo(this.width() / 2, -padding);
                if (tr.rotateEnabled()) {
                    ctx.lineTo(this.width() / 2, -tr.rotateAnchorOffset() * Util_1$3.Util._sign(this.height()) - padding);
                }
                ctx.fillStrokeShape(this);
            },
            hitFunc: (ctx, shape) => {
                if (!this.shouldOverdrawWholeArea()) {
                    return;
                }
                var padding = this.padding();
                ctx.beginPath();
                ctx.rect(-padding, -padding, shape.width() + padding * 2, shape.height() + padding * 2);
                ctx.fillStrokeShape(shape);
            },
        });
        this.add(back);
        this._proxyDrag(back);
        back.on('dragstart', (e) => {
            e.cancelBubble = true;
        });
        back.on('dragmove', (e) => {
            e.cancelBubble = true;
        });
        back.on('dragend', (e) => {
            e.cancelBubble = true;
        });
        this.on('dragmove', (e) => {
            this.update();
        });
    }
    _handleMouseDown(e) {
        this._movingAnchorName = e.target.name().split(' ')[0];
        var attrs = this._getNodeRect();
        var width = attrs.width;
        var height = attrs.height;
        var hypotenuse = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));
        this.sin = Math.abs(height / hypotenuse);
        this.cos = Math.abs(width / hypotenuse);
        if (typeof window !== 'undefined') {
            window.addEventListener('mousemove', this._handleMouseMove);
            window.addEventListener('touchmove', this._handleMouseMove);
            window.addEventListener('mouseup', this._handleMouseUp, true);
            window.addEventListener('touchend', this._handleMouseUp, true);
        }
        this._transforming = true;
        var ap = e.target.getAbsolutePosition();
        var pos = e.target.getStage().getPointerPosition();
        this._anchorDragOffset = {
            x: pos.x - ap.x,
            y: pos.y - ap.y,
        };
        this._fire('transformstart', { evt: e.evt, target: this.getNode() });
        this._nodes.forEach((target) => {
            target._fire('transformstart', { evt: e.evt, target });
        });
    }
    _handleMouseMove(e) {
        var x, y, newHypotenuse;
        var anchorNode = this.findOne('.' + this._movingAnchorName);
        var stage = anchorNode.getStage();
        stage.setPointersPositions(e);
        const pp = stage.getPointerPosition();
        let newNodePos = {
            x: pp.x - this._anchorDragOffset.x,
            y: pp.y - this._anchorDragOffset.y,
        };
        const oldAbs = anchorNode.getAbsolutePosition();
        if (this.anchorDragBoundFunc()) {
            newNodePos = this.anchorDragBoundFunc()(oldAbs, newNodePos, e);
        }
        anchorNode.setAbsolutePosition(newNodePos);
        const newAbs = anchorNode.getAbsolutePosition();
        if (oldAbs.x === newAbs.x && oldAbs.y === newAbs.y) {
            return;
        }
        if (this._movingAnchorName === 'rotater') {
            var attrs = this._getNodeRect();
            x = anchorNode.x() - attrs.width / 2;
            y = -anchorNode.y() + attrs.height / 2;
            let delta = Math.atan2(-y, x) + Math.PI / 2;
            if (attrs.height < 0) {
                delta -= Math.PI;
            }
            var oldRotation = Global_1$1.Konva.getAngle(this.rotation());
            const newRotation = oldRotation + delta;
            const tol = Global_1$1.Konva.getAngle(this.rotationSnapTolerance());
            const snappedRot = getSnap(this.rotationSnaps(), newRotation, tol);
            const diff = snappedRot - attrs.rotation;
            const shape = rotateAroundCenter(attrs, diff);
            this._fitNodesInto(shape, e);
            return;
        }
        var shiftBehavior = this.shiftBehavior();
        var keepProportion;
        if (shiftBehavior === 'inverted') {
            keepProportion = this.keepRatio() && !e.shiftKey;
        }
        else if (shiftBehavior === 'none') {
            keepProportion = this.keepRatio();
        }
        else {
            keepProportion = this.keepRatio() || e.shiftKey;
        }
        var centeredScaling = this.centeredScaling() || e.altKey;
        if (this._movingAnchorName === 'top-left') {
            if (keepProportion) {
                var comparePoint = centeredScaling
                    ? {
                        x: this.width() / 2,
                        y: this.height() / 2,
                    }
                    : {
                        x: this.findOne('.bottom-right').x(),
                        y: this.findOne('.bottom-right').y(),
                    };
                newHypotenuse = Math.sqrt(Math.pow(comparePoint.x - anchorNode.x(), 2) +
                    Math.pow(comparePoint.y - anchorNode.y(), 2));
                var reverseX = this.findOne('.top-left').x() > comparePoint.x ? -1 : 1;
                var reverseY = this.findOne('.top-left').y() > comparePoint.y ? -1 : 1;
                x = newHypotenuse * this.cos * reverseX;
                y = newHypotenuse * this.sin * reverseY;
                this.findOne('.top-left').x(comparePoint.x - x);
                this.findOne('.top-left').y(comparePoint.y - y);
            }
        }
        else if (this._movingAnchorName === 'top-center') {
            this.findOne('.top-left').y(anchorNode.y());
        }
        else if (this._movingAnchorName === 'top-right') {
            if (keepProportion) {
                var comparePoint = centeredScaling
                    ? {
                        x: this.width() / 2,
                        y: this.height() / 2,
                    }
                    : {
                        x: this.findOne('.bottom-left').x(),
                        y: this.findOne('.bottom-left').y(),
                    };
                newHypotenuse = Math.sqrt(Math.pow(anchorNode.x() - comparePoint.x, 2) +
                    Math.pow(comparePoint.y - anchorNode.y(), 2));
                var reverseX = this.findOne('.top-right').x() < comparePoint.x ? -1 : 1;
                var reverseY = this.findOne('.top-right').y() > comparePoint.y ? -1 : 1;
                x = newHypotenuse * this.cos * reverseX;
                y = newHypotenuse * this.sin * reverseY;
                this.findOne('.top-right').x(comparePoint.x + x);
                this.findOne('.top-right').y(comparePoint.y - y);
            }
            var pos = anchorNode.position();
            this.findOne('.top-left').y(pos.y);
            this.findOne('.bottom-right').x(pos.x);
        }
        else if (this._movingAnchorName === 'middle-left') {
            this.findOne('.top-left').x(anchorNode.x());
        }
        else if (this._movingAnchorName === 'middle-right') {
            this.findOne('.bottom-right').x(anchorNode.x());
        }
        else if (this._movingAnchorName === 'bottom-left') {
            if (keepProportion) {
                var comparePoint = centeredScaling
                    ? {
                        x: this.width() / 2,
                        y: this.height() / 2,
                    }
                    : {
                        x: this.findOne('.top-right').x(),
                        y: this.findOne('.top-right').y(),
                    };
                newHypotenuse = Math.sqrt(Math.pow(comparePoint.x - anchorNode.x(), 2) +
                    Math.pow(anchorNode.y() - comparePoint.y, 2));
                var reverseX = comparePoint.x < anchorNode.x() ? -1 : 1;
                var reverseY = anchorNode.y() < comparePoint.y ? -1 : 1;
                x = newHypotenuse * this.cos * reverseX;
                y = newHypotenuse * this.sin * reverseY;
                anchorNode.x(comparePoint.x - x);
                anchorNode.y(comparePoint.y + y);
            }
            pos = anchorNode.position();
            this.findOne('.top-left').x(pos.x);
            this.findOne('.bottom-right').y(pos.y);
        }
        else if (this._movingAnchorName === 'bottom-center') {
            this.findOne('.bottom-right').y(anchorNode.y());
        }
        else if (this._movingAnchorName === 'bottom-right') {
            if (keepProportion) {
                var comparePoint = centeredScaling
                    ? {
                        x: this.width() / 2,
                        y: this.height() / 2,
                    }
                    : {
                        x: this.findOne('.top-left').x(),
                        y: this.findOne('.top-left').y(),
                    };
                newHypotenuse = Math.sqrt(Math.pow(anchorNode.x() - comparePoint.x, 2) +
                    Math.pow(anchorNode.y() - comparePoint.y, 2));
                var reverseX = this.findOne('.bottom-right').x() < comparePoint.x ? -1 : 1;
                var reverseY = this.findOne('.bottom-right').y() < comparePoint.y ? -1 : 1;
                x = newHypotenuse * this.cos * reverseX;
                y = newHypotenuse * this.sin * reverseY;
                this.findOne('.bottom-right').x(comparePoint.x + x);
                this.findOne('.bottom-right').y(comparePoint.y + y);
            }
        }
        else {
            console.error(new Error('Wrong position argument of selection resizer: ' +
                this._movingAnchorName));
        }
        var centeredScaling = this.centeredScaling() || e.altKey;
        if (centeredScaling) {
            var topLeft = this.findOne('.top-left');
            var bottomRight = this.findOne('.bottom-right');
            var topOffsetX = topLeft.x();
            var topOffsetY = topLeft.y();
            var bottomOffsetX = this.getWidth() - bottomRight.x();
            var bottomOffsetY = this.getHeight() - bottomRight.y();
            bottomRight.move({
                x: -topOffsetX,
                y: -topOffsetY,
            });
            topLeft.move({
                x: bottomOffsetX,
                y: bottomOffsetY,
            });
        }
        var absPos = this.findOne('.top-left').getAbsolutePosition();
        x = absPos.x;
        y = absPos.y;
        var width = this.findOne('.bottom-right').x() - this.findOne('.top-left').x();
        var height = this.findOne('.bottom-right').y() - this.findOne('.top-left').y();
        this._fitNodesInto({
            x: x,
            y: y,
            width: width,
            height: height,
            rotation: Global_1$1.Konva.getAngle(this.rotation()),
        }, e);
    }
    _handleMouseUp(e) {
        this._removeEvents(e);
    }
    getAbsoluteTransform() {
        return this.getTransform();
    }
    _removeEvents(e) {
        if (this._transforming) {
            this._transforming = false;
            if (typeof window !== 'undefined') {
                window.removeEventListener('mousemove', this._handleMouseMove);
                window.removeEventListener('touchmove', this._handleMouseMove);
                window.removeEventListener('mouseup', this._handleMouseUp, true);
                window.removeEventListener('touchend', this._handleMouseUp, true);
            }
            var node = this.getNode();
            this._fire('transformend', { evt: e, target: node });
            if (node) {
                this._nodes.forEach((target) => {
                    target._fire('transformend', { evt: e, target });
                });
            }
            this._movingAnchorName = null;
        }
    }
    _fitNodesInto(newAttrs, evt) {
        var oldAttrs = this._getNodeRect();
        const minSize = 1;
        if (Util_1$3.Util._inRange(newAttrs.width, -this.padding() * 2 - minSize, minSize)) {
            this.update();
            return;
        }
        if (Util_1$3.Util._inRange(newAttrs.height, -this.padding() * 2 - minSize, minSize)) {
            this.update();
            return;
        }
        const allowNegativeScale = this.flipEnabled();
        var t = new Util_1$3.Transform();
        t.rotate(Global_1$1.Konva.getAngle(this.rotation()));
        if (this._movingAnchorName &&
            newAttrs.width < 0 &&
            this._movingAnchorName.indexOf('left') >= 0) {
            const offset = t.point({
                x: -this.padding() * 2,
                y: 0,
            });
            newAttrs.x += offset.x;
            newAttrs.y += offset.y;
            newAttrs.width += this.padding() * 2;
            this._movingAnchorName = this._movingAnchorName.replace('left', 'right');
            this._anchorDragOffset.x -= offset.x;
            this._anchorDragOffset.y -= offset.y;
            if (!allowNegativeScale) {
                this.update();
                return;
            }
        }
        else if (this._movingAnchorName &&
            newAttrs.width < 0 &&
            this._movingAnchorName.indexOf('right') >= 0) {
            const offset = t.point({
                x: this.padding() * 2,
                y: 0,
            });
            this._movingAnchorName = this._movingAnchorName.replace('right', 'left');
            this._anchorDragOffset.x -= offset.x;
            this._anchorDragOffset.y -= offset.y;
            newAttrs.width += this.padding() * 2;
            if (!allowNegativeScale) {
                this.update();
                return;
            }
        }
        if (this._movingAnchorName &&
            newAttrs.height < 0 &&
            this._movingAnchorName.indexOf('top') >= 0) {
            const offset = t.point({
                x: 0,
                y: -this.padding() * 2,
            });
            newAttrs.x += offset.x;
            newAttrs.y += offset.y;
            this._movingAnchorName = this._movingAnchorName.replace('top', 'bottom');
            this._anchorDragOffset.x -= offset.x;
            this._anchorDragOffset.y -= offset.y;
            newAttrs.height += this.padding() * 2;
            if (!allowNegativeScale) {
                this.update();
                return;
            }
        }
        else if (this._movingAnchorName &&
            newAttrs.height < 0 &&
            this._movingAnchorName.indexOf('bottom') >= 0) {
            const offset = t.point({
                x: 0,
                y: this.padding() * 2,
            });
            this._movingAnchorName = this._movingAnchorName.replace('bottom', 'top');
            this._anchorDragOffset.x -= offset.x;
            this._anchorDragOffset.y -= offset.y;
            newAttrs.height += this.padding() * 2;
            if (!allowNegativeScale) {
                this.update();
                return;
            }
        }
        if (this.boundBoxFunc()) {
            const bounded = this.boundBoxFunc()(oldAttrs, newAttrs);
            if (bounded) {
                newAttrs = bounded;
            }
            else {
                Util_1$3.Util.warn('boundBoxFunc returned falsy. You should return new bound rect from it!');
            }
        }
        const baseSize = 10000000;
        const oldTr = new Util_1$3.Transform();
        oldTr.translate(oldAttrs.x, oldAttrs.y);
        oldTr.rotate(oldAttrs.rotation);
        oldTr.scale(oldAttrs.width / baseSize, oldAttrs.height / baseSize);
        const newTr = new Util_1$3.Transform();
        newTr.translate(newAttrs.x, newAttrs.y);
        newTr.rotate(newAttrs.rotation);
        newTr.scale(newAttrs.width / baseSize, newAttrs.height / baseSize);
        const delta = newTr.multiply(oldTr.invert());
        this._nodes.forEach((node) => {
            var _a;
            const parentTransform = node.getParent().getAbsoluteTransform();
            const localTransform = node.getTransform().copy();
            localTransform.translate(node.offsetX(), node.offsetY());
            const newLocalTransform = new Util_1$3.Transform();
            newLocalTransform
                .multiply(parentTransform.copy().invert())
                .multiply(delta)
                .multiply(parentTransform)
                .multiply(localTransform);
            const attrs = newLocalTransform.decompose();
            node.setAttrs(attrs);
            this._fire('transform', { evt: evt, target: node });
            node._fire('transform', { evt: evt, target: node });
            (_a = node.getLayer()) === null || _a === void 0 ? void 0 : _a.batchDraw();
        });
        this.rotation(Util_1$3.Util._getRotation(newAttrs.rotation));
        this._resetTransformCache();
        this.update();
        this.getLayer().batchDraw();
    }
    forceUpdate() {
        this._resetTransformCache();
        this.update();
    }
    _batchChangeChild(selector, attrs) {
        const anchor = this.findOne(selector);
        anchor.setAttrs(attrs);
    }
    update() {
        var _a;
        var attrs = this._getNodeRect();
        this.rotation(Util_1$3.Util._getRotation(attrs.rotation));
        var width = attrs.width;
        var height = attrs.height;
        var enabledAnchors = this.enabledAnchors();
        var resizeEnabled = this.resizeEnabled();
        var padding = this.padding();
        var anchorSize = this.anchorSize();
        const anchors = this.find('._anchor');
        anchors.forEach((node) => {
            node.setAttrs({
                width: anchorSize,
                height: anchorSize,
                offsetX: anchorSize / 2,
                offsetY: anchorSize / 2,
                stroke: this.anchorStroke(),
                strokeWidth: this.anchorStrokeWidth(),
                fill: this.anchorFill(),
                cornerRadius: this.anchorCornerRadius(),
            });
        });
        this._batchChangeChild('.top-left', {
            x: 0,
            y: 0,
            offsetX: anchorSize / 2 + padding,
            offsetY: anchorSize / 2 + padding,
            visible: resizeEnabled && enabledAnchors.indexOf('top-left') >= 0,
        });
        this._batchChangeChild('.top-center', {
            x: width / 2,
            y: 0,
            offsetY: anchorSize / 2 + padding,
            visible: resizeEnabled && enabledAnchors.indexOf('top-center') >= 0,
        });
        this._batchChangeChild('.top-right', {
            x: width,
            y: 0,
            offsetX: anchorSize / 2 - padding,
            offsetY: anchorSize / 2 + padding,
            visible: resizeEnabled && enabledAnchors.indexOf('top-right') >= 0,
        });
        this._batchChangeChild('.middle-left', {
            x: 0,
            y: height / 2,
            offsetX: anchorSize / 2 + padding,
            visible: resizeEnabled && enabledAnchors.indexOf('middle-left') >= 0,
        });
        this._batchChangeChild('.middle-right', {
            x: width,
            y: height / 2,
            offsetX: anchorSize / 2 - padding,
            visible: resizeEnabled && enabledAnchors.indexOf('middle-right') >= 0,
        });
        this._batchChangeChild('.bottom-left', {
            x: 0,
            y: height,
            offsetX: anchorSize / 2 + padding,
            offsetY: anchorSize / 2 - padding,
            visible: resizeEnabled && enabledAnchors.indexOf('bottom-left') >= 0,
        });
        this._batchChangeChild('.bottom-center', {
            x: width / 2,
            y: height,
            offsetY: anchorSize / 2 - padding,
            visible: resizeEnabled && enabledAnchors.indexOf('bottom-center') >= 0,
        });
        this._batchChangeChild('.bottom-right', {
            x: width,
            y: height,
            offsetX: anchorSize / 2 - padding,
            offsetY: anchorSize / 2 - padding,
            visible: resizeEnabled && enabledAnchors.indexOf('bottom-right') >= 0,
        });
        this._batchChangeChild('.rotater', {
            x: width / 2,
            y: -this.rotateAnchorOffset() * Util_1$3.Util._sign(height) - padding,
            visible: this.rotateEnabled(),
        });
        this._batchChangeChild('.back', {
            width: width,
            height: height,
            visible: this.borderEnabled(),
            stroke: this.borderStroke(),
            strokeWidth: this.borderStrokeWidth(),
            dash: this.borderDash(),
            x: 0,
            y: 0,
        });
        const styleFunc = this.anchorStyleFunc();
        if (styleFunc) {
            anchors.forEach((node) => {
                styleFunc(node);
            });
        }
        (_a = this.getLayer()) === null || _a === void 0 ? void 0 : _a.batchDraw();
    }
    isTransforming() {
        return this._transforming;
    }
    stopTransform() {
        if (this._transforming) {
            this._removeEvents();
            var anchorNode = this.findOne('.' + this._movingAnchorName);
            if (anchorNode) {
                anchorNode.stopDrag();
            }
        }
    }
    destroy() {
        if (this.getStage() && this._cursorChange) {
            this.getStage().content && (this.getStage().content.style.cursor = '');
        }
        Group_1.Group.prototype.destroy.call(this);
        this.detach();
        this._removeEvents();
        return this;
    }
    toObject() {
        return Node_1$f.Node.prototype.toObject.call(this);
    }
    clone(obj) {
        var node = Node_1$f.Node.prototype.clone.call(this, obj);
        return node;
    }
    getClientRect() {
        if (this.nodes().length > 0) {
            return super.getClientRect();
        }
        else {
            return { x: 0, y: 0, width: 0, height: 0 };
        }
    }
}
Transformer$1.Transformer = Transformer;
function validateAnchors(val) {
    if (!(val instanceof Array)) {
        Util_1$3.Util.warn('enabledAnchors value should be an array');
    }
    if (val instanceof Array) {
        val.forEach(function (name) {
            if (ANCHORS_NAMES.indexOf(name) === -1) {
                Util_1$3.Util.warn('Unknown anchor name: ' +
                    name +
                    '. Available names are: ' +
                    ANCHORS_NAMES.join(', '));
            }
        });
    }
    return val || [];
}
Transformer.prototype.className = 'Transformer';
(0, Global_2$1._registerNode)(Transformer);
Factory_1$g.Factory.addGetterSetter(Transformer, 'enabledAnchors', ANCHORS_NAMES, validateAnchors);
Factory_1$g.Factory.addGetterSetter(Transformer, 'flipEnabled', true, (0, Validators_1$g.getBooleanValidator)());
Factory_1$g.Factory.addGetterSetter(Transformer, 'resizeEnabled', true);
Factory_1$g.Factory.addGetterSetter(Transformer, 'anchorSize', 10, (0, Validators_1$g.getNumberValidator)());
Factory_1$g.Factory.addGetterSetter(Transformer, 'rotateEnabled', true);
Factory_1$g.Factory.addGetterSetter(Transformer, 'rotationSnaps', []);
Factory_1$g.Factory.addGetterSetter(Transformer, 'rotateAnchorOffset', 50, (0, Validators_1$g.getNumberValidator)());
Factory_1$g.Factory.addGetterSetter(Transformer, 'rotationSnapTolerance', 5, (0, Validators_1$g.getNumberValidator)());
Factory_1$g.Factory.addGetterSetter(Transformer, 'borderEnabled', true);
Factory_1$g.Factory.addGetterSetter(Transformer, 'anchorStroke', 'rgb(0, 161, 255)');
Factory_1$g.Factory.addGetterSetter(Transformer, 'anchorStrokeWidth', 1, (0, Validators_1$g.getNumberValidator)());
Factory_1$g.Factory.addGetterSetter(Transformer, 'anchorFill', 'white');
Factory_1$g.Factory.addGetterSetter(Transformer, 'anchorCornerRadius', 0, (0, Validators_1$g.getNumberValidator)());
Factory_1$g.Factory.addGetterSetter(Transformer, 'borderStroke', 'rgb(0, 161, 255)');
Factory_1$g.Factory.addGetterSetter(Transformer, 'borderStrokeWidth', 1, (0, Validators_1$g.getNumberValidator)());
Factory_1$g.Factory.addGetterSetter(Transformer, 'borderDash');
Factory_1$g.Factory.addGetterSetter(Transformer, 'keepRatio', true);
Factory_1$g.Factory.addGetterSetter(Transformer, 'shiftBehavior', 'default');
Factory_1$g.Factory.addGetterSetter(Transformer, 'centeredScaling', false);
Factory_1$g.Factory.addGetterSetter(Transformer, 'ignoreStroke', false);
Factory_1$g.Factory.addGetterSetter(Transformer, 'padding', 0, (0, Validators_1$g.getNumberValidator)());
Factory_1$g.Factory.addGetterSetter(Transformer, 'node');
Factory_1$g.Factory.addGetterSetter(Transformer, 'nodes');
Factory_1$g.Factory.addGetterSetter(Transformer, 'boundBoxFunc');
Factory_1$g.Factory.addGetterSetter(Transformer, 'anchorDragBoundFunc');
Factory_1$g.Factory.addGetterSetter(Transformer, 'anchorStyleFunc');
Factory_1$g.Factory.addGetterSetter(Transformer, 'shouldOverdrawWholeArea', false);
Factory_1$g.Factory.addGetterSetter(Transformer, 'useSingleNodeRotation', true);
Factory_1$g.Factory.backCompat(Transformer, {
    lineEnabled: 'borderEnabled',
    rotateHandlerOffset: 'rotateAnchorOffset',
    enabledHandlers: 'enabledAnchors',
});

var Wedge$1 = {};

Object.defineProperty(Wedge$1, "__esModule", { value: true });
Wedge$1.Wedge = void 0;
const Factory_1$f = Factory;
const Shape_1 = Shape;
const Global_1 = Global;
const Validators_1$f = Validators;
const Global_2 = Global;
class Wedge extends Shape_1.Shape {
    _sceneFunc(context) {
        context.beginPath();
        context.arc(0, 0, this.radius(), 0, Global_1.Konva.getAngle(this.angle()), this.clockwise());
        context.lineTo(0, 0);
        context.closePath();
        context.fillStrokeShape(this);
    }
    getWidth() {
        return this.radius() * 2;
    }
    getHeight() {
        return this.radius() * 2;
    }
    setWidth(width) {
        this.radius(width / 2);
    }
    setHeight(height) {
        this.radius(height / 2);
    }
}
Wedge$1.Wedge = Wedge;
Wedge.prototype.className = 'Wedge';
Wedge.prototype._centroid = true;
Wedge.prototype._attrsAffectingSize = ['radius'];
(0, Global_2._registerNode)(Wedge);
Factory_1$f.Factory.addGetterSetter(Wedge, 'radius', 0, (0, Validators_1$f.getNumberValidator)());
Factory_1$f.Factory.addGetterSetter(Wedge, 'angle', 0, (0, Validators_1$f.getNumberValidator)());
Factory_1$f.Factory.addGetterSetter(Wedge, 'clockwise', false);
Factory_1$f.Factory.backCompat(Wedge, {
    angleDeg: 'angle',
    getAngleDeg: 'getAngle',
    setAngleDeg: 'setAngle',
});

var Blur$1 = {};

Object.defineProperty(Blur$1, "__esModule", { value: true });
Blur$1.Blur = void 0;
const Factory_1$e = Factory;
const Node_1$e = Node$2;
const Validators_1$e = Validators;
function BlurStack() {
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.a = 0;
    this.next = null;
}
var mul_table = [
    512,
    512,
    456,
    512,
    328,
    456,
    335,
    512,
    405,
    328,
    271,
    456,
    388,
    335,
    292,
    512,
    454,
    405,
    364,
    328,
    298,
    271,
    496,
    456,
    420,
    388,
    360,
    335,
    312,
    292,
    273,
    512,
    482,
    454,
    428,
    405,
    383,
    364,
    345,
    328,
    312,
    298,
    284,
    271,
    259,
    496,
    475,
    456,
    437,
    420,
    404,
    388,
    374,
    360,
    347,
    335,
    323,
    312,
    302,
    292,
    282,
    273,
    265,
    512,
    497,
    482,
    468,
    454,
    441,
    428,
    417,
    405,
    394,
    383,
    373,
    364,
    354,
    345,
    337,
    328,
    320,
    312,
    305,
    298,
    291,
    284,
    278,
    271,
    265,
    259,
    507,
    496,
    485,
    475,
    465,
    456,
    446,
    437,
    428,
    420,
    412,
    404,
    396,
    388,
    381,
    374,
    367,
    360,
    354,
    347,
    341,
    335,
    329,
    323,
    318,
    312,
    307,
    302,
    297,
    292,
    287,
    282,
    278,
    273,
    269,
    265,
    261,
    512,
    505,
    497,
    489,
    482,
    475,
    468,
    461,
    454,
    447,
    441,
    435,
    428,
    422,
    417,
    411,
    405,
    399,
    394,
    389,
    383,
    378,
    373,
    368,
    364,
    359,
    354,
    350,
    345,
    341,
    337,
    332,
    328,
    324,
    320,
    316,
    312,
    309,
    305,
    301,
    298,
    294,
    291,
    287,
    284,
    281,
    278,
    274,
    271,
    268,
    265,
    262,
    259,
    257,
    507,
    501,
    496,
    491,
    485,
    480,
    475,
    470,
    465,
    460,
    456,
    451,
    446,
    442,
    437,
    433,
    428,
    424,
    420,
    416,
    412,
    408,
    404,
    400,
    396,
    392,
    388,
    385,
    381,
    377,
    374,
    370,
    367,
    363,
    360,
    357,
    354,
    350,
    347,
    344,
    341,
    338,
    335,
    332,
    329,
    326,
    323,
    320,
    318,
    315,
    312,
    310,
    307,
    304,
    302,
    299,
    297,
    294,
    292,
    289,
    287,
    285,
    282,
    280,
    278,
    275,
    273,
    271,
    269,
    267,
    265,
    263,
    261,
    259,
];
var shg_table = [
    9,
    11,
    12,
    13,
    13,
    14,
    14,
    15,
    15,
    15,
    15,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
];
function filterGaussBlurRGBA(imageData, radius) {
    var pixels = imageData.data, width = imageData.width, height = imageData.height;
    var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, r_out_sum, g_out_sum, b_out_sum, a_out_sum, r_in_sum, g_in_sum, b_in_sum, a_in_sum, pr, pg, pb, pa, rbs;
    var div = radius + radius + 1, widthMinus1 = width - 1, heightMinus1 = height - 1, radiusPlus1 = radius + 1, sumFactor = (radiusPlus1 * (radiusPlus1 + 1)) / 2, stackStart = new BlurStack(), stackEnd = null, stack = stackStart, stackIn = null, stackOut = null, mul_sum = mul_table[radius], shg_sum = shg_table[radius];
    for (i = 1; i < div; i++) {
        stack = stack.next = new BlurStack();
        if (i === radiusPlus1) {
            stackEnd = stack;
        }
    }
    stack.next = stackStart;
    yw = yi = 0;
    for (y = 0; y < height; y++) {
        r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;
        r_out_sum = radiusPlus1 * (pr = pixels[yi]);
        g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
        b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
        a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
        r_sum += sumFactor * pr;
        g_sum += sumFactor * pg;
        b_sum += sumFactor * pb;
        a_sum += sumFactor * pa;
        stack = stackStart;
        for (i = 0; i < radiusPlus1; i++) {
            stack.r = pr;
            stack.g = pg;
            stack.b = pb;
            stack.a = pa;
            stack = stack.next;
        }
        for (i = 1; i < radiusPlus1; i++) {
            p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
            r_sum += (stack.r = pr = pixels[p]) * (rbs = radiusPlus1 - i);
            g_sum += (stack.g = pg = pixels[p + 1]) * rbs;
            b_sum += (stack.b = pb = pixels[p + 2]) * rbs;
            a_sum += (stack.a = pa = pixels[p + 3]) * rbs;
            r_in_sum += pr;
            g_in_sum += pg;
            b_in_sum += pb;
            a_in_sum += pa;
            stack = stack.next;
        }
        stackIn = stackStart;
        stackOut = stackEnd;
        for (x = 0; x < width; x++) {
            pixels[yi + 3] = pa = (a_sum * mul_sum) >> shg_sum;
            if (pa !== 0) {
                pa = 255 / pa;
                pixels[yi] = ((r_sum * mul_sum) >> shg_sum) * pa;
                pixels[yi + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;
                pixels[yi + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;
            }
            else {
                pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
            }
            r_sum -= r_out_sum;
            g_sum -= g_out_sum;
            b_sum -= b_out_sum;
            a_sum -= a_out_sum;
            r_out_sum -= stackIn.r;
            g_out_sum -= stackIn.g;
            b_out_sum -= stackIn.b;
            a_out_sum -= stackIn.a;
            p = (yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1)) << 2;
            r_in_sum += stackIn.r = pixels[p];
            g_in_sum += stackIn.g = pixels[p + 1];
            b_in_sum += stackIn.b = pixels[p + 2];
            a_in_sum += stackIn.a = pixels[p + 3];
            r_sum += r_in_sum;
            g_sum += g_in_sum;
            b_sum += b_in_sum;
            a_sum += a_in_sum;
            stackIn = stackIn.next;
            r_out_sum += pr = stackOut.r;
            g_out_sum += pg = stackOut.g;
            b_out_sum += pb = stackOut.b;
            a_out_sum += pa = stackOut.a;
            r_in_sum -= pr;
            g_in_sum -= pg;
            b_in_sum -= pb;
            a_in_sum -= pa;
            stackOut = stackOut.next;
            yi += 4;
        }
        yw += width;
    }
    for (x = 0; x < width; x++) {
        g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;
        yi = x << 2;
        r_out_sum = radiusPlus1 * (pr = pixels[yi]);
        g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
        b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
        a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
        r_sum += sumFactor * pr;
        g_sum += sumFactor * pg;
        b_sum += sumFactor * pb;
        a_sum += sumFactor * pa;
        stack = stackStart;
        for (i = 0; i < radiusPlus1; i++) {
            stack.r = pr;
            stack.g = pg;
            stack.b = pb;
            stack.a = pa;
            stack = stack.next;
        }
        yp = width;
        for (i = 1; i <= radius; i++) {
            yi = (yp + x) << 2;
            r_sum += (stack.r = pr = pixels[yi]) * (rbs = radiusPlus1 - i);
            g_sum += (stack.g = pg = pixels[yi + 1]) * rbs;
            b_sum += (stack.b = pb = pixels[yi + 2]) * rbs;
            a_sum += (stack.a = pa = pixels[yi + 3]) * rbs;
            r_in_sum += pr;
            g_in_sum += pg;
            b_in_sum += pb;
            a_in_sum += pa;
            stack = stack.next;
            if (i < heightMinus1) {
                yp += width;
            }
        }
        yi = x;
        stackIn = stackStart;
        stackOut = stackEnd;
        for (y = 0; y < height; y++) {
            p = yi << 2;
            pixels[p + 3] = pa = (a_sum * mul_sum) >> shg_sum;
            if (pa > 0) {
                pa = 255 / pa;
                pixels[p] = ((r_sum * mul_sum) >> shg_sum) * pa;
                pixels[p + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;
                pixels[p + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;
            }
            else {
                pixels[p] = pixels[p + 1] = pixels[p + 2] = 0;
            }
            r_sum -= r_out_sum;
            g_sum -= g_out_sum;
            b_sum -= b_out_sum;
            a_sum -= a_out_sum;
            r_out_sum -= stackIn.r;
            g_out_sum -= stackIn.g;
            b_out_sum -= stackIn.b;
            a_out_sum -= stackIn.a;
            p =
                (x +
                    ((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width) <<
                    2;
            r_sum += r_in_sum += stackIn.r = pixels[p];
            g_sum += g_in_sum += stackIn.g = pixels[p + 1];
            b_sum += b_in_sum += stackIn.b = pixels[p + 2];
            a_sum += a_in_sum += stackIn.a = pixels[p + 3];
            stackIn = stackIn.next;
            r_out_sum += pr = stackOut.r;
            g_out_sum += pg = stackOut.g;
            b_out_sum += pb = stackOut.b;
            a_out_sum += pa = stackOut.a;
            r_in_sum -= pr;
            g_in_sum -= pg;
            b_in_sum -= pb;
            a_in_sum -= pa;
            stackOut = stackOut.next;
            yi += width;
        }
    }
}
const Blur = function Blur(imageData) {
    var radius = Math.round(this.blurRadius());
    if (radius > 0) {
        filterGaussBlurRGBA(imageData, radius);
    }
};
Blur$1.Blur = Blur;
Factory_1$e.Factory.addGetterSetter(Node_1$e.Node, 'blurRadius', 0, (0, Validators_1$e.getNumberValidator)(), Factory_1$e.Factory.afterSetFilter);

var Brighten$1 = {};

Object.defineProperty(Brighten$1, "__esModule", { value: true });
Brighten$1.Brighten = void 0;
const Factory_1$d = Factory;
const Node_1$d = Node$2;
const Validators_1$d = Validators;
const Brighten = function (imageData) {
    var brightness = this.brightness() * 255, data = imageData.data, len = data.length, i;
    for (i = 0; i < len; i += 4) {
        data[i] += brightness;
        data[i + 1] += brightness;
        data[i + 2] += brightness;
    }
};
Brighten$1.Brighten = Brighten;
Factory_1$d.Factory.addGetterSetter(Node_1$d.Node, 'brightness', 0, (0, Validators_1$d.getNumberValidator)(), Factory_1$d.Factory.afterSetFilter);

var Contrast$1 = {};

Object.defineProperty(Contrast$1, "__esModule", { value: true });
Contrast$1.Contrast = void 0;
const Factory_1$c = Factory;
const Node_1$c = Node$2;
const Validators_1$c = Validators;
const Contrast = function (imageData) {
    var adjust = Math.pow((this.contrast() + 100) / 100, 2);
    var data = imageData.data, nPixels = data.length, red = 150, green = 150, blue = 150, i;
    for (i = 0; i < nPixels; i += 4) {
        red = data[i];
        green = data[i + 1];
        blue = data[i + 2];
        red /= 255;
        red -= 0.5;
        red *= adjust;
        red += 0.5;
        red *= 255;
        green /= 255;
        green -= 0.5;
        green *= adjust;
        green += 0.5;
        green *= 255;
        blue /= 255;
        blue -= 0.5;
        blue *= adjust;
        blue += 0.5;
        blue *= 255;
        red = red < 0 ? 0 : red > 255 ? 255 : red;
        green = green < 0 ? 0 : green > 255 ? 255 : green;
        blue = blue < 0 ? 0 : blue > 255 ? 255 : blue;
        data[i] = red;
        data[i + 1] = green;
        data[i + 2] = blue;
    }
};
Contrast$1.Contrast = Contrast;
Factory_1$c.Factory.addGetterSetter(Node_1$c.Node, 'contrast', 0, (0, Validators_1$c.getNumberValidator)(), Factory_1$c.Factory.afterSetFilter);

var Emboss$1 = {};

Object.defineProperty(Emboss$1, "__esModule", { value: true });
Emboss$1.Emboss = void 0;
const Factory_1$b = Factory;
const Node_1$b = Node$2;
const Util_1$2 = Util;
const Validators_1$b = Validators;
const Emboss = function (imageData) {
    var strength = this.embossStrength() * 10, greyLevel = this.embossWhiteLevel() * 255, direction = this.embossDirection(), blend = this.embossBlend(), dirY = 0, dirX = 0, data = imageData.data, w = imageData.width, h = imageData.height, w4 = w * 4, y = h;
    switch (direction) {
        case 'top-left':
            dirY = -1;
            dirX = -1;
            break;
        case 'top':
            dirY = -1;
            dirX = 0;
            break;
        case 'top-right':
            dirY = -1;
            dirX = 1;
            break;
        case 'right':
            dirY = 0;
            dirX = 1;
            break;
        case 'bottom-right':
            dirY = 1;
            dirX = 1;
            break;
        case 'bottom':
            dirY = 1;
            dirX = 0;
            break;
        case 'bottom-left':
            dirY = 1;
            dirX = -1;
            break;
        case 'left':
            dirY = 0;
            dirX = -1;
            break;
        default:
            Util_1$2.Util.error('Unknown emboss direction: ' + direction);
    }
    do {
        var offsetY = (y - 1) * w4;
        var otherY = dirY;
        if (y + otherY < 1) {
            otherY = 0;
        }
        if (y + otherY > h) {
            otherY = 0;
        }
        var offsetYOther = (y - 1 + otherY) * w * 4;
        var x = w;
        do {
            var offset = offsetY + (x - 1) * 4;
            var otherX = dirX;
            if (x + otherX < 1) {
                otherX = 0;
            }
            if (x + otherX > w) {
                otherX = 0;
            }
            var offsetOther = offsetYOther + (x - 1 + otherX) * 4;
            var dR = data[offset] - data[offsetOther];
            var dG = data[offset + 1] - data[offsetOther + 1];
            var dB = data[offset + 2] - data[offsetOther + 2];
            var dif = dR;
            var absDif = dif > 0 ? dif : -dif;
            var absG = dG > 0 ? dG : -dG;
            var absB = dB > 0 ? dB : -dB;
            if (absG > absDif) {
                dif = dG;
            }
            if (absB > absDif) {
                dif = dB;
            }
            dif *= strength;
            if (blend) {
                var r = data[offset] + dif;
                var g = data[offset + 1] + dif;
                var b = data[offset + 2] + dif;
                data[offset] = r > 255 ? 255 : r < 0 ? 0 : r;
                data[offset + 1] = g > 255 ? 255 : g < 0 ? 0 : g;
                data[offset + 2] = b > 255 ? 255 : b < 0 ? 0 : b;
            }
            else {
                var grey = greyLevel - dif;
                if (grey < 0) {
                    grey = 0;
                }
                else if (grey > 255) {
                    grey = 255;
                }
                data[offset] = data[offset + 1] = data[offset + 2] = grey;
            }
        } while (--x);
    } while (--y);
};
Emboss$1.Emboss = Emboss;
Factory_1$b.Factory.addGetterSetter(Node_1$b.Node, 'embossStrength', 0.5, (0, Validators_1$b.getNumberValidator)(), Factory_1$b.Factory.afterSetFilter);
Factory_1$b.Factory.addGetterSetter(Node_1$b.Node, 'embossWhiteLevel', 0.5, (0, Validators_1$b.getNumberValidator)(), Factory_1$b.Factory.afterSetFilter);
Factory_1$b.Factory.addGetterSetter(Node_1$b.Node, 'embossDirection', 'top-left', null, Factory_1$b.Factory.afterSetFilter);
Factory_1$b.Factory.addGetterSetter(Node_1$b.Node, 'embossBlend', false, null, Factory_1$b.Factory.afterSetFilter);

var Enhance$1 = {};

Object.defineProperty(Enhance$1, "__esModule", { value: true });
Enhance$1.Enhance = void 0;
const Factory_1$a = Factory;
const Node_1$a = Node$2;
const Validators_1$a = Validators;
function remap(fromValue, fromMin, fromMax, toMin, toMax) {
    var fromRange = fromMax - fromMin, toRange = toMax - toMin, toValue;
    if (fromRange === 0) {
        return toMin + toRange / 2;
    }
    if (toRange === 0) {
        return toMin;
    }
    toValue = (fromValue - fromMin) / fromRange;
    toValue = toRange * toValue + toMin;
    return toValue;
}
const Enhance = function (imageData) {
    var data = imageData.data, nSubPixels = data.length, rMin = data[0], rMax = rMin, r, gMin = data[1], gMax = gMin, g, bMin = data[2], bMax = bMin, b, i;
    var enhanceAmount = this.enhance();
    if (enhanceAmount === 0) {
        return;
    }
    for (i = 0; i < nSubPixels; i += 4) {
        r = data[i + 0];
        if (r < rMin) {
            rMin = r;
        }
        else if (r > rMax) {
            rMax = r;
        }
        g = data[i + 1];
        if (g < gMin) {
            gMin = g;
        }
        else if (g > gMax) {
            gMax = g;
        }
        b = data[i + 2];
        if (b < bMin) {
            bMin = b;
        }
        else if (b > bMax) {
            bMax = b;
        }
    }
    if (rMax === rMin) {
        rMax = 255;
        rMin = 0;
    }
    if (gMax === gMin) {
        gMax = 255;
        gMin = 0;
    }
    if (bMax === bMin) {
        bMax = 255;
        bMin = 0;
    }
    var rMid, rGoalMax, rGoalMin, gMid, gGoalMax, gGoalMin, bMid, bGoalMax, bGoalMin;
    if (enhanceAmount > 0) {
        rGoalMax = rMax + enhanceAmount * (255 - rMax);
        rGoalMin = rMin - enhanceAmount * (rMin - 0);
        gGoalMax = gMax + enhanceAmount * (255 - gMax);
        gGoalMin = gMin - enhanceAmount * (gMin - 0);
        bGoalMax = bMax + enhanceAmount * (255 - bMax);
        bGoalMin = bMin - enhanceAmount * (bMin - 0);
    }
    else {
        rMid = (rMax + rMin) * 0.5;
        rGoalMax = rMax + enhanceAmount * (rMax - rMid);
        rGoalMin = rMin + enhanceAmount * (rMin - rMid);
        gMid = (gMax + gMin) * 0.5;
        gGoalMax = gMax + enhanceAmount * (gMax - gMid);
        gGoalMin = gMin + enhanceAmount * (gMin - gMid);
        bMid = (bMax + bMin) * 0.5;
        bGoalMax = bMax + enhanceAmount * (bMax - bMid);
        bGoalMin = bMin + enhanceAmount * (bMin - bMid);
    }
    for (i = 0; i < nSubPixels; i += 4) {
        data[i + 0] = remap(data[i + 0], rMin, rMax, rGoalMin, rGoalMax);
        data[i + 1] = remap(data[i + 1], gMin, gMax, gGoalMin, gGoalMax);
        data[i + 2] = remap(data[i + 2], bMin, bMax, bGoalMin, bGoalMax);
    }
};
Enhance$1.Enhance = Enhance;
Factory_1$a.Factory.addGetterSetter(Node_1$a.Node, 'enhance', 0, (0, Validators_1$a.getNumberValidator)(), Factory_1$a.Factory.afterSetFilter);

var Grayscale$1 = {};

Object.defineProperty(Grayscale$1, "__esModule", { value: true });
Grayscale$1.Grayscale = void 0;
const Grayscale = function (imageData) {
    var data = imageData.data, len = data.length, i, brightness;
    for (i = 0; i < len; i += 4) {
        brightness = 0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2];
        data[i] = brightness;
        data[i + 1] = brightness;
        data[i + 2] = brightness;
    }
};
Grayscale$1.Grayscale = Grayscale;

var HSL$1 = {};

Object.defineProperty(HSL$1, "__esModule", { value: true });
HSL$1.HSL = void 0;
const Factory_1$9 = Factory;
const Node_1$9 = Node$2;
const Validators_1$9 = Validators;
Factory_1$9.Factory.addGetterSetter(Node_1$9.Node, 'hue', 0, (0, Validators_1$9.getNumberValidator)(), Factory_1$9.Factory.afterSetFilter);
Factory_1$9.Factory.addGetterSetter(Node_1$9.Node, 'saturation', 0, (0, Validators_1$9.getNumberValidator)(), Factory_1$9.Factory.afterSetFilter);
Factory_1$9.Factory.addGetterSetter(Node_1$9.Node, 'luminance', 0, (0, Validators_1$9.getNumberValidator)(), Factory_1$9.Factory.afterSetFilter);
const HSL = function (imageData) {
    var data = imageData.data, nPixels = data.length, v = 1, s = Math.pow(2, this.saturation()), h = Math.abs(this.hue() + 360) % 360, l = this.luminance() * 127, i;
    var vsu = v * s * Math.cos((h * Math.PI) / 180), vsw = v * s * Math.sin((h * Math.PI) / 180);
    var rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw, rg = 0.587 * v - 0.587 * vsu + 0.33 * vsw, rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;
    var gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw, gg = 0.587 * v + 0.413 * vsu + 0.035 * vsw, gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;
    var br = 0.299 * v - 0.3 * vsu + 1.25 * vsw, bg = 0.587 * v - 0.586 * vsu - 1.05 * vsw, bb = 0.114 * v + 0.886 * vsu - 0.2 * vsw;
    var r, g, b, a;
    for (i = 0; i < nPixels; i += 4) {
        r = data[i + 0];
        g = data[i + 1];
        b = data[i + 2];
        a = data[i + 3];
        data[i + 0] = rr * r + rg * g + rb * b + l;
        data[i + 1] = gr * r + gg * g + gb * b + l;
        data[i + 2] = br * r + bg * g + bb * b + l;
        data[i + 3] = a;
    }
};
HSL$1.HSL = HSL;

var HSV$1 = {};

Object.defineProperty(HSV$1, "__esModule", { value: true });
HSV$1.HSV = void 0;
const Factory_1$8 = Factory;
const Node_1$8 = Node$2;
const Validators_1$8 = Validators;
const HSV = function (imageData) {
    var data = imageData.data, nPixels = data.length, v = Math.pow(2, this.value()), s = Math.pow(2, this.saturation()), h = Math.abs(this.hue() + 360) % 360, i;
    var vsu = v * s * Math.cos((h * Math.PI) / 180), vsw = v * s * Math.sin((h * Math.PI) / 180);
    var rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw, rg = 0.587 * v - 0.587 * vsu + 0.33 * vsw, rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;
    var gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw, gg = 0.587 * v + 0.413 * vsu + 0.035 * vsw, gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;
    var br = 0.299 * v - 0.3 * vsu + 1.25 * vsw, bg = 0.587 * v - 0.586 * vsu - 1.05 * vsw, bb = 0.114 * v + 0.886 * vsu - 0.2 * vsw;
    var r, g, b, a;
    for (i = 0; i < nPixels; i += 4) {
        r = data[i + 0];
        g = data[i + 1];
        b = data[i + 2];
        a = data[i + 3];
        data[i + 0] = rr * r + rg * g + rb * b;
        data[i + 1] = gr * r + gg * g + gb * b;
        data[i + 2] = br * r + bg * g + bb * b;
        data[i + 3] = a;
    }
};
HSV$1.HSV = HSV;
Factory_1$8.Factory.addGetterSetter(Node_1$8.Node, 'hue', 0, (0, Validators_1$8.getNumberValidator)(), Factory_1$8.Factory.afterSetFilter);
Factory_1$8.Factory.addGetterSetter(Node_1$8.Node, 'saturation', 0, (0, Validators_1$8.getNumberValidator)(), Factory_1$8.Factory.afterSetFilter);
Factory_1$8.Factory.addGetterSetter(Node_1$8.Node, 'value', 0, (0, Validators_1$8.getNumberValidator)(), Factory_1$8.Factory.afterSetFilter);

var Invert$1 = {};

Object.defineProperty(Invert$1, "__esModule", { value: true });
Invert$1.Invert = void 0;
const Invert = function (imageData) {
    var data = imageData.data, len = data.length, i;
    for (i = 0; i < len; i += 4) {
        data[i] = 255 - data[i];
        data[i + 1] = 255 - data[i + 1];
        data[i + 2] = 255 - data[i + 2];
    }
};
Invert$1.Invert = Invert;

var Kaleidoscope$1 = {};

Object.defineProperty(Kaleidoscope$1, "__esModule", { value: true });
Kaleidoscope$1.Kaleidoscope = void 0;
const Factory_1$7 = Factory;
const Node_1$7 = Node$2;
const Util_1$1 = Util;
const Validators_1$7 = Validators;
var ToPolar = function (src, dst, opt) {
    var srcPixels = src.data, dstPixels = dst.data, xSize = src.width, ySize = src.height, xMid = opt.polarCenterX || xSize / 2, yMid = opt.polarCenterY || ySize / 2, i, x, y, r = 0, g = 0, b = 0, a = 0;
    var rad, rMax = Math.sqrt(xMid * xMid + yMid * yMid);
    x = xSize - xMid;
    y = ySize - yMid;
    rad = Math.sqrt(x * x + y * y);
    rMax = rad > rMax ? rad : rMax;
    var rSize = ySize, tSize = xSize, radius, theta;
    var conversion = ((360 / tSize) * Math.PI) / 180, sin, cos;
    for (theta = 0; theta < tSize; theta += 1) {
        sin = Math.sin(theta * conversion);
        cos = Math.cos(theta * conversion);
        for (radius = 0; radius < rSize; radius += 1) {
            x = Math.floor(xMid + ((rMax * radius) / rSize) * cos);
            y = Math.floor(yMid + ((rMax * radius) / rSize) * sin);
            i = (y * xSize + x) * 4;
            r = srcPixels[i + 0];
            g = srcPixels[i + 1];
            b = srcPixels[i + 2];
            a = srcPixels[i + 3];
            i = (theta + radius * xSize) * 4;
            dstPixels[i + 0] = r;
            dstPixels[i + 1] = g;
            dstPixels[i + 2] = b;
            dstPixels[i + 3] = a;
        }
    }
};
var FromPolar = function (src, dst, opt) {
    var srcPixels = src.data, dstPixels = dst.data, xSize = src.width, ySize = src.height, xMid = opt.polarCenterX || xSize / 2, yMid = opt.polarCenterY || ySize / 2, i, x, y, dx, dy, r = 0, g = 0, b = 0, a = 0;
    var rad, rMax = Math.sqrt(xMid * xMid + yMid * yMid);
    x = xSize - xMid;
    y = ySize - yMid;
    rad = Math.sqrt(x * x + y * y);
    rMax = rad > rMax ? rad : rMax;
    var rSize = ySize, tSize = xSize, radius, theta, phaseShift = opt.polarRotation || 0;
    var x1, y1;
    for (x = 0; x < xSize; x += 1) {
        for (y = 0; y < ySize; y += 1) {
            dx = x - xMid;
            dy = y - yMid;
            radius = (Math.sqrt(dx * dx + dy * dy) * rSize) / rMax;
            theta = ((Math.atan2(dy, dx) * 180) / Math.PI + 360 + phaseShift) % 360;
            theta = (theta * tSize) / 360;
            x1 = Math.floor(theta);
            y1 = Math.floor(radius);
            i = (y1 * xSize + x1) * 4;
            r = srcPixels[i + 0];
            g = srcPixels[i + 1];
            b = srcPixels[i + 2];
            a = srcPixels[i + 3];
            i = (y * xSize + x) * 4;
            dstPixels[i + 0] = r;
            dstPixels[i + 1] = g;
            dstPixels[i + 2] = b;
            dstPixels[i + 3] = a;
        }
    }
};
const Kaleidoscope = function (imageData) {
    var xSize = imageData.width, ySize = imageData.height;
    var x, y, xoff, i, r, g, b, a, srcPos, dstPos;
    var power = Math.round(this.kaleidoscopePower());
    var angle = Math.round(this.kaleidoscopeAngle());
    var offset = Math.floor((xSize * (angle % 360)) / 360);
    if (power < 1) {
        return;
    }
    var tempCanvas = Util_1$1.Util.createCanvasElement();
    tempCanvas.width = xSize;
    tempCanvas.height = ySize;
    var scratchData = tempCanvas
        .getContext('2d')
        .getImageData(0, 0, xSize, ySize);
    Util_1$1.Util.releaseCanvas(tempCanvas);
    ToPolar(imageData, scratchData, {
        polarCenterX: xSize / 2,
        polarCenterY: ySize / 2,
    });
    var minSectionSize = xSize / Math.pow(2, power);
    while (minSectionSize <= 8) {
        minSectionSize = minSectionSize * 2;
        power -= 1;
    }
    minSectionSize = Math.ceil(minSectionSize);
    var sectionSize = minSectionSize;
    var xStart = 0, xEnd = sectionSize, xDelta = 1;
    if (offset + minSectionSize > xSize) {
        xStart = sectionSize;
        xEnd = 0;
        xDelta = -1;
    }
    for (y = 0; y < ySize; y += 1) {
        for (x = xStart; x !== xEnd; x += xDelta) {
            xoff = Math.round(x + offset) % xSize;
            srcPos = (xSize * y + xoff) * 4;
            r = scratchData.data[srcPos + 0];
            g = scratchData.data[srcPos + 1];
            b = scratchData.data[srcPos + 2];
            a = scratchData.data[srcPos + 3];
            dstPos = (xSize * y + x) * 4;
            scratchData.data[dstPos + 0] = r;
            scratchData.data[dstPos + 1] = g;
            scratchData.data[dstPos + 2] = b;
            scratchData.data[dstPos + 3] = a;
        }
    }
    for (y = 0; y < ySize; y += 1) {
        sectionSize = Math.floor(minSectionSize);
        for (i = 0; i < power; i += 1) {
            for (x = 0; x < sectionSize + 1; x += 1) {
                srcPos = (xSize * y + x) * 4;
                r = scratchData.data[srcPos + 0];
                g = scratchData.data[srcPos + 1];
                b = scratchData.data[srcPos + 2];
                a = scratchData.data[srcPos + 3];
                dstPos = (xSize * y + sectionSize * 2 - x - 1) * 4;
                scratchData.data[dstPos + 0] = r;
                scratchData.data[dstPos + 1] = g;
                scratchData.data[dstPos + 2] = b;
                scratchData.data[dstPos + 3] = a;
            }
            sectionSize *= 2;
        }
    }
    FromPolar(scratchData, imageData, { polarRotation: 0 });
};
Kaleidoscope$1.Kaleidoscope = Kaleidoscope;
Factory_1$7.Factory.addGetterSetter(Node_1$7.Node, 'kaleidoscopePower', 2, (0, Validators_1$7.getNumberValidator)(), Factory_1$7.Factory.afterSetFilter);
Factory_1$7.Factory.addGetterSetter(Node_1$7.Node, 'kaleidoscopeAngle', 0, (0, Validators_1$7.getNumberValidator)(), Factory_1$7.Factory.afterSetFilter);

var Mask$2 = {};

Object.defineProperty(Mask$2, "__esModule", { value: true });
Mask$2.Mask = void 0;
const Factory_1$6 = Factory;
const Node_1$6 = Node$2;
const Validators_1$6 = Validators;
function pixelAt(idata, x, y) {
    var idx = (y * idata.width + x) * 4;
    var d = [];
    d.push(idata.data[idx++], idata.data[idx++], idata.data[idx++], idata.data[idx++]);
    return d;
}
function rgbDistance(p1, p2) {
    return Math.sqrt(Math.pow(p1[0] - p2[0], 2) +
        Math.pow(p1[1] - p2[1], 2) +
        Math.pow(p1[2] - p2[2], 2));
}
function rgbMean(pTab) {
    var m = [0, 0, 0];
    for (var i = 0; i < pTab.length; i++) {
        m[0] += pTab[i][0];
        m[1] += pTab[i][1];
        m[2] += pTab[i][2];
    }
    m[0] /= pTab.length;
    m[1] /= pTab.length;
    m[2] /= pTab.length;
    return m;
}
function backgroundMask(idata, threshold) {
    var rgbv_no = pixelAt(idata, 0, 0);
    var rgbv_ne = pixelAt(idata, idata.width - 1, 0);
    var rgbv_so = pixelAt(idata, 0, idata.height - 1);
    var rgbv_se = pixelAt(idata, idata.width - 1, idata.height - 1);
    var thres = threshold || 10;
    if (rgbDistance(rgbv_no, rgbv_ne) < thres &&
        rgbDistance(rgbv_ne, rgbv_se) < thres &&
        rgbDistance(rgbv_se, rgbv_so) < thres &&
        rgbDistance(rgbv_so, rgbv_no) < thres) {
        var mean = rgbMean([rgbv_ne, rgbv_no, rgbv_se, rgbv_so]);
        var mask = [];
        for (var i = 0; i < idata.width * idata.height; i++) {
            var d = rgbDistance(mean, [
                idata.data[i * 4],
                idata.data[i * 4 + 1],
                idata.data[i * 4 + 2],
            ]);
            mask[i] = d < thres ? 0 : 255;
        }
        return mask;
    }
}
function applyMask(idata, mask) {
    for (var i = 0; i < idata.width * idata.height; i++) {
        idata.data[4 * i + 3] = mask[i];
    }
}
function erodeMask(mask, sw, sh) {
    var weights = [1, 1, 1, 1, 0, 1, 1, 1, 1];
    var side = Math.round(Math.sqrt(weights.length));
    var halfSide = Math.floor(side / 2);
    var maskResult = [];
    for (var y = 0; y < sh; y++) {
        for (var x = 0; x < sw; x++) {
            var so = y * sw + x;
            var a = 0;
            for (var cy = 0; cy < side; cy++) {
                for (var cx = 0; cx < side; cx++) {
                    var scy = y + cy - halfSide;
                    var scx = x + cx - halfSide;
                    if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
                        var srcOff = scy * sw + scx;
                        var wt = weights[cy * side + cx];
                        a += mask[srcOff] * wt;
                    }
                }
            }
            maskResult[so] = a === 255 * 8 ? 255 : 0;
        }
    }
    return maskResult;
}
function dilateMask(mask, sw, sh) {
    var weights = [1, 1, 1, 1, 1, 1, 1, 1, 1];
    var side = Math.round(Math.sqrt(weights.length));
    var halfSide = Math.floor(side / 2);
    var maskResult = [];
    for (var y = 0; y < sh; y++) {
        for (var x = 0; x < sw; x++) {
            var so = y * sw + x;
            var a = 0;
            for (var cy = 0; cy < side; cy++) {
                for (var cx = 0; cx < side; cx++) {
                    var scy = y + cy - halfSide;
                    var scx = x + cx - halfSide;
                    if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
                        var srcOff = scy * sw + scx;
                        var wt = weights[cy * side + cx];
                        a += mask[srcOff] * wt;
                    }
                }
            }
            maskResult[so] = a >= 255 * 4 ? 255 : 0;
        }
    }
    return maskResult;
}
function smoothEdgeMask(mask, sw, sh) {
    var weights = [1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9];
    var side = Math.round(Math.sqrt(weights.length));
    var halfSide = Math.floor(side / 2);
    var maskResult = [];
    for (var y = 0; y < sh; y++) {
        for (var x = 0; x < sw; x++) {
            var so = y * sw + x;
            var a = 0;
            for (var cy = 0; cy < side; cy++) {
                for (var cx = 0; cx < side; cx++) {
                    var scy = y + cy - halfSide;
                    var scx = x + cx - halfSide;
                    if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
                        var srcOff = scy * sw + scx;
                        var wt = weights[cy * side + cx];
                        a += mask[srcOff] * wt;
                    }
                }
            }
            maskResult[so] = a;
        }
    }
    return maskResult;
}
const Mask$1 = function (imageData) {
    var threshold = this.threshold(), mask = backgroundMask(imageData, threshold);
    if (mask) {
        mask = erodeMask(mask, imageData.width, imageData.height);
        mask = dilateMask(mask, imageData.width, imageData.height);
        mask = smoothEdgeMask(mask, imageData.width, imageData.height);
        applyMask(imageData, mask);
    }
    return imageData;
};
Mask$2.Mask = Mask$1;
Factory_1$6.Factory.addGetterSetter(Node_1$6.Node, 'threshold', 0, (0, Validators_1$6.getNumberValidator)(), Factory_1$6.Factory.afterSetFilter);

var Noise$1 = {};

Object.defineProperty(Noise$1, "__esModule", { value: true });
Noise$1.Noise = void 0;
const Factory_1$5 = Factory;
const Node_1$5 = Node$2;
const Validators_1$5 = Validators;
const Noise = function (imageData) {
    var amount = this.noise() * 255, data = imageData.data, nPixels = data.length, half = amount / 2, i;
    for (i = 0; i < nPixels; i += 4) {
        data[i + 0] += half - 2 * half * Math.random();
        data[i + 1] += half - 2 * half * Math.random();
        data[i + 2] += half - 2 * half * Math.random();
    }
};
Noise$1.Noise = Noise;
Factory_1$5.Factory.addGetterSetter(Node_1$5.Node, 'noise', 0.2, (0, Validators_1$5.getNumberValidator)(), Factory_1$5.Factory.afterSetFilter);

var Pixelate$1 = {};

Object.defineProperty(Pixelate$1, "__esModule", { value: true });
Pixelate$1.Pixelate = void 0;
const Factory_1$4 = Factory;
const Util_1 = Util;
const Node_1$4 = Node$2;
const Validators_1$4 = Validators;
const Pixelate = function (imageData) {
    var pixelSize = Math.ceil(this.pixelSize()), width = imageData.width, height = imageData.height, x, y, i, red, green, blue, alpha, nBinsX = Math.ceil(width / pixelSize), nBinsY = Math.ceil(height / pixelSize), xBinStart, xBinEnd, yBinStart, yBinEnd, xBin, yBin, pixelsInBin, data = imageData.data;
    if (pixelSize <= 0) {
        Util_1.Util.error('pixelSize value can not be <= 0');
        return;
    }
    for (xBin = 0; xBin < nBinsX; xBin += 1) {
        for (yBin = 0; yBin < nBinsY; yBin += 1) {
            red = 0;
            green = 0;
            blue = 0;
            alpha = 0;
            xBinStart = xBin * pixelSize;
            xBinEnd = xBinStart + pixelSize;
            yBinStart = yBin * pixelSize;
            yBinEnd = yBinStart + pixelSize;
            pixelsInBin = 0;
            for (x = xBinStart; x < xBinEnd; x += 1) {
                if (x >= width) {
                    continue;
                }
                for (y = yBinStart; y < yBinEnd; y += 1) {
                    if (y >= height) {
                        continue;
                    }
                    i = (width * y + x) * 4;
                    red += data[i + 0];
                    green += data[i + 1];
                    blue += data[i + 2];
                    alpha += data[i + 3];
                    pixelsInBin += 1;
                }
            }
            red = red / pixelsInBin;
            green = green / pixelsInBin;
            blue = blue / pixelsInBin;
            alpha = alpha / pixelsInBin;
            for (x = xBinStart; x < xBinEnd; x += 1) {
                if (x >= width) {
                    continue;
                }
                for (y = yBinStart; y < yBinEnd; y += 1) {
                    if (y >= height) {
                        continue;
                    }
                    i = (width * y + x) * 4;
                    data[i + 0] = red;
                    data[i + 1] = green;
                    data[i + 2] = blue;
                    data[i + 3] = alpha;
                }
            }
        }
    }
};
Pixelate$1.Pixelate = Pixelate;
Factory_1$4.Factory.addGetterSetter(Node_1$4.Node, 'pixelSize', 8, (0, Validators_1$4.getNumberValidator)(), Factory_1$4.Factory.afterSetFilter);

var Posterize$1 = {};

Object.defineProperty(Posterize$1, "__esModule", { value: true });
Posterize$1.Posterize = void 0;
const Factory_1$3 = Factory;
const Node_1$3 = Node$2;
const Validators_1$3 = Validators;
const Posterize = function (imageData) {
    var levels = Math.round(this.levels() * 254) + 1, data = imageData.data, len = data.length, scale = 255 / levels, i;
    for (i = 0; i < len; i += 1) {
        data[i] = Math.floor(data[i] / scale) * scale;
    }
};
Posterize$1.Posterize = Posterize;
Factory_1$3.Factory.addGetterSetter(Node_1$3.Node, 'levels', 0.5, (0, Validators_1$3.getNumberValidator)(), Factory_1$3.Factory.afterSetFilter);

var RGB$1 = {};

Object.defineProperty(RGB$1, "__esModule", { value: true });
RGB$1.RGB = void 0;
const Factory_1$2 = Factory;
const Node_1$2 = Node$2;
const Validators_1$2 = Validators;
const RGB = function (imageData) {
    var data = imageData.data, nPixels = data.length, red = this.red(), green = this.green(), blue = this.blue(), i, brightness;
    for (i = 0; i < nPixels; i += 4) {
        brightness =
            (0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2]) / 255;
        data[i] = brightness * red;
        data[i + 1] = brightness * green;
        data[i + 2] = brightness * blue;
        data[i + 3] = data[i + 3];
    }
};
RGB$1.RGB = RGB;
Factory_1$2.Factory.addGetterSetter(Node_1$2.Node, 'red', 0, function (val) {
    this._filterUpToDate = false;
    if (val > 255) {
        return 255;
    }
    else if (val < 0) {
        return 0;
    }
    else {
        return Math.round(val);
    }
});
Factory_1$2.Factory.addGetterSetter(Node_1$2.Node, 'green', 0, function (val) {
    this._filterUpToDate = false;
    if (val > 255) {
        return 255;
    }
    else if (val < 0) {
        return 0;
    }
    else {
        return Math.round(val);
    }
});
Factory_1$2.Factory.addGetterSetter(Node_1$2.Node, 'blue', 0, Validators_1$2.RGBComponent, Factory_1$2.Factory.afterSetFilter);

var RGBA$1 = {};

Object.defineProperty(RGBA$1, "__esModule", { value: true });
RGBA$1.RGBA = void 0;
const Factory_1$1 = Factory;
const Node_1$1 = Node$2;
const Validators_1$1 = Validators;
const RGBA = function (imageData) {
    var data = imageData.data, nPixels = data.length, red = this.red(), green = this.green(), blue = this.blue(), alpha = this.alpha(), i, ia;
    for (i = 0; i < nPixels; i += 4) {
        ia = 1 - alpha;
        data[i] = red * alpha + data[i] * ia;
        data[i + 1] = green * alpha + data[i + 1] * ia;
        data[i + 2] = blue * alpha + data[i + 2] * ia;
    }
};
RGBA$1.RGBA = RGBA;
Factory_1$1.Factory.addGetterSetter(Node_1$1.Node, 'red', 0, function (val) {
    this._filterUpToDate = false;
    if (val > 255) {
        return 255;
    }
    else if (val < 0) {
        return 0;
    }
    else {
        return Math.round(val);
    }
});
Factory_1$1.Factory.addGetterSetter(Node_1$1.Node, 'green', 0, function (val) {
    this._filterUpToDate = false;
    if (val > 255) {
        return 255;
    }
    else if (val < 0) {
        return 0;
    }
    else {
        return Math.round(val);
    }
});
Factory_1$1.Factory.addGetterSetter(Node_1$1.Node, 'blue', 0, Validators_1$1.RGBComponent, Factory_1$1.Factory.afterSetFilter);
Factory_1$1.Factory.addGetterSetter(Node_1$1.Node, 'alpha', 1, function (val) {
    this._filterUpToDate = false;
    if (val > 1) {
        return 1;
    }
    else if (val < 0) {
        return 0;
    }
    else {
        return val;
    }
});

var Sepia$1 = {};

Object.defineProperty(Sepia$1, "__esModule", { value: true });
Sepia$1.Sepia = void 0;
const Sepia = function (imageData) {
    var data = imageData.data, nPixels = data.length, i, r, g, b;
    for (i = 0; i < nPixels; i += 4) {
        r = data[i + 0];
        g = data[i + 1];
        b = data[i + 2];
        data[i + 0] = Math.min(255, r * 0.393 + g * 0.769 + b * 0.189);
        data[i + 1] = Math.min(255, r * 0.349 + g * 0.686 + b * 0.168);
        data[i + 2] = Math.min(255, r * 0.272 + g * 0.534 + b * 0.131);
    }
};
Sepia$1.Sepia = Sepia;

var Solarize$1 = {};

Object.defineProperty(Solarize$1, "__esModule", { value: true });
Solarize$1.Solarize = void 0;
const Solarize = function (imageData) {
    var data = imageData.data, w = imageData.width, h = imageData.height, w4 = w * 4, y = h;
    do {
        var offsetY = (y - 1) * w4;
        var x = w;
        do {
            var offset = offsetY + (x - 1) * 4;
            var r = data[offset];
            var g = data[offset + 1];
            var b = data[offset + 2];
            if (r > 127) {
                r = 255 - r;
            }
            if (g > 127) {
                g = 255 - g;
            }
            if (b > 127) {
                b = 255 - b;
            }
            data[offset] = r;
            data[offset + 1] = g;
            data[offset + 2] = b;
        } while (--x);
    } while (--y);
};
Solarize$1.Solarize = Solarize;

var Threshold$1 = {};

Object.defineProperty(Threshold$1, "__esModule", { value: true });
Threshold$1.Threshold = void 0;
const Factory_1 = Factory;
const Node_1 = Node$2;
const Validators_1 = Validators;
const Threshold = function (imageData) {
    var level = this.threshold() * 255, data = imageData.data, len = data.length, i;
    for (i = 0; i < len; i += 1) {
        data[i] = data[i] < level ? 0 : 255;
    }
};
Threshold$1.Threshold = Threshold;
Factory_1.Factory.addGetterSetter(Node_1.Node, 'threshold', 0.5, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);

Object.defineProperty(_FullInternals, "__esModule", { value: true });
_FullInternals.Konva = void 0;
const _CoreInternals_1 = _CoreInternals;
const Arc_1 = Arc$1;
const Arrow_1 = Arrow$1;
const Circle_1 = Circle$4;
const Ellipse_1 = Ellipse$1;
const Image_1 = Image$3;
const Label_1 = Label$1;
const Line_1 = Line$3;
const Path_1 = Path$1;
const Rect_1 = Rect$1;
const RegularPolygon_1 = RegularPolygon$1;
const Ring_1 = Ring$1;
const Sprite_1 = Sprite$1;
const Star_1 = Star$1;
const Text_1 = Text$1;
const TextPath_1 = TextPath$1;
const Transformer_1 = Transformer$1;
const Wedge_1 = Wedge$1;
const Blur_1 = Blur$1;
const Brighten_1 = Brighten$1;
const Contrast_1 = Contrast$1;
const Emboss_1 = Emboss$1;
const Enhance_1 = Enhance$1;
const Grayscale_1 = Grayscale$1;
const HSL_1 = HSL$1;
const HSV_1 = HSV$1;
const Invert_1 = Invert$1;
const Kaleidoscope_1 = Kaleidoscope$1;
const Mask_1 = Mask$2;
const Noise_1 = Noise$1;
const Pixelate_1 = Pixelate$1;
const Posterize_1 = Posterize$1;
const RGB_1 = RGB$1;
const RGBA_1 = RGBA$1;
const Sepia_1 = Sepia$1;
const Solarize_1 = Solarize$1;
const Threshold_1 = Threshold$1;
_FullInternals.Konva = _CoreInternals_1.Konva.Util._assign(_CoreInternals_1.Konva, {
    Arc: Arc_1.Arc,
    Arrow: Arrow_1.Arrow,
    Circle: Circle_1.Circle,
    Ellipse: Ellipse_1.Ellipse,
    Image: Image_1.Image,
    Label: Label_1.Label,
    Tag: Label_1.Tag,
    Line: Line_1.Line,
    Path: Path_1.Path,
    Rect: Rect_1.Rect,
    RegularPolygon: RegularPolygon_1.RegularPolygon,
    Ring: Ring_1.Ring,
    Sprite: Sprite_1.Sprite,
    Star: Star_1.Star,
    Text: Text_1.Text,
    TextPath: TextPath_1.TextPath,
    Transformer: Transformer_1.Transformer,
    Wedge: Wedge_1.Wedge,
    Filters: {
        Blur: Blur_1.Blur,
        Brighten: Brighten_1.Brighten,
        Contrast: Contrast_1.Contrast,
        Emboss: Emboss_1.Emboss,
        Enhance: Enhance_1.Enhance,
        Grayscale: Grayscale_1.Grayscale,
        HSL: HSL_1.HSL,
        HSV: HSV_1.HSV,
        Invert: Invert_1.Invert,
        Kaleidoscope: Kaleidoscope_1.Kaleidoscope,
        Mask: Mask_1.Mask,
        Noise: Noise_1.Noise,
        Pixelate: Pixelate_1.Pixelate,
        Posterize: Posterize_1.Posterize,
        RGB: RGB_1.RGB,
        RGBA: RGBA_1.RGBA,
        Sepia: Sepia_1.Sepia,
        Solarize: Solarize_1.Solarize,
        Threshold: Threshold_1.Threshold,
    },
});

var indexNode = indexNode$1.exports;
Object.defineProperty(indexNode, "__esModule", { value: true });
const _FullInternals_1 = _FullInternals;
const Canvas = require$$1;
const canvas = Canvas['default'] || Canvas;
commonjsGlobal.DOMMatrix = canvas.DOMMatrix;
const isNode = typeof commonjsGlobal.document === 'undefined';
if (isNode) {
    _FullInternals_1.Konva.Util['createCanvasElement'] = () => {
        const node = canvas.createCanvas(300, 300);
        if (!node['style']) {
            node['style'] = {};
        }
        return node;
    };
    _FullInternals_1.Konva.Util.createImageElement = () => {
        const node = new canvas.Image();
        return node;
    };
}
indexNode$1.exports = _FullInternals_1.Konva;

var indexNodeExports = indexNode$1.exports;
var Konva = /*@__PURE__*/getDefaultExportFromCjs(indexNodeExports);

Recoil_index_8({
    key: 'boxListAtom',
    default: [],
});
const appModeAtom = Recoil_index_8({
    key: 'appModeAtom',
    default: {
        mode: "DRAWING_MODE"
    }
});
const loaderAtom = Recoil_index_8({
    key: 'loaderAtom',
    default: {
        visible: false,
    }
});
const showUploadDraggerAtom = Recoil_index_8({
    key: 'showUploadDraggerAtom',
    default: false
});
const activeImageAtom = Recoil_index_8({
    key: 'activeImage',
    default: null,
});
const imageListAtom = Recoil_index_8({
    key: 'imageListAtom',
    default: [],
});

function uuidv4() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        const r = (Math.random() * 16) | 0;
        const v = c === 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
}

class Action {
    constructor(subject, actionStore, parent) {
        this.childActions = [];
        this.parentAction = null;
        this.image = null;
        this.actionStore = null;
        this.actionID = uuidv4();
        this.childActions = [];
        this.subject = subject;
        this.actionStore = actionStore;
        if (parent) {
            this.parentAction = parent;
            this.parentAction.childActions.push(this);
        }
        else
            this.actionStore.push(this);
        this.status = 'awaitingBuild';
    }
    finish(config) {
        return new Promise((resolve, reject) => {
            this.status = 'finish';
            resolve();
        });
    }
    directExecute() {
        return new Promise((resolve, reject) => {
            this.build().then(() => {
                this.execute().then(() => {
                    this.finish().then(() => {
                        resolve(this);
                    });
                });
            });
        });
    }
    destroy() {
        return new Promise((resolve, reject) => {
            if (this?.parentAction?.childActions)
                this.parentAction.childActions = this.parentAction.childActions.filter(action => action.actionID === this.actionID);
            else {
                if (!this.image)
                    return;
                this.image.actionStore.index -= 1;
                this.image.actionStore.ActionsList.pop();
            }
            resolve();
        });
    }
}

class BoxTransformAction extends Action {
    constructor(config) {
        super(config.box, config.actionsStore, config.parent);
        this.anchor = null;
        this.oldPosition = null;
        this.newPosition = null;
        this.anchor = config.anchor;
    }
    build() {
        return new Promise((resolve, reject) => {
            if (this.status !== "awaitingBuild") {
                this.status = 'buildFailed';
                return reject("Unable to store old position of box.");
            }
            this.oldPosition = {
                x: this.subject.x(),
                y: this.subject.y(),
                width: this.subject.rect.width(),
                height: this.subject.rect.height(),
                label: ""
            };
            this.status = 'awaitingExecute';
            resolve();
        });
    }
    execute() {
        return new Promise((resolve, reject) => {
            if (!['awaitingExecute', 'executing'].includes(this.status)) {
                this.status = 'executionFailed';
                return reject("Unable to transform box.");
            }
            const pos = this.subject.image?.editor?.getRelativePointerPosition();
            switch (this.anchor?.name()) {
                case 'top-left':
                    this.subject.rect.width(this.subject.rect.width() + this.subject.x() - pos.x);
                    this.subject.rect.height(this.subject.rect.height() + this.subject.y() - pos.y);
                    this.subject.y(pos.y);
                    this.subject.x(pos.x);
                    break;
                case 'bottom-right':
                    this.subject.rect.width(pos.x - this.subject.x());
                    this.subject.rect.height(pos.y - this.subject.y());
                    break;
                case 'top-right':
                    this.subject.rect.height(this.subject.rect.height() - (pos.y - this.subject.y()));
                    this.subject.rect.width(pos.x - this.subject.x());
                    this.subject.y(pos.y);
                    break;
                case 'bottom-left':
                    this.subject.rect.width(this.subject.rect.width() + this.subject.x() - pos.x);
                    this.subject.rect.height(this.subject.rect.height() + (pos.y - (this.subject.y() + this.subject.rect.height())));
                    this.subject.x(pos.x);
                    break;
            }
            this.newPosition = {
                x: this.subject.x(),
                y: this.subject.y(),
                width: this.subject.rect.width(),
                height: this.subject.rect.height(),
                label: ""
            };
            this.status = 'executing';
            resolve();
        });
    }
    undo() {
        return new Promise((resolve, reject) => {
            if (this.status !== 'finish' || !this.oldPosition) {
                this.status = 'undoFailed';
                return reject("Unable to undo, action execution is not finished yet or old position is not found.");
            }
            this.subject.x(this.oldPosition.x);
            this.subject.y(this.oldPosition.y);
            this.subject.rect.width(this.oldPosition.width);
            this.subject.rect.height(this.oldPosition.height);
            this.subject.updateAnchorsPosition();
            this.status = 'undo';
            resolve();
        });
    }
    redo() {
        return new Promise((resolve, reject) => {
            if (this.status !== "undo" || !this.newPosition) {
                this.status = 'redoFailed';
                return reject("Unable to redo. Undo is not finished yet or new position is not found.");
            }
            this.subject.x(this.newPosition.x);
            this.subject.y(this.newPosition.y);
            this.subject.rect.width(this.newPosition.width);
            this.subject.rect.height(this.newPosition.height);
            this.subject.updateAnchorsPosition();
            this.status = 'finish';
            resolve();
        });
    }
}

class BoxMoveAction extends Action {
    constructor(config) {
        super(config.box, config.actionsStore, config.parent);
        this.oldPosition = null;
        this.newPosition = null;
    }
    build() {
        return new Promise((resolve, reject) => {
            if (this.status !== "awaitingBuild") {
                this.status = 'buildFailed';
                return reject("Unable to save old position of box.");
            }
            this.oldPosition = {
                x: this.subject.x(),
                y: this.subject.y()
            };
            this.status = 'awaitingExecute';
            resolve();
        });
    }
    execute() {
        return new Promise((resolve, reject) => {
            if (!['awaitingExecute', 'executing'].includes(this.status)) {
                this.status = 'executionFailed';
                return reject("Unable to move box.");
            }
            this.newPosition = {
                x: this.subject.x(),
                y: this.subject.y()
            };
            this.status = 'executing';
            resolve();
        });
    }
    undo() {
        return new Promise((resolve, reject) => {
            if (this.status !== 'finish' || !this.oldPosition) {
                this.status = 'undoFailed';
                return reject("Unable to undo, action execution is not finished yet or old position is not found.");
            }
            this.subject.x(this.oldPosition.x);
            this.subject.y(this.oldPosition.y);
            this.status = 'undo';
            resolve();
        });
    }
    redo() {
        return new Promise((resolve, reject) => {
            if (this.status !== "undo" || !this.newPosition) {
                this.status = 'redoFailed';
                return reject("Unable to redo. Undo is not finished yet or new position is not found.");
            }
            this.subject.x(this.newPosition.x);
            this.subject.y(this.newPosition.y);
            this.status = 'finish';
            resolve();
        });
    }
}

class Anchor extends Konva.Rect {
    constructor(config) {
        super(config);
        this.box = null;
        this.box = config.box;
    }
}
class Box extends Konva.Group {
    constructor(config) {
        super(config);
        this.rect = new Konva.Rect();
        this.label = '';
        this.image = null;
        this.editor = null;
        this.anchors = [{ pos: [0, 0], name: 'top-left' }, { pos: [1, 0], name: "top-right" }, { pos: [0, 1], name: 'bottom-left' }, { pos: [1, 1], name: 'bottom-right' }];
        this.boxTransformAction = null;
        this.boxMoveAction = null;
        this.init(config);
        this.on("mousemove", this.mouseMoveAction.bind(this));
        this.on('click', this.mouseClickAction.bind(this));
        this.on('mouseenter', this.mouseEnterAction.bind(this));
        this.on('mouseleave', this.mouseLeaveAction.bind(this));
        this.on('dragstart', this.handleDragStart.bind(this));
        this.on('dragmove', this.handleDragMove.bind(this));
        this.on('dragend', this.handleDragEnd.bind(this));
    }
    init(config) {
        this.image = config.image;
        this.editor = this.image.editor;
        this.label = config?.label || "";
        this.initAnchors();
        this.rect = new Konva.Rect({
            x: 0,
            y: 0,
            width: this.width(),
            height: this.height(),
            fill: 'rgb(66, 72, 255, 0.10)',
            stroke: 'rgb(66, 72, 255)',
            strokeWidth: 1.5,
            strokeScaleEnabled: false,
        });
        this.add(this.rect);
    }
    initAnchors() {
        this.anchors.forEach(anchor => {
            anchor.rect = new Anchor({
                x: anchor.pos[0] * this.width(),
                y: anchor.pos[1] * this.height(),
                width: 10,
                height: 10,
                name: anchor.name,
                draggable: true,
                stroke: 'black',
                strokeWidth: 1.5,
                strokeScaleEnabled: false,
                fill: 'white',
                visible: false,
                box: this
            });
            anchor.rect.on('mouseenter', this.handleAnchorMouseEnter.bind(this));
            anchor.rect.on('mouseleave', this.handleAnchorMouseLeave.bind(this));
            anchor.rect.on('dragmove', this.handleAnchorDragMove.bind(this));
            anchor.rect.on('dragstart', this.handleAnchorDragStart.bind(this));
            anchor.rect.on('dragend', this.handleAnchorDragEnd.bind(this));
            this.add(anchor.rect);
        });
    }
    handleDragStart(event) {
        return new Promise((resolve, reject) => {
            this.boxMoveAction = new BoxMoveAction({ box: this, actionsStore: this.image?.actionStore });
            this.boxMoveAction.build().then(() => {
                resolve();
            }).catch((error) => {
                console.log(error);
            });
        });
    }
    handleDragMove(event) {
        return new Promise((resolve, reject) => {
            this.boxMoveAction?.execute();
        });
    }
    handleDragEnd(event) {
        return new Promise((resolve, reject) => {
            this.boxMoveAction?.finish().then(() => {
                resolve();
            }).catch((error) => {
                console.log(error);
            });
        });
    }
    updateAnchorsPosition() {
        this.anchors.forEach(anchor => {
            anchor.rect?.x(anchor.pos[0] * this.rect.width());
            anchor.rect?.y(anchor.pos[1] * this.rect.height());
        });
    }
    handleAnchorDragStart(event) {
        return new Promise((resolve, reject) => {
            event.cancelBubble = true;
            if (this.editor?.appMode.mode === "EDIT_MODE") {
                setRecoil_1(appModeAtom, (prev) => ({ ...prev, visible: false }));
            }
            this.hideAnchors();
            this.boxTransformAction = new BoxTransformAction({ anchor: event.target, box: this, actionsStore: this.image?.actionStore });
            this.boxTransformAction.build().then(() => {
                resolve();
            }).catch((error) => {
                console.log(error);
            });
        });
    }
    handleAnchorDragEnd(event) {
        return new Promise((resolve, reject) => {
            event.cancelBubble = true;
            if (this.editor?.appMode.mode === "EDIT_MODE") {
                setRecoil_1(appModeAtom, (prev) => ({ ...prev, visible: true }));
                this.showAnchors();
                this.updateAnchorsPosition();
            }
            else {
                setTimeout(() => {
                    const target = this.editor?.getIntersection(this.editor?.getPointerPosition());
                    target instanceof Box && target.showAnchors();
                    target instanceof Konva.Rect && target.parent.showAnchors();
                }, 50);
            }
            this.editor?.updateCursorStyle();
            this.boxTransformAction?.finish().then(() => {
                resolve();
            }).catch(error => console.log(error));
        });
    }
    handleAnchorDragMove(event) {
        return new Promise((resolve, reject) => {
            event.cancelBubble = true;
            this.boxTransformAction?.execute().then(() => {
                resolve();
            }).catch((error) => {
                console.log(error);
            });
        });
    }
    handleAnchorMouseLeave(event) {
        event.cancelBubble = true;
        this.editor?.updateCursorStyle();
    }
    handleAnchorMouseEnter(event) {
        event.cancelBubble = true;
        this.editor?.updateCursorStyle(event.target);
    }
    showAnchors() {
        this.anchors.forEach(anchor => {
            anchor.rect?.show();
            this.updateAnchorsScale();
            this.updateAnchorsPosition();
            anchor.rect?.moveToTop();
        });
    }
    updateAnchorsScale() {
        const scale = this.editor?.scaleX() || 1;
        this.anchors.forEach(anchor => {
            anchor.rect?.width(10 / scale);
            anchor.rect?.height(10 / scale);
            anchor.rect?.offset({
                x: anchor.rect.width() / 2,
                y: anchor.rect.height() / 2
            });
        });
    }
    hideAnchors() {
        this.anchors.forEach(anchor => anchor.rect?.hide());
    }
    mouseClickAction(event) {
        console.log(this);
        if (this.editor?.appMode.mode === 'DRAG_SELECTION_MODE') {
            this.editor.setMode({
                mode: "EDIT_MODE",
                boxInEditMode: this,
                visible: true
            });
        }
    }
    mouseMoveAction(event) {
    }
    mouseEnterAction(event) {
        this.editor?.updateCursorStyle(this);
        this.showAnchors();
    }
    mouseLeaveAction(event) {
        this.editor?.updateCursorStyle();
        if (this.editor?.appMode.mode === "EDIT_MODE") {
            this.showAnchors();
        }
        else {
            this.hideAnchors();
        }
    }
    updateLabel(label) {
        this.label = label;
    }
}

class CreateBoxAction extends Action {
    constructor(config) {
        super(null, config.actionsStore, config.parent);
        this.pos = null;
        this.image = config.image;
        this.pos = config.pos;
    }
    build() {
        return new Promise((resolve, reject) => {
            if (!this.image || !this.pos || this.status !== "awaitingBuild") {
                this.status = 'buildFailed';
                return reject("Unable to create box.");
            }
            this.subject = new Box({
                x: this.pos.x,
                y: this.pos.y,
                width: 0,
                height: 0,
                draggable: true,
                listening: false,
                image: this.image
            });
            this.image.editor?.layer?.add(this.subject);
            this.image.boxes.add(this.subject);
            this.status = 'awaitingExecute';
            resolve();
        });
    }
    execute(pos) {
        return new Promise((resolve, reject) => {
            if (!this.pos || !['awaitingExecute', 'executing'].includes(this.status)) {
                this.status = 'executionFailed';
                return reject("Unable to create box.");
            }
            this.subject.rect.width(0 - this.pos.x + pos.x);
            this.subject.rect.height(0 - this.pos.y + pos.y);
            this.subject.updateAnchorsPosition();
            this.status = 'executing';
            resolve();
        });
    }
    undo() {
        return new Promise((resolve, reject) => {
            if (this.status !== 'finish') {
                this.status = 'undoFailed';
                return reject("Unable to undo, action execution is not finished yet.");
            }
            this.subject.remove();
            this.image?.boxes.delete(this.subject);
            this.status = 'undo';
            resolve();
        });
    }
    redo() {
        return new Promise((resolve, reject) => {
            if (this.status !== "undo") {
                this.status = 'redoFailed';
                return reject("Unable to redo. Undo is not finished yet.");
            }
            this.image?.editor?.layer?.add(this.subject);
            this.image?.boxes.add(this.subject);
            this.status = 'finish';
            resolve();
        });
    }
}

class ActionsStore {
    constructor() {
        this.ActionsList = [];
        this.index = -1;
        this.maxLength = 10;
    }
    push(action) {
        this.index += 1;
        this.ActionsList[this.index] = action;
        if (this.ActionsList.length > this.maxLength) {
            this.ActionsList.shift();
            this.index -= 1;
        }
    }
    undo() {
        return new Promise((resolve, reject) => {
            if (this.index === -1)
                return reject("No more action to undo.");
            this.ActionsList[this.index].undo().then(() => {
                this.index -= 1;
                resolve();
            });
        });
    }
    redo() {
        return new Promise((resolve, reject) => {
            if (this.ActionsList.length === this.index + 1)
                return reject("No more action to redo.");
            this.ActionsList[this.index + 1].redo().then(() => {
                this.index += 1;
                resolve();
            });
        });
    }
}

let Image$1 = class Image extends Konva.Image {
    constructor(config) {
        super(config);
        this.src = "";
        this.editor = null;
        this.boxes = new Set();
        this.createBoxAction = null;
        this.actionStore = new ActionsStore();
        this.init(config);
        this.on("mousedown", this.mouseDownAction.bind(this));
        this.on("mousemove", this.mouseMoveAction.bind(this));
        this.on("mouseup", this.mouseUpAction.bind(this));
        this.on('mouseenter', this.mouseEnterAction.bind(this));
        this.on('mouseleave', this.mouseLeaveAction.bind(this));
        this.cache();
    }
    init(config) {
        this.src = config.src;
        this.editor = config.editor;
        if (config.imBoxes) {
            config.imBoxes.forEach(imBox => this.addImBox(imBox));
        }
    }
    addImBox(imBox) {
        const box = new Box({
            ...imBox,
            draggable: true,
            listening: false,
            image: this,
        });
        this.boxes.add(box);
    }
    renderBoxes() {
        [...this.boxes].forEach(box => {
            this.editor?.layer?.add(box);
            box.moveToTop();
        });
    }
    async mouseDownAction(event) {
        try {
            if (this.editor?.appMode.mode !== "DRAWING_MODE" || this.createBoxAction !== null || event.evt.which !== 1)
                return;
            this.editor?.hideCrossHairs();
            const pos = this.editor?.getRelativePointerPosition();
            this.createBoxAction = new CreateBoxAction({ pos, image: this, actionsStore: this.actionStore });
            await this.createBoxAction.build();
        }
        catch (error) {
            console.log(error);
        }
    }
    async mouseMoveAction(event) {
        try {
            if (this.editor?.appMode.mode !== "DRAWING_MODE" || this.createBoxAction === null)
                return;
            const pos = this.editor?.getRelativePointerPosition();
            await this.createBoxAction.execute(pos);
        }
        catch (error) {
            console.log(error);
        }
    }
    async mouseUpAction(event) {
        try {
            if (this.editor?.appMode.mode !== "DRAWING_MODE" || this.createBoxAction === null)
                return;
            this.editor?.showCrossHairs();
            await this.createBoxAction.finish();
            if (this.createBoxAction.subject?.rect?.width() === 0 || this.createBoxAction.subject?.rect?.height() === 0) {
                await this.createBoxAction.undo();
                await this.createBoxAction.destroy();
                this.createBoxAction = null;
                return;
            }
            this.editor?.setMode({
                mode: "EDIT_MODE",
                boxInEditMode: this.createBoxAction.subject,
                visible: true
            });
            this.createBoxAction = null;
        }
        catch (error) {
            console.log(error);
        }
    }
    mouseEnterAction(event) {
        this.editor?.updateCursorStyle(this);
    }
    mouseLeaveAction(event) {
        this.editor?.updateCursorStyle();
    }
};

class RemoveBoxAction extends Action {
    constructor(config) {
        super(config.box, config.actionsStore, config.parent);
        this.editor = null;
        this.image = this.subject.image;
        this.editor = this.subject.image?.editor;
    }
    build() {
        return new Promise((resolve, reject) => {
            if (this.status !== "awaitingBuild") {
                this.status = 'buildFailed';
                return reject("Unable to create box.");
            }
            this.status = 'awaitingExecute';
            resolve();
        });
    }
    execute() {
        return new Promise((resolve, reject) => {
            if (!this.editor || !['awaitingExecute', 'executing'].includes(this.status)) {
                this.status = 'executionFailed';
                return reject("Unable to create box.");
            }
            this.image?.boxes.delete(this.subject);
            this.subject.remove();
            this.status = 'executing';
            resolve();
        });
    }
    undo() {
        return new Promise((resolve, reject) => {
            if (!this.editor || this.status !== 'finish') {
                this.status = 'undoFailed';
                return reject("Unable to undo, action execution is not finished yet.");
            }
            this.editor.layer?.add(this.subject);
            this.image?.boxes.add(this.subject);
            this.status = 'undo';
            resolve();
        });
    }
    redo() {
        return new Promise((resolve, reject) => {
            if (!this.editor || this.status !== "undo") {
                this.status = 'redoFailed';
                return reject("Unable to redo. Undo is not finished yet.");
            }
            this.image?.boxes.delete(this.subject);
            this.subject.remove();
            this.status = 'finish';
            resolve();
        });
    }
}

class Editor extends Konva.Stage {
    constructor(config) {
        super(config);
        this.layer = null;
        this.images = [];
        this.activeImage = null;
        this._zoomStep = 1.1;
        this.spacingLeft = 0;
        this.appMode = {
            mode: "DRAWING_MODE"
        };
        this.crosshairLines = [new Konva.Line(), new Konva.Line()];
        this.keyDownAction = async (event) => {
            try {
                if (this.appMode.mode === 'EDIT_MODE') {
                    if (event.key === 'Delete') {
                        await new RemoveBoxAction({ box: this.appMode.boxInEditMode, actionsStore: this.appMode.boxInEditMode.image?.actionStore }).directExecute();
                        this.setMode({
                            mode: "DRAWING_MODE"
                        });
                    }
                }
                if (event.ctrlKey) {
                    if (this.appMode.mode !== 'EDIT_MODE') {
                        this.setMode({
                            mode: "DRAG_SELECTION_MODE"
                        });
                        setTimeout(() => {
                            const target = this.getIntersection(this.getPointerPosition());
                            target instanceof Box && target.showAnchors();
                            target instanceof Rect_2 && target.parent.showAnchors();
                        }, 50);
                    }
                    if (event.key === 'z' || event.key === 'Z') {
                        await this.activeImage?.actionStore.undo();
                    }
                    if (event.key === 'y' || event.key === 'Y') {
                        await this.activeImage?.actionStore.redo();
                    }
                }
            }
            catch (error) {
                console.log(error);
            }
        };
        this.keyUpAction = (event) => {
            if (!event.ctrlKey) {
                if (this.appMode.mode !== 'EDIT_MODE')
                    this.setMode({
                        mode: "DRAWING_MODE"
                    });
            }
        };
        this.mouseMoveAction = (event) => {
            this.setPointersPositions(event);
            this.renderCrossHair();
        };
        this.zoomInOutStage = (event, position = this.getPointerPosition(), newPosition) => {
            event.preventDefault();
            if (this.appMode.mode === 'EDIT_MODE')
                return;
            if (event.ctrlKey) {
                const oldScale = this.scaleX();
                const mousePointTo = {
                    x: position.x / oldScale - this.x() / oldScale,
                    y: position.y / oldScale - this.y() / oldScale
                };
                const newScale = event.deltaY <= 0 ? oldScale * this._zoomStep : oldScale / this._zoomStep;
                this.scale({ x: newScale, y: newScale });
                this.scaleAnchors();
                const updatedPosition = newPosition || this.getPointerPosition();
                const newPos = {
                    x: -(mousePointTo.x - updatedPosition.x / newScale) * newScale,
                    y: -(mousePointTo.y - updatedPosition.y / newScale) * newScale
                };
                this.position(newPos);
            }
            else if (event.shiftKey) {
                let moveByX = this.scaleY() * event.deltaY;
                let moveByY = this.scaleX() * event.deltaX;
                this.y(this.y() - moveByY);
                this.x(this.x() - moveByX);
            }
            else {
                let moveByY = this.scaleY() * event.deltaY;
                let moveByX = this.scaleX() * event.deltaX;
                this.y(this.y() - moveByY);
                this.x(this.x() - moveByX);
            }
            this.renderCrossHair();
        };
        this.init(config);
        this.container().addEventListener("wheel", this.zoomInOutStage);
        document.addEventListener("keydown", this.keyDownAction);
        document.addEventListener("keyup", this.keyUpAction);
        document.addEventListener("mousemove", this.mouseMoveAction);
        this.on("dragstart", this.dragStartAction.bind(this));
        this.on("dragend", this.dragEndAction.bind(this));
        this.on("click", () => {
            console.log(this.getRelativePointerPosition());
        });
    }
    importEditorState(editorState) {
        return new Promise((resolve, reject) => {
            setRecoil_1(loaderAtom, { visible: true, title: "Importing image..." });
            Promise.all(editorState.map(imState => this.addImage(imState.image, imState.boxes)))
                .then(() => {
                this.syncImageList();
                this.loadFirstImageIfRequired();
                resolve();
            }).catch((err) => console.log(err)).finally(() => {
                setRecoil_1(loaderAtom, { visible: false });
            });
        });
    }
    exportEditorState() {
        return this.images.map(image => ({
            image: {
                id: image.id(),
                src: image.src,
                name: image.name()
            },
            boxes: [...image.boxes].map(box => {
                box.getClientRect();
                return ({
                    x: box.x(),
                    y: box.y(),
                    width: box.rect?.width(),
                    height: box.rect?.height(),
                    label: box?.label || ""
                });
            })
        }));
    }
    destructor() {
        this.container().removeEventListener("wheel", this.zoomInOutStage);
        document.removeEventListener("keydown", this.keyDownAction);
        document.removeEventListener("keyup", this.keyUpAction);
        document.removeEventListener("mousemove", this.mouseMoveAction);
    }
    init(config) {
        this.spacingLeft = config?.spacingLeft || 0;
        this.layer = new Konva.Layer();
        this.crosshairLines = [new Konva.Line({
                points: [0, 100, 1000, 100],
                stroke: '#424242',
                strokeWidth: 2,
                dash: [10, 5],
                listening: false,
                strokeScaleEnabled: false,
                visible: false
            }), new Konva.Line({
                points: [0, 0, 0, this.height()],
                stroke: '#424242',
                strokeWidth: 2,
                dash: [10, 5],
                listening: false,
                strokeScaleEnabled: false,
                visible: false
            })];
        this.layer.add(this.crosshairLines[0], this.crosshairLines[1]);
        this.add(this.layer);
        this.loadFirstImageIfRequired();
    }
    loadFirstImageIfRequired() {
        return new Promise((resolve, reject) => {
            if (!this.activeImage && this.images.length) {
                this.loadImage(this.images[0]).then(() => {
                    this.images[0].renderBoxes();
                    resolve();
                });
            }
        });
    }
    dragStartAction(event) {
        this.updateCursorStyle(null);
    }
    dragEndAction(event) {
        this.updateCursorStyle(null);
    }
    renderCrossHair() {
        const bBox = this.getRelativeBBoxOfStage();
        const { x, y } = this.getRelativePointerPosition();
        this.crosshairLines[0].points([bBox.l, y, bBox.r, y]);
        this.crosshairLines[1].points([x, bBox.t, x, bBox.b]);
        this.crosshairLines[0].moveToTop();
        this.crosshairLines[1].moveToTop();
        this.layer?.batchDraw();
    }
    addImage(imImage, imBoxes) {
        return new Promise((resolve, reject) => {
            let pos = { x: 0, y: 0 };
            // if(this.activeImage) {
            //     const padding = 100;
            //     pos = {
            //         x: this.activeImage.x() + this.activeImage.width() + padding,
            //         y: 0
            //     }
            // }
            const image = new window.Image();
            image.crossOrigin = 'Anonymous';
            image.src = imImage.src;
            image.onload = (e) => {
                const img = new Image$1({
                    id: imImage.id,
                    name: imImage.name,
                    src: imImage.src,
                    x: pos.x,
                    y: pos.y,
                    fill: 'white',
                    draggable: false,
                    image: image,
                    editor: this,
                    imBoxes
                });
                this.images.unshift(img);
                resolve(img);
            };
            image.onerror = reject;
        });
    }
    removeActiveImage() {
        this.activeImage?.remove();
        this.activeImage = null;
    }
    loadImage(image) {
        return new Promise((resolve, reject) => {
            setRecoil_1(loaderAtom, { visible: true, title: "Loading Image..." });
            this.syncActiveImage(image);
            if (this.activeImage) {
                this.removeActiveImage();
            }
            this.activeImage = image;
            this.layer?.add(image);
            this.fitToScreen();
            image.renderBoxes();
            this.showCrossHairs();
            setRecoil_1(loaderAtom, { visible: false });
        });
    }
    extractBBoxes() {
        const [pos, scale] = [this.position(), this.scale()];
        this.resetZoom();
        const allSelectionBoxes = this.images.reduce((acc, curr) => {
            return [...acc, ...curr.boxes];
        }, []);
        const bBoxesWithLabels = [...allSelectionBoxes].filter(box => box.label !== "").map(box => ({
            box: {
                x: box.x(),
                y: box.y(),
                width: box.rect.width(),
                height: box.rect.height()
            },
            label: box.label
        }));
        this.position(pos);
        this.scale(scale);
        return bBoxesWithLabels;
    }
    extractCutOuts() {
        const [pos, scale] = [this.position(), this.scale()];
        this.resetZoom();
        const allSelectionBoxes = this.images.reduce((acc, curr) => {
            return [...acc, ...curr.boxes];
        }, []);
        const cutOutsBase64 = [...allSelectionBoxes].filter(box => box.label !== "").map(box => {
            const pos = box?.rect?.getClientRect();
            return {
                base64: box?.image?.toDataURL({
                    x: pos.x,
                    y: pos.y,
                    width: pos.width,
                    height: pos.height
                }) || "",
                label: box.label
            };
        });
        this.position(pos);
        this.scale(scale);
        return cutOutsBase64;
    }
    scaleAnchors() {
        this.activeImage?.boxes.forEach(box => {
            box.updateAnchorsScale();
        });
    }
    resetZoom() {
        this.scale({ x: 1, y: 1 });
        this.position({ x: 0, y: 0 });
    }
    fitToScreen() {
        if (!this.activeImage)
            return;
        const paddingLeftRight = 2000;
        const paddingTopBottom = 100;
        const additionalPaddingLeft = this.spacingLeft;
        const additionalPaddingTop = 55;
        const newScale = Math.min((this.width() - additionalPaddingLeft) / ((this.activeImage.x() + this.activeImage.width()) + paddingLeftRight), (this.height() - additionalPaddingTop) / ((this.activeImage.y() + this.activeImage.height()) + paddingTopBottom));
        this.setAttrs({
            x: this.width() / 2 - ((this.activeImage.x() + this.activeImage.width()) / 2 * newScale) + additionalPaddingLeft / 2,
            y: this.height() / 2 - ((this.activeImage.y() + this.activeImage.height()) / 2 * newScale) + additionalPaddingTop / 2,
            scaleX: newScale,
            scaleY: newScale
        });
        this.scaleAnchors();
    }
    syncActiveImage(image) {
        setRecoil_1(activeImageAtom, image);
    }
    syncImageList() {
        setRecoil_1(imageListAtom, [...this.images]);
    }
    getRelativeBBoxOfStage() {
        const scale = this.scale();
        return {
            l: -this.x() / scale.x,
            r: (this.width() - this.x()) / scale.x,
            t: -this.y() / scale.y,
            b: (this.height() - this.y()) / scale.y
        };
    }
    hideCrossHairs() {
        this.crosshairLines.forEach(line => line.hide());
    }
    showCrossHairs() {
        this.crosshairLines.forEach(line => line.show());
    }
    setSelectionBoxesListening(listen, filter = () => true) {
        this.activeImage?.boxes.forEach(box => (filter(box)) ? box.listening(listen) : null);
    }
    updateCursorStyle(target) {
        if (!target) {
            target = this.getIntersection(this.getPointerPosition());
        }
        let cursor = 'default';
        if (this.appMode.mode === "DRAG_SELECTION_MODE") {
            if (target instanceof Anchor) {
                ['top-left', 'bottom-right'].includes(target.name()) ? cursor = 'nwse-resize' : cursor = 'nesw-resize';
            }
            else if (target instanceof Box || target instanceof Rect_2) {
                cursor = 'move';
            }
            else if (target instanceof Image$1 || target === null) {
                if (this.isDragging()) {
                    cursor = 'grabbing';
                }
                else {
                    cursor = 'grab';
                }
            }
        }
        else if (this.appMode.mode === "EDIT_MODE") {
            if (target instanceof Anchor) {
                ['top-left', 'bottom-right'].includes(target.name()) ? cursor = 'nwse-resize' : cursor = 'nesw-resize';
            }
            else if (target instanceof Box || target instanceof Rect_2) {
                cursor = 'move';
            }
            else {
                cursor = 'default';
            }
        }
        else if (this.appMode.mode === "DRAWING_MODE") {
            if (!target) {
                cursor = 'default';
            }
            else {
                cursor = 'crosshair';
            }
        }
        this.container().style.cursor = cursor;
    }
    setMode(appMode) {
        if (appMode.mode === 'DRAG_SELECTION_MODE') {
            this.setSelectionBoxesListening(true);
            this.hideCrossHairs();
            this.draggable(true);
        }
        else if (appMode.mode === 'EDIT_MODE') {
            this.hideCrossHairs();
            this.setSelectionBoxesListening(false);
            appMode.boxInEditMode.showAnchors();
            appMode.boxInEditMode.listening(true);
            this.draggable(false);
        }
        else if (appMode.mode === 'DRAWING_MODE') {
            this.draggable(false);
            this.showCrossHairs();
            this.activeImage?.boxes.forEach(box => box.hideAnchors());
            this.setSelectionBoxesListening(false);
        }
        this.appMode = appMode;
        setRecoil_1(appModeAtom, appMode);
        setTimeout(() => {
            this.updateCursorStyle();
        }, 50);
    }
}

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

function _typeof$1(obj) {
  "@babel/helpers - typeof";

  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$1(obj);
}

function _toPrimitive(input, hint) {
  if (_typeof$1(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof$1(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}

function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof$1(key) === "symbol" ? key : String(key);
}

function _defineProperty$1(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof$1(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}

var classnames = {exports: {}};

/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/

(function (module) {
	/* global define */

	(function () {

		var hasOwn = {}.hasOwnProperty;

		function classNames() {
			var classes = [];

			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;

				var argType = typeof arg;

				if (argType === 'string' || argType === 'number') {
					classes.push(arg);
				} else if (Array.isArray(arg)) {
					if (arg.length) {
						var inner = classNames.apply(null, arg);
						if (inner) {
							classes.push(inner);
						}
					}
				} else if (argType === 'object') {
					if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {
						classes.push(arg.toString());
						continue;
					}

					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				}
			}

			return classes.join(' ');
		}

		if (module.exports) {
			classNames.default = classNames;
			module.exports = classNames;
		} else {
			window.classNames = classNames;
		}
	}()); 
} (classnames));

var classnamesExports = classnames.exports;
var classNames = /*@__PURE__*/getDefaultExportFromCjs(classnamesExports);

var reactIs = {exports: {}};

var reactIs_production_min = {};

/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_production_min;

function requireReactIs_production_min () {
	if (hasRequiredReactIs_production_min) return reactIs_production_min;
	hasRequiredReactIs_production_min = 1;
var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
	Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
	function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}reactIs_production_min.AsyncMode=l;reactIs_production_min.ConcurrentMode=m;reactIs_production_min.ContextConsumer=k;reactIs_production_min.ContextProvider=h;reactIs_production_min.Element=c;reactIs_production_min.ForwardRef=n;reactIs_production_min.Fragment=e;reactIs_production_min.Lazy=t;reactIs_production_min.Memo=r;reactIs_production_min.Portal=d;
	reactIs_production_min.Profiler=g;reactIs_production_min.StrictMode=f;reactIs_production_min.Suspense=p;reactIs_production_min.isAsyncMode=function(a){return A(a)||z(a)===l};reactIs_production_min.isConcurrentMode=A;reactIs_production_min.isContextConsumer=function(a){return z(a)===k};reactIs_production_min.isContextProvider=function(a){return z(a)===h};reactIs_production_min.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};reactIs_production_min.isForwardRef=function(a){return z(a)===n};reactIs_production_min.isFragment=function(a){return z(a)===e};reactIs_production_min.isLazy=function(a){return z(a)===t};
	reactIs_production_min.isMemo=function(a){return z(a)===r};reactIs_production_min.isPortal=function(a){return z(a)===d};reactIs_production_min.isProfiler=function(a){return z(a)===g};reactIs_production_min.isStrictMode=function(a){return z(a)===f};reactIs_production_min.isSuspense=function(a){return z(a)===p};
	reactIs_production_min.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};reactIs_production_min.typeOf=z;
	return reactIs_production_min;
}

var reactIs_development = {};

var hasRequiredReactIs_development;

function requireReactIs_development () {
	if (hasRequiredReactIs_development) return reactIs_development;
	hasRequiredReactIs_development = 1;



	if (process.env.NODE_ENV !== "production") {
	  (function() {

	// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var hasSymbol = typeof Symbol === 'function' && Symbol.for;
	var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
	var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
	var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
	var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
	var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
	var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
	var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
	// (unstable) APIs that have been removed. Can we remove the symbols?

	var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
	var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
	var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
	var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
	var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
	var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
	var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
	var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
	var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
	var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
	var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

	function isValidElementType(type) {
	  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
	  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
	}

	function typeOf(object) {
	  if (typeof object === 'object' && object !== null) {
	    var $$typeof = object.$$typeof;

	    switch ($$typeof) {
	      case REACT_ELEMENT_TYPE:
	        var type = object.type;

	        switch (type) {
	          case REACT_ASYNC_MODE_TYPE:
	          case REACT_CONCURRENT_MODE_TYPE:
	          case REACT_FRAGMENT_TYPE:
	          case REACT_PROFILER_TYPE:
	          case REACT_STRICT_MODE_TYPE:
	          case REACT_SUSPENSE_TYPE:
	            return type;

	          default:
	            var $$typeofType = type && type.$$typeof;

	            switch ($$typeofType) {
	              case REACT_CONTEXT_TYPE:
	              case REACT_FORWARD_REF_TYPE:
	              case REACT_LAZY_TYPE:
	              case REACT_MEMO_TYPE:
	              case REACT_PROVIDER_TYPE:
	                return $$typeofType;

	              default:
	                return $$typeof;
	            }

	        }

	      case REACT_PORTAL_TYPE:
	        return $$typeof;
	    }
	  }

	  return undefined;
	} // AsyncMode is deprecated along with isAsyncMode

	var AsyncMode = REACT_ASYNC_MODE_TYPE;
	var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
	var ContextConsumer = REACT_CONTEXT_TYPE;
	var ContextProvider = REACT_PROVIDER_TYPE;
	var Element = REACT_ELEMENT_TYPE;
	var ForwardRef = REACT_FORWARD_REF_TYPE;
	var Fragment = REACT_FRAGMENT_TYPE;
	var Lazy = REACT_LAZY_TYPE;
	var Memo = REACT_MEMO_TYPE;
	var Portal = REACT_PORTAL_TYPE;
	var Profiler = REACT_PROFILER_TYPE;
	var StrictMode = REACT_STRICT_MODE_TYPE;
	var Suspense = REACT_SUSPENSE_TYPE;
	var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

	function isAsyncMode(object) {
	  {
	    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
	      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

	      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
	    }
	  }

	  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
	}
	function isConcurrentMode(object) {
	  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
	}
	function isContextConsumer(object) {
	  return typeOf(object) === REACT_CONTEXT_TYPE;
	}
	function isContextProvider(object) {
	  return typeOf(object) === REACT_PROVIDER_TYPE;
	}
	function isElement(object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	}
	function isForwardRef(object) {
	  return typeOf(object) === REACT_FORWARD_REF_TYPE;
	}
	function isFragment(object) {
	  return typeOf(object) === REACT_FRAGMENT_TYPE;
	}
	function isLazy(object) {
	  return typeOf(object) === REACT_LAZY_TYPE;
	}
	function isMemo(object) {
	  return typeOf(object) === REACT_MEMO_TYPE;
	}
	function isPortal(object) {
	  return typeOf(object) === REACT_PORTAL_TYPE;
	}
	function isProfiler(object) {
	  return typeOf(object) === REACT_PROFILER_TYPE;
	}
	function isStrictMode(object) {
	  return typeOf(object) === REACT_STRICT_MODE_TYPE;
	}
	function isSuspense(object) {
	  return typeOf(object) === REACT_SUSPENSE_TYPE;
	}

	reactIs_development.AsyncMode = AsyncMode;
	reactIs_development.ConcurrentMode = ConcurrentMode;
	reactIs_development.ContextConsumer = ContextConsumer;
	reactIs_development.ContextProvider = ContextProvider;
	reactIs_development.Element = Element;
	reactIs_development.ForwardRef = ForwardRef;
	reactIs_development.Fragment = Fragment;
	reactIs_development.Lazy = Lazy;
	reactIs_development.Memo = Memo;
	reactIs_development.Portal = Portal;
	reactIs_development.Profiler = Profiler;
	reactIs_development.StrictMode = StrictMode;
	reactIs_development.Suspense = Suspense;
	reactIs_development.isAsyncMode = isAsyncMode;
	reactIs_development.isConcurrentMode = isConcurrentMode;
	reactIs_development.isContextConsumer = isContextConsumer;
	reactIs_development.isContextProvider = isContextProvider;
	reactIs_development.isElement = isElement;
	reactIs_development.isForwardRef = isForwardRef;
	reactIs_development.isFragment = isFragment;
	reactIs_development.isLazy = isLazy;
	reactIs_development.isMemo = isMemo;
	reactIs_development.isPortal = isPortal;
	reactIs_development.isProfiler = isProfiler;
	reactIs_development.isStrictMode = isStrictMode;
	reactIs_development.isSuspense = isSuspense;
	reactIs_development.isValidElementType = isValidElementType;
	reactIs_development.typeOf = typeOf;
	  })();
	}
	return reactIs_development;
}

if (process.env.NODE_ENV === 'production') {
  reactIs.exports = requireReactIs_production_min();
} else {
  reactIs.exports = requireReactIs_development();
}

var reactIsExports = reactIs.exports;

/* eslint-disable no-console */
var warned = {};
var preWarningFns = [];

/**
 * Pre warning enable you to parse content before console.error.
 * Modify to null will prevent warning.
 */
var preMessage = function preMessage(fn) {
  preWarningFns.push(fn);
};
function warning$3(valid, message) {
  // Support uglify
  if (process.env.NODE_ENV !== 'production' && !valid && console !== undefined) {
    var finalMessage = preWarningFns.reduce(function (msg, preMessageFn) {
      return preMessageFn(msg !== null && msg !== void 0 ? msg : '', 'warning');
    }, message);
    if (finalMessage) {
      console.error("Warning: ".concat(finalMessage));
    }
  }
}
function note(valid, message) {
  // Support uglify
  if (process.env.NODE_ENV !== 'production' && !valid && console !== undefined) {
    var finalMessage = preWarningFns.reduce(function (msg, preMessageFn) {
      return preMessageFn(msg !== null && msg !== void 0 ? msg : '', 'note');
    }, message);
    if (finalMessage) {
      console.warn("Note: ".concat(finalMessage));
    }
  }
}
function resetWarned() {
  warned = {};
}
function call(method, valid, message) {
  if (!valid && !warned[message]) {
    method(false, message);
    warned[message] = true;
  }
}
function warningOnce(valid, message) {
  call(warning$3, valid, message);
}
function noteOnce(valid, message) {
  call(note, valid, message);
}
warningOnce.preMessage = preMessage;
warningOnce.resetWarned = resetWarned;
warningOnce.noteOnce = noteOnce;
/* eslint-enable */

function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {
      _defineProperty$1(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}

function fillRef(ref, node) {
  if (typeof ref === 'function') {
    ref(node);
  } else if (_typeof$1(ref) === 'object' && ref && 'current' in ref) {
    ref.current = node;
  }
}

/**
 * Merge refs into one ref function to support ref passing.
 */
function composeRef() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  var refList = refs.filter(function (ref) {
    return ref;
  });
  if (refList.length <= 1) {
    return refList[0];
  }
  return function (node) {
    refs.forEach(function (ref) {
      fillRef(ref, node);
    });
  };
}
function supportRef(nodeOrComponent) {
  var _type$prototype, _nodeOrComponent$prot;
  var type = reactIsExports.isMemo(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;

  // Function component node
  if (typeof type === 'function' && !((_type$prototype = type.prototype) !== null && _type$prototype !== void 0 && _type$prototype.render)) {
    return false;
  }

  // Class component
  if (typeof nodeOrComponent === 'function' && !((_nodeOrComponent$prot = nodeOrComponent.prototype) !== null && _nodeOrComponent$prot !== void 0 && _nodeOrComponent$prot.render)) {
    return false;
  }
  return true;
}
/* eslint-enable */

function isDOM(node) {
  // https://developer.mozilla.org/en-US/docs/Web/API/Element
  // Since XULElement is also subclass of Element, we only need HTMLElement and SVGElement
  return node instanceof HTMLElement || node instanceof SVGElement;
}

/**
 * Return if a node is a DOM node. Else will return by `findDOMNode`
 */
function findDOMNode(node) {
  if (isDOM(node)) {
    return node;
  }
  if (node instanceof React.Component) {
    return ReactDOM.findDOMNode(node);
  }
  return null;
}

/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */
/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = (function () {
    if (typeof Map !== 'undefined') {
        return Map;
    }
    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */
    function getIndex(arr, key) {
        var result = -1;
        arr.some(function (entry, index) {
            if (entry[0] === key) {
                result = index;
                return true;
            }
            return false;
        });
        return result;
    }
    return /** @class */ (function () {
        function class_1() {
            this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function () {
                return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {*} key
         * @returns {*}
         */
        class_1.prototype.get = function (key) {
            var index = getIndex(this.__entries__, key);
            var entry = this.__entries__[index];
            return entry && entry[1];
        };
        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */
        class_1.prototype.set = function (key, value) {
            var index = getIndex(this.__entries__, key);
            if (~index) {
                this.__entries__[index][1] = value;
            }
            else {
                this.__entries__.push([key, value]);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.delete = function (key) {
            var entries = this.__entries__;
            var index = getIndex(entries, key);
            if (~index) {
                entries.splice(index, 1);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.has = function (key) {
            return !!~getIndex(this.__entries__, key);
        };
        /**
         * @returns {void}
         */
        class_1.prototype.clear = function () {
            this.__entries__.splice(0);
        };
        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */
        class_1.prototype.forEach = function (callback, ctx) {
            if (ctx === void 0) { ctx = null; }
            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                var entry = _a[_i];
                callback.call(ctx, entry[1], entry[0]);
            }
        };
        return class_1;
    }());
})();

/**
 * Detects whether window and document objects are available in current environment.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

// Returns global object of a current environment.
var global$1 = (function () {
    if (typeof global$2 !== 'undefined' && global$2.Math === Math) {
        return global$2;
    }
    if (typeof self !== 'undefined' && self.Math === Math) {
        return self;
    }
    if (typeof window !== 'undefined' && window.Math === Math) {
        return window;
    }
    // eslint-disable-next-line no-new-func
    return Function('return this')();
})();

/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */
var requestAnimationFrame$1 = (function () {
    if (typeof requestAnimationFrame === 'function') {
        // It's required to use a bounded function because IE sometimes throws
        // an "Invalid calling object" error if rAF is invoked without the global
        // object on the left hand side.
        return requestAnimationFrame.bind(global$1);
    }
    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
})();

// Defines minimum timeout before adding a trailing call.
var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */
function throttle (callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */
    function resolvePending() {
        if (leadingCall) {
            leadingCall = false;
            callback();
        }
        if (trailingCall) {
            proxy();
        }
    }
    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */
    function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
    }
    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */
    function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
            // Reject immediately following calls.
            if (timeStamp - lastCallTime < trailingTimeout) {
                return;
            }
            // Schedule new call to be in invoked when the pending one is resolved.
            // This is important for "transitions" which never actually start
            // immediately so there is a chance that we might miss one if change
            // happens amids the pending invocation.
            trailingCall = true;
        }
        else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
    }
    return proxy;
}

// Minimum delay before invoking the update of observers.
var REFRESH_DELAY = 20;
// A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.
var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
// Check if MutationObserver is available.
var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */
var ResizeObserverController = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */
    function ResizeObserverController() {
        /**
         * Indicates whether DOM listeners have been added.
         *
         * @private {boolean}
         */
        this.connected_ = false;
        /**
         * Tells that controller has subscribed for Mutation Events.
         *
         * @private {boolean}
         */
        this.mutationEventsAdded_ = false;
        /**
         * Keeps reference to the instance of MutationObserver.
         *
         * @private {MutationObserver}
         */
        this.mutationsObserver_ = null;
        /**
         * A list of connected observers.
         *
         * @private {Array<ResizeObserverSPI>}
         */
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */
    ResizeObserverController.prototype.addObserver = function (observer) {
        if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
        }
        // Add listeners if they haven't been added yet.
        if (!this.connected_) {
            this.connect_();
        }
    };
    /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */
    ResizeObserverController.prototype.removeObserver = function (observer) {
        var observers = this.observers_;
        var index = observers.indexOf(observer);
        // Remove observer if it's present in registry.
        if (~index) {
            observers.splice(index, 1);
        }
        // Remove listeners if controller has no connected observers.
        if (!observers.length && this.connected_) {
            this.disconnect_();
        }
    };
    /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */
    ResizeObserverController.prototype.refresh = function () {
        var changesDetected = this.updateObservers_();
        // Continue running updates if changes have been detected as there might
        // be future ones caused by CSS transitions.
        if (changesDetected) {
            this.refresh();
        }
    };
    /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */
    ResizeObserverController.prototype.updateObservers_ = function () {
        // Collect observers that have active observations.
        var activeObservers = this.observers_.filter(function (observer) {
            return observer.gatherActive(), observer.hasActive();
        });
        // Deliver notifications in a separate cycle in order to avoid any
        // collisions between observers, e.g. when multiple instances of
        // ResizeObserver are tracking the same element and the callback of one
        // of them changes content dimensions of the observed target. Sometimes
        // this may result in notifications being blocked for the rest of observers.
        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
        return activeObservers.length > 0;
    };
    /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.connect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already added.
        if (!isBrowser || this.connected_) {
            return;
        }
        // Subscription to the "Transitionend" event is used as a workaround for
        // delayed transitions. This way it's possible to capture at least the
        // final state of an element.
        document.addEventListener('transitionend', this.onTransitionEnd_);
        window.addEventListener('resize', this.refresh);
        if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
            });
        }
        else {
            document.addEventListener('DOMSubtreeModified', this.refresh);
            this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
    };
    /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.disconnect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already removed.
        if (!isBrowser || !this.connected_) {
            return;
        }
        document.removeEventListener('transitionend', this.onTransitionEnd_);
        window.removeEventListener('resize', this.refresh);
        if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
            document.removeEventListener('DOMSubtreeModified', this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
    };
    /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */
    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
        // Detect whether transition may affect dimensions of an element.
        var isReflowProperty = transitionKeys.some(function (key) {
            return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
            this.refresh();
        }
    };
    /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */
    ResizeObserverController.getInstance = function () {
        if (!this.instance_) {
            this.instance_ = new ResizeObserverController();
        }
        return this.instance_;
    };
    /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */
    ResizeObserverController.instance_ = null;
    return ResizeObserverController;
}());

/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */
var defineConfigurable = (function (target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    return target;
});

/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */
var getWindowOf = (function (target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    // Return the local global object if it's not possible extract one from
    // provided element.
    return ownerGlobal || global$1;
});

// Placeholder of an empty content rectangle.
var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */
function toFloat(value) {
    return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */
function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function (size, position) {
        var value = styles['border-' + position + '-width'];
        return size + toFloat(value);
    }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */
function getPaddings(styles) {
    var positions = ['top', 'right', 'bottom', 'left'];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position = positions_1[_i];
        var value = styles['padding-' + position];
        paddings[position] = toFloat(value);
    }
    return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */
function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */
function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.
    if (!clientWidth && !clientHeight) {
        return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.
    var width = toFloat(styles.width), height = toFloat(styles.height);
    // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).
    if (styles.boxSizing === 'border-box') {
        // Following conditions are required to handle Internet Explorer which
        // doesn't include paddings and borders to computed CSS dimensions.
        //
        // We can say that if CSS dimensions + paddings are equal to the "client"
        // properties then it's either IE, and thus we don't need to subtract
        // anything, or an element merely doesn't have paddings/borders styles.
        if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, 'left', 'right') + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
        }
    }
    // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.
    if (!isDocumentElement(target)) {
        // In some browsers (only in Firefox, actually) CSS width & height
        // include scroll bars size which can be removed at this step as scroll
        // bars are the only difference between rounded dimensions + paddings
        // and "client" properties, though that is not always true in Chrome.
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        // Chrome has a rather weird rounding of "client" properties.
        // E.g. for an element with content width of 314.2px it sometimes gives
        // the client width of 315px and for the width of 314.7px it may give
        // 314px. And it doesn't happen all the time. So just ignore this delta
        // as a non-relevant.
        if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
        }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
var isSVGGraphicsElement = (function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
    }
    // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens
    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
        typeof target.getBBox === 'function'); };
})();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */
function getContentRect(target) {
    if (!isBrowser) {
        return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */
function createReadOnlyRect(_a) {
    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    // If DOMRectReadOnly is available use it as a prototype for the rectangle.
    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    // Rectangle's properties are not writable and non-enumerable.
    defineConfigurable(rect, {
        x: x, y: y, width: width, height: height,
        top: y,
        right: x + width,
        bottom: height + y,
        left: x
    });
    return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */
function createRectInit(x, y, width, height) {
    return { x: x, y: y, width: width, height: height };
}

/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */
var ResizeObservation = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */
    function ResizeObservation(target) {
        /**
         * Broadcasted width of content rectangle.
         *
         * @type {number}
         */
        this.broadcastWidth = 0;
        /**
         * Broadcasted height of content rectangle.
         *
         * @type {number}
         */
        this.broadcastHeight = 0;
        /**
         * Reference to the last observed content rectangle.
         *
         * @private {DOMRectInit}
         */
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
    }
    /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */
    ResizeObservation.prototype.isActive = function () {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return (rect.width !== this.broadcastWidth ||
            rect.height !== this.broadcastHeight);
    };
    /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */
    ResizeObservation.prototype.broadcastRect = function () {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
    };
    return ResizeObservation;
}());

var ResizeObserverEntry = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */
    function ResizeObserverEntry(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        // According to the specification following properties are not writable
        // and are also not enumerable in the native implementation.
        //
        // Property accessors are not being used as they'd require to define a
        // private WeakMap storage which may cause memory leaks in browsers that
        // don't support this type of collections.
        defineConfigurable(this, { target: target, contentRect: contentRect });
    }
    return ResizeObserverEntry;
}());

var ResizeObserverSPI = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */
    function ResizeObserverSPI(callback, controller, callbackCtx) {
        /**
         * Collection of resize observations that have detected changes in dimensions
         * of elements.
         *
         * @private {Array<ResizeObservation>}
         */
        this.activeObservations_ = [];
        /**
         * Registry of the ResizeObservation instances.
         *
         * @private {Map<Element, ResizeObservation>}
         */
        this.observations_ = new MapShim();
        if (typeof callback !== 'function') {
            throw new TypeError('The callback provided as parameter 1 is not a function.');
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
    }
    /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.observe = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is already being observed.
        if (observations.has(target)) {
            return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        // Force the update of observations.
        this.controller_.refresh();
    };
    /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.unobserve = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is not being observed.
        if (!observations.has(target)) {
            return;
        }
        observations.delete(target);
        if (!observations.size) {
            this.controller_.removeObserver(this);
        }
    };
    /**
     * Stops observing all elements.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.disconnect = function () {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
    };
    /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.gatherActive = function () {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function (observation) {
            if (observation.isActive()) {
                _this.activeObservations_.push(observation);
            }
        });
    };
    /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.broadcastActive = function () {
        // Do nothing if observer doesn't have active observations.
        if (!this.hasActive()) {
            return;
        }
        var ctx = this.callbackCtx_;
        // Create ResizeObserverEntry instance for every active observation.
        var entries = this.activeObservations_.map(function (observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
    };
    /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
    };
    /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */
    ResizeObserverSPI.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI;
}());

// Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.
var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */
var ResizeObserver = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */
    function ResizeObserver(callback) {
        if (!(this instanceof ResizeObserver)) {
            throw new TypeError('Cannot call a class as a function.');
        }
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
    }
    return ResizeObserver;
}());
// Expose public methods of ResizeObserver.
[
    'observe',
    'unobserve',
    'disconnect'
].forEach(function (method) {
    ResizeObserver.prototype[method] = function () {
        var _a;
        return (_a = observers.get(this))[method].apply(_a, arguments);
    };
});

var index$1 = (function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
        return global$1.ResizeObserver;
    }
    return ResizeObserver;
})();

function omit(obj, fields) {
  var clone = _objectSpread2$1({}, obj);
  if (Array.isArray(fields)) {
    fields.forEach(function (key) {
      delete clone[key];
    });
  }
  return clone;
}

var IconContext$1 = /*#__PURE__*/React.createContext({});
var IconContext$2 = IconContext$1;

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function noop$1() {}
// eslint-disable-next-line import/no-mutable-exports
var warning$1 = noop$1;
if (process.env.NODE_ENV !== 'production') {
  warning$1 = function warning(valid, component, message) {
    warningOnce(valid, "[antd: ".concat(component, "] ").concat(message));
    // StrictMode will inject console which will not throw warning in React 17.
    if (process.env.NODE_ENV === 'test') {
      resetWarned();
    }
  };
}
var warning$2 = warning$1;

var enUS$1 = {
  // Options.jsx
  items_per_page: '/ page',
  jump_to: 'Go to',
  jump_to_confirm: 'confirm',
  page: 'Page',
  // Pagination.jsx
  prev_page: 'Previous Page',
  next_page: 'Next Page',
  prev_5: 'Previous 5 Pages',
  next_5: 'Next 5 Pages',
  prev_3: 'Previous 3 Pages',
  next_3: 'Next 3 Pages',
  page_size: 'Page Size'
};

var locale$2 = {
  locale: 'en_US',
  today: 'Today',
  now: 'Now',
  backToToday: 'Back to today',
  ok: 'OK',
  clear: 'Clear',
  month: 'Month',
  year: 'Year',
  timeSelect: 'select time',
  dateSelect: 'select date',
  weekSelect: 'Choose a week',
  monthSelect: 'Choose a month',
  yearSelect: 'Choose a year',
  decadeSelect: 'Choose a decade',
  yearFormat: 'YYYY',
  dateFormat: 'M/D/YYYY',
  dayFormat: 'D',
  dateTimeFormat: 'M/D/YYYY HH:mm:ss',
  monthBeforeYear: true,
  previousMonth: 'Previous month (PageUp)',
  nextMonth: 'Next month (PageDown)',
  previousYear: 'Last year (Control + left)',
  nextYear: 'Next year (Control + right)',
  previousDecade: 'Last decade',
  nextDecade: 'Next decade',
  previousCentury: 'Last century',
  nextCentury: 'Next century'
};

var locale$1 = {
  placeholder: 'Select time',
  rangePlaceholder: ['Start time', 'End time']
};
var TimePicker = locale$1;

// Merge into a locale object
var locale = {
  lang: _extends({
    placeholder: 'Select date',
    yearPlaceholder: 'Select year',
    quarterPlaceholder: 'Select quarter',
    monthPlaceholder: 'Select month',
    weekPlaceholder: 'Select week',
    rangePlaceholder: ['Start date', 'End date'],
    rangeYearPlaceholder: ['Start year', 'End year'],
    rangeQuarterPlaceholder: ['Start quarter', 'End quarter'],
    rangeMonthPlaceholder: ['Start month', 'End month'],
    rangeWeekPlaceholder: ['Start week', 'End week']
  }, locale$2),
  timePickerLocale: _extends({}, TimePicker)
};
// All settings at:
// https://github.com/ant-design/ant-design/blob/master/components/date-picker/locale/example.json
var enUS = locale;

/* eslint-disable no-template-curly-in-string */
var typeTemplate = '${label} is not a valid ${type}';
var localeValues = {
  locale: 'en',
  Pagination: enUS$1,
  DatePicker: enUS,
  TimePicker: TimePicker,
  Calendar: enUS,
  global: {
    placeholder: 'Please select'
  },
  Table: {
    filterTitle: 'Filter menu',
    filterConfirm: 'OK',
    filterReset: 'Reset',
    filterEmptyText: 'No filters',
    filterCheckall: 'Select all items',
    filterSearchPlaceholder: 'Search in filters',
    emptyText: 'No data',
    selectAll: 'Select current page',
    selectInvert: 'Invert current page',
    selectNone: 'Clear all data',
    selectionAll: 'Select all data',
    sortTitle: 'Sort',
    expand: 'Expand row',
    collapse: 'Collapse row',
    triggerDesc: 'Click to sort descending',
    triggerAsc: 'Click to sort ascending',
    cancelSort: 'Click to cancel sorting'
  },
  Modal: {
    okText: 'OK',
    cancelText: 'Cancel',
    justOkText: 'OK'
  },
  Popconfirm: {
    okText: 'OK',
    cancelText: 'Cancel'
  },
  Transfer: {
    titles: ['', ''],
    searchPlaceholder: 'Search here',
    itemUnit: 'item',
    itemsUnit: 'items',
    remove: 'Remove',
    selectCurrent: 'Select current page',
    removeCurrent: 'Remove current page',
    selectAll: 'Select all data',
    removeAll: 'Remove all data',
    selectInvert: 'Invert current page'
  },
  Upload: {
    uploading: 'Uploading...',
    removeFile: 'Remove file',
    uploadError: 'Upload error',
    previewFile: 'Preview file',
    downloadFile: 'Download file'
  },
  Empty: {
    description: 'No data'
  },
  Icon: {
    icon: 'icon'
  },
  Text: {
    edit: 'Edit',
    copy: 'Copy',
    copied: 'Copied',
    expand: 'Expand'
  },
  PageHeader: {
    back: 'Back'
  },
  Form: {
    optional: '(optional)',
    defaultValidateMessages: {
      "default": 'Field validation error for ${label}',
      required: 'Please enter ${label}',
      "enum": '${label} must be one of [${enum}]',
      whitespace: '${label} cannot be a blank character',
      date: {
        format: '${label} date format is invalid',
        parse: '${label} cannot be converted to a date',
        invalid: '${label} is an invalid date'
      },
      types: {
        string: typeTemplate,
        method: typeTemplate,
        array: typeTemplate,
        object: typeTemplate,
        number: typeTemplate,
        date: typeTemplate,
        "boolean": typeTemplate,
        integer: typeTemplate,
        "float": typeTemplate,
        regexp: typeTemplate,
        email: typeTemplate,
        url: typeTemplate,
        hex: typeTemplate
      },
      string: {
        len: '${label} must be ${len} characters',
        min: '${label} must be at least ${min} characters',
        max: '${label} must be up to ${max} characters',
        range: '${label} must be between ${min}-${max} characters'
      },
      number: {
        len: '${label} must be equal to ${len}',
        min: '${label} must be minimum ${min}',
        max: '${label} must be maximum ${max}',
        range: '${label} must be between ${min}-${max}'
      },
      array: {
        len: 'Must be ${len} ${label}',
        min: 'At least ${min} ${label}',
        max: 'At most ${max} ${label}',
        range: 'The amount of ${label} must be between ${min}-${max}'
      },
      pattern: {
        mismatch: '${label} does not match the pattern ${pattern}'
      }
    }
  },
  Image: {
    preview: 'Preview'
  }
};
var defaultLocale = localeValues;

var LocaleContext = /*#__PURE__*/React.createContext(undefined);
var LocaleContext$1 = LocaleContext;

var LocaleReceiver = function LocaleReceiver(props) {
  var _props$componentName = props.componentName,
    componentName = _props$componentName === void 0 ? 'global' : _props$componentName,
    defaultLocale$1 = props.defaultLocale,
    children = props.children;
  var antLocale = React__namespace.useContext(LocaleContext$1);
  var getLocale = React__namespace.useMemo(function () {
    var _a;
    var locale = defaultLocale$1 || defaultLocale[componentName];
    var localeFromContext = (_a = antLocale === null || antLocale === void 0 ? void 0 : antLocale[componentName]) !== null && _a !== void 0 ? _a : {};
    return _extends(_extends({}, locale instanceof Function ? locale() : locale), localeFromContext || {});
  }, [componentName, defaultLocale$1, antLocale]);
  var getLocaleCode = React__namespace.useMemo(function () {
    var localeCode = antLocale && antLocale.locale;
    // Had use LocaleProvide but didn't set locale
    if (antLocale && antLocale.exist && !localeCode) {
      return defaultLocale.locale;
    }
    return localeCode;
  }, [antLocale]);
  return children(getLocale, getLocaleCode, antLocale);
};
var LocaleReceiver$1 = LocaleReceiver;

// This icon file is generated automatically.
var CheckCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" } }] }, "name": "check-circle", "theme": "filled" };
var CheckCircleFilledSvg = CheckCircleFilled$2;

function _iterableToArrayLimit(arr, i) {
  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i) {
    var _s,
      _e,
      _x,
      _r,
      _arr = [],
      _n = !0,
      _d = !1;
    try {
      if (_x = (_i = _i.call(arr)).next, 0 === i) {
        if (Object(_i) !== _i) return;
        _n = !1;
      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return;
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}

/**
 * Take input from [0, n] and return it as [0, 1]
 * @hidden
 */
function bound01(n, max) {
    if (isOnePointZero(n)) {
        n = '100%';
    }
    var isPercent = isPercentage(n);
    n = max === 360 ? n : Math.min(max, Math.max(0, parseFloat(n)));
    // Automatically convert percentage into number
    if (isPercent) {
        n = parseInt(String(n * max), 10) / 100;
    }
    // Handle floating point rounding errors
    if (Math.abs(n - max) < 0.000001) {
        return 1;
    }
    // Convert into [0, 1] range if it isn't already
    if (max === 360) {
        // If n is a hue given in degrees,
        // wrap around out-of-range values into [0, 360] range
        // then convert into [0, 1].
        n = (n < 0 ? (n % max) + max : n % max) / parseFloat(String(max));
    }
    else {
        // If n not a hue given in degrees
        // Convert into [0, 1] range if it isn't already.
        n = (n % max) / parseFloat(String(max));
    }
    return n;
}
/**
 * Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
 * <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
 * @hidden
 */
function isOnePointZero(n) {
    return typeof n === 'string' && n.indexOf('.') !== -1 && parseFloat(n) === 1;
}
/**
 * Check to see if string passed in is a percentage
 * @hidden
 */
function isPercentage(n) {
    return typeof n === 'string' && n.indexOf('%') !== -1;
}
/**
 * Return a valid alpha value [0,1] with all invalid values being set to 1
 * @hidden
 */
function boundAlpha(a) {
    a = parseFloat(a);
    if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
    }
    return a;
}
/**
 * Replace a decimal with it's percentage value
 * @hidden
 */
function convertToPercentage(n) {
    if (n <= 1) {
        return "".concat(Number(n) * 100, "%");
    }
    return n;
}
/**
 * Force a hex value to have 2 characters
 * @hidden
 */
function pad2(c) {
    return c.length === 1 ? '0' + c : String(c);
}

// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>
/**
 * Handle bounds / percentage checking to conform to CSS color spec
 * <http://www.w3.org/TR/css3-color/>
 * *Assumes:* r, g, b in [0, 255] or [0, 1]
 * *Returns:* { r, g, b } in [0, 255]
 */
function rgbToRgb(r, g, b) {
    return {
        r: bound01(r, 255) * 255,
        g: bound01(g, 255) * 255,
        b: bound01(b, 255) * 255,
    };
}
function hue2rgb(p, q, t) {
    if (t < 0) {
        t += 1;
    }
    if (t > 1) {
        t -= 1;
    }
    if (t < 1 / 6) {
        return p + (q - p) * (6 * t);
    }
    if (t < 1 / 2) {
        return q;
    }
    if (t < 2 / 3) {
        return p + (q - p) * (2 / 3 - t) * 6;
    }
    return p;
}
/**
 * Converts an HSL color value to RGB.
 *
 * *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
 * *Returns:* { r, g, b } in the set [0, 255]
 */
function hslToRgb(h, s, l) {
    var r;
    var g;
    var b;
    h = bound01(h, 360);
    s = bound01(s, 100);
    l = bound01(l, 100);
    if (s === 0) {
        // achromatic
        g = l;
        b = l;
        r = l;
    }
    else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }
    return { r: r * 255, g: g * 255, b: b * 255 };
}
/**
 * Converts an RGB color value to HSV
 *
 * *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
 * *Returns:* { h, s, v } in [0,1]
 */
function rgbToHsv(r, g, b) {
    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var h = 0;
    var v = max;
    var d = max - min;
    var s = max === 0 ? 0 : d / max;
    if (max === min) {
        h = 0; // achromatic
    }
    else {
        switch (max) {
            case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
            case g:
                h = (b - r) / d + 2;
                break;
            case b:
                h = (r - g) / d + 4;
                break;
        }
        h /= 6;
    }
    return { h: h, s: s, v: v };
}
/**
 * Converts an HSV color value to RGB.
 *
 * *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
 * *Returns:* { r, g, b } in the set [0, 255]
 */
function hsvToRgb(h, s, v) {
    h = bound01(h, 360) * 6;
    s = bound01(s, 100);
    v = bound01(v, 100);
    var i = Math.floor(h);
    var f = h - i;
    var p = v * (1 - s);
    var q = v * (1 - f * s);
    var t = v * (1 - (1 - f) * s);
    var mod = i % 6;
    var r = [v, q, p, p, t, v][mod];
    var g = [t, v, v, q, p, p][mod];
    var b = [p, p, t, v, v, q][mod];
    return { r: r * 255, g: g * 255, b: b * 255 };
}
/**
 * Converts an RGB color to hex
 *
 * Assumes r, g, and b are contained in the set [0, 255]
 * Returns a 3 or 6 character hex
 */
function rgbToHex(r, g, b, allow3Char) {
    var hex = [
        pad2(Math.round(r).toString(16)),
        pad2(Math.round(g).toString(16)),
        pad2(Math.round(b).toString(16)),
    ];
    // Return a 3 character hex if possible
    if (allow3Char &&
        hex[0].startsWith(hex[0].charAt(1)) &&
        hex[1].startsWith(hex[1].charAt(1)) &&
        hex[2].startsWith(hex[2].charAt(1))) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    }
    return hex.join('');
}
/** Converts a hex value to a decimal */
function convertHexToDecimal(h) {
    return parseIntFromHex(h) / 255;
}
/** Parse a base-16 hex value into a base-10 integer */
function parseIntFromHex(val) {
    return parseInt(val, 16);
}

// https://github.com/bahamas10/css-color-names/blob/master/css-color-names.json
/**
 * @hidden
 */
var names = {
    aliceblue: '#f0f8ff',
    antiquewhite: '#faebd7',
    aqua: '#00ffff',
    aquamarine: '#7fffd4',
    azure: '#f0ffff',
    beige: '#f5f5dc',
    bisque: '#ffe4c4',
    black: '#000000',
    blanchedalmond: '#ffebcd',
    blue: '#0000ff',
    blueviolet: '#8a2be2',
    brown: '#a52a2a',
    burlywood: '#deb887',
    cadetblue: '#5f9ea0',
    chartreuse: '#7fff00',
    chocolate: '#d2691e',
    coral: '#ff7f50',
    cornflowerblue: '#6495ed',
    cornsilk: '#fff8dc',
    crimson: '#dc143c',
    cyan: '#00ffff',
    darkblue: '#00008b',
    darkcyan: '#008b8b',
    darkgoldenrod: '#b8860b',
    darkgray: '#a9a9a9',
    darkgreen: '#006400',
    darkgrey: '#a9a9a9',
    darkkhaki: '#bdb76b',
    darkmagenta: '#8b008b',
    darkolivegreen: '#556b2f',
    darkorange: '#ff8c00',
    darkorchid: '#9932cc',
    darkred: '#8b0000',
    darksalmon: '#e9967a',
    darkseagreen: '#8fbc8f',
    darkslateblue: '#483d8b',
    darkslategray: '#2f4f4f',
    darkslategrey: '#2f4f4f',
    darkturquoise: '#00ced1',
    darkviolet: '#9400d3',
    deeppink: '#ff1493',
    deepskyblue: '#00bfff',
    dimgray: '#696969',
    dimgrey: '#696969',
    dodgerblue: '#1e90ff',
    firebrick: '#b22222',
    floralwhite: '#fffaf0',
    forestgreen: '#228b22',
    fuchsia: '#ff00ff',
    gainsboro: '#dcdcdc',
    ghostwhite: '#f8f8ff',
    goldenrod: '#daa520',
    gold: '#ffd700',
    gray: '#808080',
    green: '#008000',
    greenyellow: '#adff2f',
    grey: '#808080',
    honeydew: '#f0fff0',
    hotpink: '#ff69b4',
    indianred: '#cd5c5c',
    indigo: '#4b0082',
    ivory: '#fffff0',
    khaki: '#f0e68c',
    lavenderblush: '#fff0f5',
    lavender: '#e6e6fa',
    lawngreen: '#7cfc00',
    lemonchiffon: '#fffacd',
    lightblue: '#add8e6',
    lightcoral: '#f08080',
    lightcyan: '#e0ffff',
    lightgoldenrodyellow: '#fafad2',
    lightgray: '#d3d3d3',
    lightgreen: '#90ee90',
    lightgrey: '#d3d3d3',
    lightpink: '#ffb6c1',
    lightsalmon: '#ffa07a',
    lightseagreen: '#20b2aa',
    lightskyblue: '#87cefa',
    lightslategray: '#778899',
    lightslategrey: '#778899',
    lightsteelblue: '#b0c4de',
    lightyellow: '#ffffe0',
    lime: '#00ff00',
    limegreen: '#32cd32',
    linen: '#faf0e6',
    magenta: '#ff00ff',
    maroon: '#800000',
    mediumaquamarine: '#66cdaa',
    mediumblue: '#0000cd',
    mediumorchid: '#ba55d3',
    mediumpurple: '#9370db',
    mediumseagreen: '#3cb371',
    mediumslateblue: '#7b68ee',
    mediumspringgreen: '#00fa9a',
    mediumturquoise: '#48d1cc',
    mediumvioletred: '#c71585',
    midnightblue: '#191970',
    mintcream: '#f5fffa',
    mistyrose: '#ffe4e1',
    moccasin: '#ffe4b5',
    navajowhite: '#ffdead',
    navy: '#000080',
    oldlace: '#fdf5e6',
    olive: '#808000',
    olivedrab: '#6b8e23',
    orange: '#ffa500',
    orangered: '#ff4500',
    orchid: '#da70d6',
    palegoldenrod: '#eee8aa',
    palegreen: '#98fb98',
    paleturquoise: '#afeeee',
    palevioletred: '#db7093',
    papayawhip: '#ffefd5',
    peachpuff: '#ffdab9',
    peru: '#cd853f',
    pink: '#ffc0cb',
    plum: '#dda0dd',
    powderblue: '#b0e0e6',
    purple: '#800080',
    rebeccapurple: '#663399',
    red: '#ff0000',
    rosybrown: '#bc8f8f',
    royalblue: '#4169e1',
    saddlebrown: '#8b4513',
    salmon: '#fa8072',
    sandybrown: '#f4a460',
    seagreen: '#2e8b57',
    seashell: '#fff5ee',
    sienna: '#a0522d',
    silver: '#c0c0c0',
    skyblue: '#87ceeb',
    slateblue: '#6a5acd',
    slategray: '#708090',
    slategrey: '#708090',
    snow: '#fffafa',
    springgreen: '#00ff7f',
    steelblue: '#4682b4',
    tan: '#d2b48c',
    teal: '#008080',
    thistle: '#d8bfd8',
    tomato: '#ff6347',
    turquoise: '#40e0d0',
    violet: '#ee82ee',
    wheat: '#f5deb3',
    white: '#ffffff',
    whitesmoke: '#f5f5f5',
    yellow: '#ffff00',
    yellowgreen: '#9acd32',
};

/* eslint-disable @typescript-eslint/no-redundant-type-constituents */
/**
 * Given a string or object, convert that input to RGB
 *
 * Possible string inputs:
 * ```
 * "red"
 * "#f00" or "f00"
 * "#ff0000" or "ff0000"
 * "#ff000000" or "ff000000"
 * "rgb 255 0 0" or "rgb (255, 0, 0)"
 * "rgb 1.0 0 0" or "rgb (1, 0, 0)"
 * "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
 * "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
 * "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
 * "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
 * "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
 * ```
 */
function inputToRGB(color) {
    var rgb = { r: 0, g: 0, b: 0 };
    var a = 1;
    var s = null;
    var v = null;
    var l = null;
    var ok = false;
    var format = false;
    if (typeof color === 'string') {
        color = stringInputToObject(color);
    }
    if (typeof color === 'object') {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format = String(color.r).substr(-1) === '%' ? 'prgb' : 'rgb';
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s = convertToPercentage(color.s);
            v = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s, v);
            ok = true;
            format = 'hsv';
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s = convertToPercentage(color.s);
            l = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s, l);
            ok = true;
            format = 'hsl';
        }
        if (Object.prototype.hasOwnProperty.call(color, 'a')) {
            a = color.a;
        }
    }
    a = boundAlpha(a);
    return {
        ok: ok,
        format: color.format || format,
        r: Math.min(255, Math.max(rgb.r, 0)),
        g: Math.min(255, Math.max(rgb.g, 0)),
        b: Math.min(255, Math.max(rgb.b, 0)),
        a: a,
    };
}
// <http://www.w3.org/TR/css3-values/#integers>
var CSS_INTEGER = '[-\\+]?\\d+%?';
// <http://www.w3.org/TR/css3-values/#number-value>
var CSS_NUMBER = '[-\\+]?\\d*\\.\\d+%?';
// Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
// Actual matching.
// Parentheses and commas are optional, but not required.
// Whitespace can take the place of commas or opening paren
var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var matchers = {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp('rgb' + PERMISSIVE_MATCH3),
    rgba: new RegExp('rgba' + PERMISSIVE_MATCH4),
    hsl: new RegExp('hsl' + PERMISSIVE_MATCH3),
    hsla: new RegExp('hsla' + PERMISSIVE_MATCH4),
    hsv: new RegExp('hsv' + PERMISSIVE_MATCH3),
    hsva: new RegExp('hsva' + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
};
/**
 * Permissive string parsing.  Take in a number of formats, and output an object
 * based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
 */
function stringInputToObject(color) {
    color = color.trim().toLowerCase();
    if (color.length === 0) {
        return false;
    }
    var named = false;
    if (names[color]) {
        color = names[color];
        named = true;
    }
    else if (color === 'transparent') {
        return { r: 0, g: 0, b: 0, a: 0, format: 'name' };
    }
    // Try to match string input using regular expressions.
    // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
    // Just return an object and let the conversion functions handle that.
    // This way the result will be the same whether the tinycolor is initialized with string or object.
    var match = matchers.rgb.exec(color);
    if (match) {
        return { r: match[1], g: match[2], b: match[3] };
    }
    match = matchers.rgba.exec(color);
    if (match) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
    }
    match = matchers.hsl.exec(color);
    if (match) {
        return { h: match[1], s: match[2], l: match[3] };
    }
    match = matchers.hsla.exec(color);
    if (match) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
    }
    match = matchers.hsv.exec(color);
    if (match) {
        return { h: match[1], s: match[2], v: match[3] };
    }
    match = matchers.hsva.exec(color);
    if (match) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
    }
    match = matchers.hex8.exec(color);
    if (match) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? 'name' : 'hex8',
        };
    }
    match = matchers.hex6.exec(color);
    if (match) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? 'name' : 'hex',
        };
    }
    match = matchers.hex4.exec(color);
    if (match) {
        return {
            r: parseIntFromHex(match[1] + match[1]),
            g: parseIntFromHex(match[2] + match[2]),
            b: parseIntFromHex(match[3] + match[3]),
            a: convertHexToDecimal(match[4] + match[4]),
            format: named ? 'name' : 'hex8',
        };
    }
    match = matchers.hex3.exec(color);
    if (match) {
        return {
            r: parseIntFromHex(match[1] + match[1]),
            g: parseIntFromHex(match[2] + match[2]),
            b: parseIntFromHex(match[3] + match[3]),
            format: named ? 'name' : 'hex',
        };
    }
    return false;
}
/**
 * Check to see if it looks like a CSS unit
 * (see `matchers` above for definition).
 */
function isValidCSSUnit(color) {
    return Boolean(matchers.CSS_UNIT.exec(String(color)));
}

var hueStep = 2; // 色相阶梯

var saturationStep = 0.16; // 饱和度阶梯，浅色部分

var saturationStep2 = 0.05; // 饱和度阶梯，深色部分

var brightnessStep1 = 0.05; // 亮度阶梯，浅色部分

var brightnessStep2 = 0.15; // 亮度阶梯，深色部分

var lightColorCount = 5; // 浅色数量，主色上

var darkColorCount = 4; // 深色数量，主色下
// 暗色主题颜色映射关系表

var darkColorMap = [{
  index: 7,
  opacity: 0.15
}, {
  index: 6,
  opacity: 0.25
}, {
  index: 5,
  opacity: 0.3
}, {
  index: 5,
  opacity: 0.45
}, {
  index: 5,
  opacity: 0.65
}, {
  index: 5,
  opacity: 0.85
}, {
  index: 4,
  opacity: 0.9
}, {
  index: 3,
  opacity: 0.95
}, {
  index: 2,
  opacity: 0.97
}, {
  index: 1,
  opacity: 0.98
}]; // Wrapper function ported from TinyColor.prototype.toHsv
// Keep it here because of `hsv.h * 360`

function toHsv(_ref) {
  var r = _ref.r,
      g = _ref.g,
      b = _ref.b;
  var hsv = rgbToHsv(r, g, b);
  return {
    h: hsv.h * 360,
    s: hsv.s,
    v: hsv.v
  };
} // Wrapper function ported from TinyColor.prototype.toHexString
// Keep it here because of the prefix `#`


function toHex(_ref2) {
  var r = _ref2.r,
      g = _ref2.g,
      b = _ref2.b;
  return "#".concat(rgbToHex(r, g, b, false));
} // Wrapper function ported from TinyColor.prototype.mix, not treeshakable.
// Amount in range [0, 1]
// Assume color1 & color2 has no alpha, since the following src code did so.


function mix$1(rgb1, rgb2, amount) {
  var p = amount / 100;
  var rgb = {
    r: (rgb2.r - rgb1.r) * p + rgb1.r,
    g: (rgb2.g - rgb1.g) * p + rgb1.g,
    b: (rgb2.b - rgb1.b) * p + rgb1.b
  };
  return rgb;
}

function getHue(hsv, i, light) {
  var hue; // 根据色相不同，色相转向不同

  if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
    hue = light ? Math.round(hsv.h) - hueStep * i : Math.round(hsv.h) + hueStep * i;
  } else {
    hue = light ? Math.round(hsv.h) + hueStep * i : Math.round(hsv.h) - hueStep * i;
  }

  if (hue < 0) {
    hue += 360;
  } else if (hue >= 360) {
    hue -= 360;
  }

  return hue;
}

function getSaturation(hsv, i, light) {
  // grey color don't change saturation
  if (hsv.h === 0 && hsv.s === 0) {
    return hsv.s;
  }

  var saturation;

  if (light) {
    saturation = hsv.s - saturationStep * i;
  } else if (i === darkColorCount) {
    saturation = hsv.s + saturationStep;
  } else {
    saturation = hsv.s + saturationStep2 * i;
  } // 边界值修正


  if (saturation > 1) {
    saturation = 1;
  } // 第一格的 s 限制在 0.06-0.1 之间


  if (light && i === lightColorCount && saturation > 0.1) {
    saturation = 0.1;
  }

  if (saturation < 0.06) {
    saturation = 0.06;
  }

  return Number(saturation.toFixed(2));
}

function getValue(hsv, i, light) {
  var value;

  if (light) {
    value = hsv.v + brightnessStep1 * i;
  } else {
    value = hsv.v - brightnessStep2 * i;
  }

  if (value > 1) {
    value = 1;
  }

  return Number(value.toFixed(2));
}

function generate$1(color) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var patterns = [];
  var pColor = inputToRGB(color);

  for (var i = lightColorCount; i > 0; i -= 1) {
    var hsv = toHsv(pColor);
    var colorString = toHex(inputToRGB({
      h: getHue(hsv, i, true),
      s: getSaturation(hsv, i, true),
      v: getValue(hsv, i, true)
    }));
    patterns.push(colorString);
  }

  patterns.push(toHex(pColor));

  for (var _i = 1; _i <= darkColorCount; _i += 1) {
    var _hsv = toHsv(pColor);

    var _colorString = toHex(inputToRGB({
      h: getHue(_hsv, _i),
      s: getSaturation(_hsv, _i),
      v: getValue(_hsv, _i)
    }));

    patterns.push(_colorString);
  } // dark theme patterns


  if (opts.theme === 'dark') {
    return darkColorMap.map(function (_ref3) {
      var index = _ref3.index,
          opacity = _ref3.opacity;
      var darkColorString = toHex(mix$1(inputToRGB(opts.backgroundColor || '#141414'), inputToRGB(patterns[index]), opacity * 100));
      return darkColorString;
    });
  }

  return patterns;
}

var presetPrimaryColors = {
  red: '#F5222D',
  volcano: '#FA541C',
  orange: '#FA8C16',
  gold: '#FAAD14',
  yellow: '#FADB14',
  lime: '#A0D911',
  green: '#52C41A',
  cyan: '#13C2C2',
  blue: '#1890FF',
  geekblue: '#2F54EB',
  purple: '#722ED1',
  magenta: '#EB2F96',
  grey: '#666666'
};
var presetPalettes = {};
var presetDarkPalettes = {};
Object.keys(presetPrimaryColors).forEach(function (key) {
  presetPalettes[key] = generate$1(presetPrimaryColors[key]);
  presetPalettes[key].primary = presetPalettes[key][5]; // dark presetPalettes

  presetDarkPalettes[key] = generate$1(presetPrimaryColors[key], {
    theme: 'dark',
    backgroundColor: '#141414'
  });
  presetDarkPalettes[key].primary = presetDarkPalettes[key][5];
});

function canUseDom() {
  return !!(typeof window !== 'undefined' && window.document && window.document.createElement);
}

function contains(root, n) {
  if (!root) {
    return false;
  }

  // Use native if support
  if (root.contains) {
    return root.contains(n);
  }

  // `document.contains` not support with IE11
  var node = n;
  while (node) {
    if (node === root) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
}

var APPEND_ORDER = 'data-rc-order';
var APPEND_PRIORITY = 'data-rc-priority';
var MARK_KEY = "rc-util-key";
var containerCache = new Map();
function getMark() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    mark = _ref.mark;
  if (mark) {
    return mark.startsWith('data-') ? mark : "data-".concat(mark);
  }
  return MARK_KEY;
}
function getContainer(option) {
  if (option.attachTo) {
    return option.attachTo;
  }
  var head = document.querySelector('head');
  return head || document.body;
}
function getOrder(prepend) {
  if (prepend === 'queue') {
    return 'prependQueue';
  }
  return prepend ? 'prepend' : 'append';
}

/**
 * Find style which inject by rc-util
 */
function findStyles(container) {
  return Array.from((containerCache.get(container) || container).children).filter(function (node) {
    return node.tagName === 'STYLE';
  });
}
function injectCSS(css) {
  var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (!canUseDom()) {
    return null;
  }
  var csp = option.csp,
    prepend = option.prepend,
    _option$priority = option.priority,
    priority = _option$priority === void 0 ? 0 : _option$priority;
  var mergedOrder = getOrder(prepend);
  var isPrependQueue = mergedOrder === 'prependQueue';
  var styleNode = document.createElement('style');
  styleNode.setAttribute(APPEND_ORDER, mergedOrder);
  if (isPrependQueue && priority) {
    styleNode.setAttribute(APPEND_PRIORITY, "".concat(priority));
  }
  if (csp !== null && csp !== void 0 && csp.nonce) {
    styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
  }
  styleNode.innerHTML = css;
  var container = getContainer(option);
  var firstChild = container.firstChild;
  if (prepend) {
    // If is queue `prepend`, it will prepend first style and then append rest style
    if (isPrependQueue) {
      var existStyle = findStyles(container).filter(function (node) {
        // Ignore style which not injected by rc-util with prepend
        if (!['prepend', 'prependQueue'].includes(node.getAttribute(APPEND_ORDER))) {
          return false;
        }

        // Ignore style which priority less then new style
        var nodePriority = Number(node.getAttribute(APPEND_PRIORITY) || 0);
        return priority >= nodePriority;
      });
      if (existStyle.length) {
        container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
        return styleNode;
      }
    }

    // Use `insertBefore` as `prepend`
    container.insertBefore(styleNode, firstChild);
  } else {
    container.appendChild(styleNode);
  }
  return styleNode;
}
function findExistNode(key) {
  var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var container = getContainer(option);
  return findStyles(container).find(function (node) {
    return node.getAttribute(getMark(option)) === key;
  });
}

/**
 * qiankun will inject `appendChild` to insert into other
 */
function syncRealContainer(container, option) {
  var cachedRealContainer = containerCache.get(container);

  // Find real container when not cached or cached container removed
  if (!cachedRealContainer || !contains(document, cachedRealContainer)) {
    var placeholderStyle = injectCSS('', option);
    var parentNode = placeholderStyle.parentNode;
    containerCache.set(container, parentNode);
    container.removeChild(placeholderStyle);
  }
}
function updateCSS(css, key) {
  var option = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var container = getContainer(option);

  // Sync real parent
  syncRealContainer(container, option);
  var existNode = findExistNode(key, option);
  if (existNode) {
    var _option$csp, _option$csp2;
    if ((_option$csp = option.csp) !== null && _option$csp !== void 0 && _option$csp.nonce && existNode.nonce !== ((_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce)) {
      var _option$csp3;
      existNode.nonce = (_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce;
    }
    if (existNode.innerHTML !== css) {
      existNode.innerHTML = css;
    }
    return existNode;
  }
  var newNode = injectCSS(css, option);
  newNode.setAttribute(getMark(option), key);
  return newNode;
}

/** Detect free variable `global` from Node.js. */

var freeGlobal$1 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

var _freeGlobal = freeGlobal$1;

var freeGlobal = _freeGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root$1 = freeGlobal || freeSelf || Function('return this')();

var _root = root$1;

var root = _root;

/** Built-in value references. */
var Symbol$4 = root.Symbol;

var _Symbol = Symbol$4;

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */

function arrayMap$1(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

var _arrayMap = arrayMap$1;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */

var isArray$1 = Array.isArray;

var isArray_1 = isArray$1;

var Symbol$3 = _Symbol;

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto$1.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$1.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag$1(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

var _getRawTag = getRawTag$1;

/** Used for built-in method references. */

var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}

var _objectToString = objectToString$1;

var Symbol$2 = _Symbol,
    getRawTag = _getRawTag,
    objectToString = _objectToString;

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag$1(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

var _baseGetTag = baseGetTag$1;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */

function isObjectLike$1(value) {
  return value != null && typeof value == 'object';
}

var isObjectLike_1 = isObjectLike$1;

var baseGetTag = _baseGetTag,
    isObjectLike = isObjectLike_1;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol$1(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

var isSymbol_1 = isSymbol$1;

var Symbol$1 = _Symbol,
    arrayMap = _arrayMap,
    isArray = isArray_1,
    isSymbol = isSymbol_1;

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString$1(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString$1) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

var _baseToString = baseToString$1;

var baseToString = _baseToString;

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString$4(value) {
  return value == null ? '' : baseToString(value);
}

var toString_1 = toString$4;

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */

function baseSlice$1(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

var _baseSlice = baseSlice$1;

var baseSlice = _baseSlice;

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice$1(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
}

var _castSlice = castSlice$1;

/** Used to compose unicode character classes. */

var rsAstralRange$2 = '\\ud800-\\udfff',
    rsComboMarksRange$3 = '\\u0300-\\u036f',
    reComboHalfMarksRange$3 = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange$3 = '\\u20d0-\\u20ff',
    rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3,
    rsVarRange$2 = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ$2 = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ$2 + rsAstralRange$2  + rsComboRange$3 + rsVarRange$2 + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode$2(string) {
  return reHasUnicode.test(string);
}

var _hasUnicode = hasUnicode$2;

/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */

function asciiToArray$1(string) {
  return string.split('');
}

var _asciiToArray = asciiToArray$1;

/** Used to compose unicode character classes. */

var rsAstralRange$1 = '\\ud800-\\udfff',
    rsComboMarksRange$2 = '\\u0300-\\u036f',
    reComboHalfMarksRange$2 = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange$2 = '\\u20d0-\\u20ff',
    rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2,
    rsVarRange$1 = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange$1 + ']',
    rsCombo$2 = '[' + rsComboRange$2 + ']',
    rsFitz$1 = '\\ud83c[\\udffb-\\udfff]',
    rsModifier$1 = '(?:' + rsCombo$2 + '|' + rsFitz$1 + ')',
    rsNonAstral$1 = '[^' + rsAstralRange$1 + ']',
    rsRegional$1 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair$1 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ$1 = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod$1 = rsModifier$1 + '?',
    rsOptVar$1 = '[' + rsVarRange$1 + ']?',
    rsOptJoin$1 = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsOptVar$1 + reOptMod$1 + ')*',
    rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1,
    rsSymbol = '(?:' + [rsNonAstral$1 + rsCombo$2 + '?', rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz$1 + '(?=' + rsFitz$1 + ')|' + rsSymbol + rsSeq$1, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray$1(string) {
  return string.match(reUnicode) || [];
}

var _unicodeToArray = unicodeToArray$1;

var asciiToArray = _asciiToArray,
    hasUnicode$1 = _hasUnicode,
    unicodeToArray = _unicodeToArray;

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray$1(string) {
  return hasUnicode$1(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

var _stringToArray = stringToArray$1;

var castSlice = _castSlice,
    hasUnicode = _hasUnicode,
    stringToArray = _stringToArray,
    toString$3 = toString_1;

/**
 * Creates a function like `_.lowerFirst`.
 *
 * @private
 * @param {string} methodName The name of the `String` case method to use.
 * @returns {Function} Returns the new case function.
 */
function createCaseFirst$1(methodName) {
  return function(string) {
    string = toString$3(string);

    var strSymbols = hasUnicode(string)
      ? stringToArray(string)
      : undefined;

    var chr = strSymbols
      ? strSymbols[0]
      : string.charAt(0);

    var trailing = strSymbols
      ? castSlice(strSymbols, 1).join('')
      : string.slice(1);

    return chr[methodName]() + trailing;
  };
}

var _createCaseFirst = createCaseFirst$1;

var createCaseFirst = _createCaseFirst;

/**
 * Converts the first character of `string` to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.upperFirst('fred');
 * // => 'Fred'
 *
 * _.upperFirst('FRED');
 * // => 'FRED'
 */
var upperFirst$1 = createCaseFirst('toUpperCase');

var upperFirst_1 = upperFirst$1;

var toString$2 = toString_1,
    upperFirst = upperFirst_1;

/**
 * Converts the first character of `string` to upper case and the remaining
 * to lower case.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to capitalize.
 * @returns {string} Returns the capitalized string.
 * @example
 *
 * _.capitalize('FRED');
 * // => 'Fred'
 */
function capitalize$1(string) {
  return upperFirst(toString$2(string).toLowerCase());
}

var capitalize_1 = capitalize$1;

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */

function arrayReduce$1(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

var _arrayReduce = arrayReduce$1;

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */

function basePropertyOf$1(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

var _basePropertyOf = basePropertyOf$1;

var basePropertyOf = _basePropertyOf;

/** Used to map Latin Unicode letters to basic Latin letters. */
var deburredLetters = {
  // Latin-1 Supplement block.
  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
  '\xc7': 'C',  '\xe7': 'c',
  '\xd0': 'D',  '\xf0': 'd',
  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
  '\xd1': 'N',  '\xf1': 'n',
  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
  '\xc6': 'Ae', '\xe6': 'ae',
  '\xde': 'Th', '\xfe': 'th',
  '\xdf': 'ss',
  // Latin Extended-A block.
  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
  '\u0134': 'J',  '\u0135': 'j',
  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
  '\u0174': 'W',  '\u0175': 'w',
  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
  '\u0132': 'IJ', '\u0133': 'ij',
  '\u0152': 'Oe', '\u0153': 'oe',
  '\u0149': "'n", '\u017f': 's'
};

/**
 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
 * letters to basic Latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */
var deburrLetter$1 = basePropertyOf(deburredLetters);

var _deburrLetter = deburrLetter$1;

var deburrLetter = _deburrLetter,
    toString$1 = toString_1;

/** Used to match Latin Unicode letters (excluding mathematical operators). */
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

/** Used to compose unicode character classes. */
var rsComboMarksRange$1 = '\\u0300-\\u036f',
    reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange$1 = '\\u20d0-\\u20ff',
    rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;

/** Used to compose unicode capture groups. */
var rsCombo$1 = '[' + rsComboRange$1 + ']';

/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */
var reComboMark = RegExp(rsCombo$1, 'g');

/**
 * Deburrs `string` by converting
 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
 * letters to basic Latin letters and removing
 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('déjà vu');
 * // => 'deja vu'
 */
function deburr$1(string) {
  string = toString$1(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
}

var deburr_1 = deburr$1;

/** Used to match words composed of alphanumeric characters. */

var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

/**
 * Splits an ASCII `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function asciiWords$1(string) {
  return string.match(reAsciiWord) || [];
}

var _asciiWords = asciiWords$1;

/** Used to detect strings that need a more robust regexp to match words. */

var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

/**
 * Checks if `string` contains a word composed of Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a word is found, else `false`.
 */
function hasUnicodeWord$1(string) {
  return reHasUnicodeWord.test(string);
}

var _hasUnicodeWord = hasUnicodeWord$1;

/** Used to compose unicode character classes. */

var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsPunctuationRange = '\\u2000-\\u206f',
    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = '\\ufe0e\\ufe0f',
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

/** Used to compose unicode capture groups. */
var rsApos$1 = "['\u2019]",
    rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
    rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
    rsOptContrLower = '(?:' + rsApos$1 + '(?:d|ll|m|re|s|t|ve))?',
    rsOptContrUpper = '(?:' + rsApos$1 + '(?:D|LL|M|RE|S|T|VE))?',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
    rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

/** Used to match complex or compound words. */
var reUnicodeWord = RegExp([
  rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
  rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
  rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
  rsUpper + '+' + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join('|'), 'g');

/**
 * Splits a Unicode `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function unicodeWords$1(string) {
  return string.match(reUnicodeWord) || [];
}

var _unicodeWords = unicodeWords$1;

var asciiWords = _asciiWords,
    hasUnicodeWord = _hasUnicodeWord,
    toString = toString_1,
    unicodeWords = _unicodeWords;

/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words$1(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}

var words_1 = words$1;

var arrayReduce = _arrayReduce,
    deburr = deburr_1,
    words = words_1;

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]";

/** Used to match apostrophes. */
var reApos = RegExp(rsApos, 'g');

/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */
function createCompounder$1(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
  };
}

var _createCompounder = createCompounder$1;

var capitalize = capitalize_1,
    createCompounder = _createCompounder;

/**
 * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the camel cased string.
 * @example
 *
 * _.camelCase('Foo Bar');
 * // => 'fooBar'
 *
 * _.camelCase('--foo-bar--');
 * // => 'fooBar'
 *
 * _.camelCase('__FOO_BAR__');
 * // => 'fooBar'
 */
var camelCase = createCompounder(function(result, word, index) {
  word = word.toLowerCase();
  return result + (index ? capitalize(word) : word);
});

var camelCase_1 = camelCase;

var camelCase$1 = /*@__PURE__*/getDefaultExportFromCjs(camelCase_1);

function warning(valid, message) {
  warningOnce(valid, "[@ant-design/icons] ".concat(message));
}
function isIconDefinition(target) {
  return _typeof$1(target) === 'object' && typeof target.name === 'string' && typeof target.theme === 'string' && (_typeof$1(target.icon) === 'object' || typeof target.icon === 'function');
}
function normalizeAttrs() {
  var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return Object.keys(attrs).reduce(function (acc, key) {
    var val = attrs[key];
    switch (key) {
      case 'class':
        acc.className = val;
        delete acc.class;
        break;
      default:
        delete acc[key];
        acc[camelCase$1(key)] = val;
    }
    return acc;
  }, {});
}
function generate(node, key, rootProps) {
  if (!rootProps) {
    return /*#__PURE__*/React.createElement(node.tag, _objectSpread2$1({
      key: key
    }, normalizeAttrs(node.attrs)), (node.children || []).map(function (child, index) {
      return generate(child, "".concat(key, "-").concat(node.tag, "-").concat(index));
    }));
  }
  return /*#__PURE__*/React.createElement(node.tag, _objectSpread2$1(_objectSpread2$1({
    key: key
  }, normalizeAttrs(node.attrs)), rootProps), (node.children || []).map(function (child, index) {
    return generate(child, "".concat(key, "-").concat(node.tag, "-").concat(index));
  }));
}
function getSecondaryColor(primaryColor) {
  // choose the second color
  return generate$1(primaryColor)[0];
}
function normalizeTwoToneColors(twoToneColor) {
  if (!twoToneColor) {
    return [];
  }
  return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
}
var iconStyles = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
var useInsertStyles = function useInsertStyles() {
  var styleStr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iconStyles;
  var _useContext = React.useContext(IconContext$2),
    csp = _useContext.csp;
  React.useEffect(function () {
    updateCSS(styleStr, '@ant-design-icons', {
      prepend: true,
      csp: csp
    });
  }, []);
};

var _excluded$5 = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"];
var twoToneColorPalette = {
  primaryColor: '#333',
  secondaryColor: '#E6E6E6',
  calculated: false
};
function setTwoToneColors(_ref) {
  var primaryColor = _ref.primaryColor,
    secondaryColor = _ref.secondaryColor;
  twoToneColorPalette.primaryColor = primaryColor;
  twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
  twoToneColorPalette.calculated = !!secondaryColor;
}
function getTwoToneColors() {
  return _objectSpread2$1({}, twoToneColorPalette);
}
var IconBase$1 = function IconBase(props) {
  var icon = props.icon,
    className = props.className,
    onClick = props.onClick,
    style = props.style,
    primaryColor = props.primaryColor,
    secondaryColor = props.secondaryColor,
    restProps = _objectWithoutProperties(props, _excluded$5);
  var colors = twoToneColorPalette;
  if (primaryColor) {
    colors = {
      primaryColor: primaryColor,
      secondaryColor: secondaryColor || getSecondaryColor(primaryColor)
    };
  }
  useInsertStyles();
  warning(isIconDefinition(icon), "icon should be icon definiton, but got ".concat(icon));
  if (!isIconDefinition(icon)) {
    return null;
  }
  var target = icon;
  if (target && typeof target.icon === 'function') {
    target = _objectSpread2$1(_objectSpread2$1({}, target), {}, {
      icon: target.icon(colors.primaryColor, colors.secondaryColor)
    });
  }
  return generate(target.icon, "svg-".concat(target.name), _objectSpread2$1({
    className: className,
    onClick: onClick,
    style: style,
    'data-icon': target.name,
    width: '1em',
    height: '1em',
    fill: 'currentColor',
    'aria-hidden': 'true'
  }, restProps));
};
IconBase$1.displayName = 'IconReact';
IconBase$1.getTwoToneColors = getTwoToneColors;
IconBase$1.setTwoToneColors = setTwoToneColors;
var ReactIcon = IconBase$1;

function setTwoToneColor(twoToneColor) {
  var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor),
    _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2),
    primaryColor = _normalizeTwoToneColo2[0],
    secondaryColor = _normalizeTwoToneColo2[1];
  return ReactIcon.setTwoToneColors({
    primaryColor: primaryColor,
    secondaryColor: secondaryColor
  });
}
function getTwoToneColor() {
  var colors = ReactIcon.getTwoToneColors();
  if (!colors.calculated) {
    return colors.primaryColor;
  }
  return [colors.primaryColor, colors.secondaryColor];
}

var _excluded$4 = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
// Initial setting
// should move it to antd main repo?
setTwoToneColor('#1890ff');
var Icon = /*#__PURE__*/React__namespace.forwardRef(function (props, ref) {
  var _classNames;
  var className = props.className,
    icon = props.icon,
    spin = props.spin,
    rotate = props.rotate,
    tabIndex = props.tabIndex,
    onClick = props.onClick,
    twoToneColor = props.twoToneColor,
    restProps = _objectWithoutProperties(props, _excluded$4);
  var _React$useContext = React__namespace.useContext(IconContext$2),
    _React$useContext$pre = _React$useContext.prefixCls,
    prefixCls = _React$useContext$pre === void 0 ? 'anticon' : _React$useContext$pre,
    rootClassName = _React$useContext.rootClassName;
  var classString = classNames(rootClassName, prefixCls, (_classNames = {}, _defineProperty$1(_classNames, "".concat(prefixCls, "-").concat(icon.name), !!icon.name), _defineProperty$1(_classNames, "".concat(prefixCls, "-spin"), !!spin || icon.name === 'loading'), _classNames), className);
  var iconTabIndex = tabIndex;
  if (iconTabIndex === undefined && onClick) {
    iconTabIndex = -1;
  }
  var svgStyle = rotate ? {
    msTransform: "rotate(".concat(rotate, "deg)"),
    transform: "rotate(".concat(rotate, "deg)")
  } : undefined;
  var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor),
    _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2),
    primaryColor = _normalizeTwoToneColo2[0],
    secondaryColor = _normalizeTwoToneColo2[1];
  return /*#__PURE__*/React__namespace.createElement("span", _objectSpread2$1(_objectSpread2$1({
    role: "img",
    "aria-label": icon.name
  }, restProps), {}, {
    ref: ref,
    tabIndex: iconTabIndex,
    onClick: onClick,
    className: classString
  }), /*#__PURE__*/React__namespace.createElement(ReactIcon, {
    icon: icon,
    primaryColor: primaryColor,
    secondaryColor: secondaryColor,
    style: svgStyle
  }));
});
Icon.displayName = 'AntdIcon';
Icon.getTwoToneColor = getTwoToneColor;
Icon.setTwoToneColor = setTwoToneColor;
var AntdIcon = Icon;

var CheckCircleFilled = function CheckCircleFilled(props, ref) {
  return /*#__PURE__*/React__namespace.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref: ref,
    icon: CheckCircleFilledSvg
  }));
};
CheckCircleFilled.displayName = 'CheckCircleFilled';
var CheckCircleFilled$1 = /*#__PURE__*/React__namespace.forwardRef(CheckCircleFilled);

// This icon file is generated automatically.
var CloseCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "fill-rule": "evenodd", "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z" } }] }, "name": "close-circle", "theme": "filled" };
var CloseCircleFilledSvg = CloseCircleFilled$2;

var CloseCircleFilled = function CloseCircleFilled(props, ref) {
  return /*#__PURE__*/React__namespace.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref: ref,
    icon: CloseCircleFilledSvg
  }));
};
CloseCircleFilled.displayName = 'CloseCircleFilled';
var CloseCircleFilled$1 = /*#__PURE__*/React__namespace.forwardRef(CloseCircleFilled);

// This icon file is generated automatically.
var LoadingOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, "name": "loading", "theme": "outlined" };
var LoadingOutlinedSvg = LoadingOutlined$2;

var LoadingOutlined = function LoadingOutlined(props, ref) {
  return /*#__PURE__*/React__namespace.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref: ref,
    icon: LoadingOutlinedSvg
  }));
};
LoadingOutlined.displayName = 'LoadingOutlined';
var LoadingOutlined$1 = /*#__PURE__*/React__namespace.forwardRef(LoadingOutlined);

function _regeneratorRuntime() {
  _regeneratorRuntime = function _regeneratorRuntime() {
    return exports;
  };
  var exports = {},
    Op = Object.prototype,
    hasOwn = Op.hasOwnProperty,
    defineProperty = Object.defineProperty || function (obj, key, desc) {
      obj[key] = desc.value;
    },
    $Symbol = "function" == typeof Symbol ? Symbol : {},
    iteratorSymbol = $Symbol.iterator || "@@iterator",
    asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
    toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function define(obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
      generator = Object.create(protoGenerator.prototype),
      context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
    NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg,
          value = result.value;
        return value && "object" == _typeof$1(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function value(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self, context) {
    var state = "suspendedStart";
    return function (method, arg) {
      if ("executing" === state) throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method) throw arg;
        return {
          value: void 0,
          done: !0
        };
      }
      for (context.method = method, context.arg = arg;;) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }
        if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
          if ("suspendedStart" === state) throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method,
      method = delegate.iterator[methodName];
    if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(iterable) {
    if (iterable || "" === iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1,
          next = function next() {
            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
            return next.value = undefined, next.done = !0, next;
          };
        return next.next = next;
      }
    }
    throw new TypeError(_typeof$1(iterable) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (val) {
    var object = Object(val),
      keys = [];
    for (var key in object) keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function stop() {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done) throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
          record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
            hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}

var Context = /*#__PURE__*/React__namespace.createContext({});

var DomWrapper = /*#__PURE__*/function (_React$Component) {
  _inherits(DomWrapper, _React$Component);
  var _super = _createSuper(DomWrapper);
  function DomWrapper() {
    _classCallCheck(this, DomWrapper);
    return _super.apply(this, arguments);
  }
  _createClass(DomWrapper, [{
    key: "render",
    value: function render() {
      return this.props.children;
    }
  }]);
  return DomWrapper;
}(React__namespace.Component);

/**
 * Same as React.useState but `setState` accept `ignoreDestroy` param to not to setState after destroyed.
 * We do not make this auto is to avoid real memory leak.
 * Developer should confirm it's safe to ignore themselves.
 */
function useSafeState(defaultValue) {
  var destroyRef = React__namespace.useRef(false);
  var _React$useState = React__namespace.useState(defaultValue),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    value = _React$useState2[0],
    setValue = _React$useState2[1];
  React__namespace.useEffect(function () {
    destroyRef.current = false;
    return function () {
      destroyRef.current = true;
    };
  }, []);
  function safeSetState(updater, ignoreDestroy) {
    if (ignoreDestroy && destroyRef.current) {
      return;
    }
    setValue(updater);
  }
  return [value, safeSetState];
}

var STATUS_NONE = 'none';
var STATUS_APPEAR = 'appear';
var STATUS_ENTER = 'enter';
var STATUS_LEAVE = 'leave';
var STEP_NONE = 'none';
var STEP_PREPARE = 'prepare';
var STEP_START = 'start';
var STEP_ACTIVE = 'active';
var STEP_ACTIVATED = 'end';
/**
 * Used for disabled motion case.
 * Prepare stage will still work but start & active will be skipped.
 */
var STEP_PREPARED = 'prepared';

// ================= Transition =================
// Event wrapper. Copy from react source code
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};
  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes["Webkit".concat(styleProp)] = "webkit".concat(eventName);
  prefixes["Moz".concat(styleProp)] = "moz".concat(eventName);
  prefixes["ms".concat(styleProp)] = "MS".concat(eventName);
  prefixes["O".concat(styleProp)] = "o".concat(eventName.toLowerCase());
  return prefixes;
}
function getVendorPrefixes(domSupport, win) {
  var prefixes = {
    animationend: makePrefixMap('Animation', 'AnimationEnd'),
    transitionend: makePrefixMap('Transition', 'TransitionEnd')
  };
  if (domSupport) {
    if (!('AnimationEvent' in win)) {
      delete prefixes.animationend.animation;
    }
    if (!('TransitionEvent' in win)) {
      delete prefixes.transitionend.transition;
    }
  }
  return prefixes;
}
var vendorPrefixes = getVendorPrefixes(canUseDom(), typeof window !== 'undefined' ? window : {});
var style = {};
if (canUseDom()) {
  var _document$createEleme = document.createElement('div');
  style = _document$createEleme.style;
}
var prefixedEventNames = {};
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  }
  var prefixMap = vendorPrefixes[eventName];
  if (prefixMap) {
    var stylePropList = Object.keys(prefixMap);
    var len = stylePropList.length;
    for (var i = 0; i < len; i += 1) {
      var styleProp = stylePropList[i];
      if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style) {
        prefixedEventNames[eventName] = prefixMap[styleProp];
        return prefixedEventNames[eventName];
      }
    }
  }
  return '';
}
var internalAnimationEndName = getVendorPrefixedEventName('animationend');
var internalTransitionEndName = getVendorPrefixedEventName('transitionend');
var supportTransition = !!(internalAnimationEndName && internalTransitionEndName);
var animationEndName = internalAnimationEndName || 'animationend';
var transitionEndName = internalTransitionEndName || 'transitionend';
function getTransitionName$2(transitionName, transitionType) {
  if (!transitionName) return null;
  if (_typeof$1(transitionName) === 'object') {
    var type = transitionType.replace(/-\w/g, function (match) {
      return match[1].toUpperCase();
    });
    return transitionName[type];
  }
  return "".concat(transitionName, "-").concat(transitionType);
}

var useDomMotionEvents = (function (callback) {
  var cacheElementRef = React.useRef();

  // Cache callback
  var callbackRef = React.useRef(callback);
  callbackRef.current = callback;

  // Internal motion event handler
  var onInternalMotionEnd = React__namespace.useCallback(function (event) {
    callbackRef.current(event);
  }, []);

  // Remove events
  function removeMotionEvents(element) {
    if (element) {
      element.removeEventListener(transitionEndName, onInternalMotionEnd);
      element.removeEventListener(animationEndName, onInternalMotionEnd);
    }
  }

  // Patch events
  function patchMotionEvents(element) {
    if (cacheElementRef.current && cacheElementRef.current !== element) {
      removeMotionEvents(cacheElementRef.current);
    }
    if (element && element !== cacheElementRef.current) {
      element.addEventListener(transitionEndName, onInternalMotionEnd);
      element.addEventListener(animationEndName, onInternalMotionEnd);

      // Save as cache in case dom removed trigger by `motionDeadline`
      cacheElementRef.current = element;
    }
  }

  // Clean up when removed
  React__namespace.useEffect(function () {
    return function () {
      removeMotionEvents(cacheElementRef.current);
    };
  }, []);
  return [patchMotionEvents, removeMotionEvents];
});

// It's safe to use `useLayoutEffect` but the warning is annoying
var useIsomorphicLayoutEffect = canUseDom() ? React.useLayoutEffect : React.useEffect;

var raf = function raf(callback) {
  return +setTimeout(callback, 16);
};
var caf = function caf(num) {
  return clearTimeout(num);
};
if (typeof window !== 'undefined' && 'requestAnimationFrame' in window) {
  raf = function raf(callback) {
    return window.requestAnimationFrame(callback);
  };
  caf = function caf(handle) {
    return window.cancelAnimationFrame(handle);
  };
}
var rafUUID = 0;
var rafIds = new Map();
function cleanup(id) {
  rafIds.delete(id);
}
var wrapperRaf$1 = function wrapperRaf(callback) {
  var times = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  rafUUID += 1;
  var id = rafUUID;
  function callRef(leftTimes) {
    if (leftTimes === 0) {
      // Clean up
      cleanup(id);

      // Trigger
      callback();
    } else {
      // Next raf
      var realId = raf(function () {
        callRef(leftTimes - 1);
      });

      // Bind real raf id
      rafIds.set(id, realId);
    }
  }
  callRef(times);
  return id;
};
wrapperRaf$1.cancel = function (id) {
  var realId = rafIds.get(id);
  cleanup(realId);
  return caf(realId);
};

var useNextFrame = (function () {
  var nextFrameRef = React__namespace.useRef(null);
  function cancelNextFrame() {
    wrapperRaf$1.cancel(nextFrameRef.current);
  }
  function nextFrame(callback) {
    var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
    cancelNextFrame();
    var nextFrameId = wrapperRaf$1(function () {
      if (delay <= 1) {
        callback({
          isCanceled: function isCanceled() {
            return nextFrameId !== nextFrameRef.current;
          }
        });
      } else {
        nextFrame(callback, delay - 1);
      }
    });
    nextFrameRef.current = nextFrameId;
  }
  React__namespace.useEffect(function () {
    return function () {
      cancelNextFrame();
    };
  }, []);
  return [nextFrame, cancelNextFrame];
});

var FULL_STEP_QUEUE = [STEP_PREPARE, STEP_START, STEP_ACTIVE, STEP_ACTIVATED];
var SIMPLE_STEP_QUEUE = [STEP_PREPARE, STEP_PREPARED];

/** Skip current step */
var SkipStep = false;
/** Current step should be update in */
var DoStep = true;
function isActive(step) {
  return step === STEP_ACTIVE || step === STEP_ACTIVATED;
}
var useStepQueue = (function (status, prepareOnly, callback) {
  var _useState = useSafeState(STEP_NONE),
    _useState2 = _slicedToArray(_useState, 2),
    step = _useState2[0],
    setStep = _useState2[1];
  var _useNextFrame = useNextFrame(),
    _useNextFrame2 = _slicedToArray(_useNextFrame, 2),
    nextFrame = _useNextFrame2[0],
    cancelNextFrame = _useNextFrame2[1];
  function startQueue() {
    setStep(STEP_PREPARE, true);
  }
  var STEP_QUEUE = prepareOnly ? SIMPLE_STEP_QUEUE : FULL_STEP_QUEUE;
  useIsomorphicLayoutEffect(function () {
    if (step !== STEP_NONE && step !== STEP_ACTIVATED) {
      var index = STEP_QUEUE.indexOf(step);
      var nextStep = STEP_QUEUE[index + 1];
      var result = callback(step);
      if (result === SkipStep) {
        // Skip when no needed
        setStep(nextStep, true);
      } else if (nextStep) {
        // Do as frame for step update
        nextFrame(function (info) {
          function doNext() {
            // Skip since current queue is ood
            if (info.isCanceled()) return;
            setStep(nextStep, true);
          }
          if (result === true) {
            doNext();
          } else {
            // Only promise should be async
            Promise.resolve(result).then(doNext);
          }
        });
      }
    }
  }, [status, step]);
  React__namespace.useEffect(function () {
    return function () {
      cancelNextFrame();
    };
  }, []);
  return [startQueue, step];
});

function useStatus(supportMotion, visible, getElement, _ref) {
  var _ref$motionEnter = _ref.motionEnter,
    motionEnter = _ref$motionEnter === void 0 ? true : _ref$motionEnter,
    _ref$motionAppear = _ref.motionAppear,
    motionAppear = _ref$motionAppear === void 0 ? true : _ref$motionAppear,
    _ref$motionLeave = _ref.motionLeave,
    motionLeave = _ref$motionLeave === void 0 ? true : _ref$motionLeave,
    motionDeadline = _ref.motionDeadline,
    motionLeaveImmediately = _ref.motionLeaveImmediately,
    onAppearPrepare = _ref.onAppearPrepare,
    onEnterPrepare = _ref.onEnterPrepare,
    onLeavePrepare = _ref.onLeavePrepare,
    onAppearStart = _ref.onAppearStart,
    onEnterStart = _ref.onEnterStart,
    onLeaveStart = _ref.onLeaveStart,
    onAppearActive = _ref.onAppearActive,
    onEnterActive = _ref.onEnterActive,
    onLeaveActive = _ref.onLeaveActive,
    onAppearEnd = _ref.onAppearEnd,
    onEnterEnd = _ref.onEnterEnd,
    onLeaveEnd = _ref.onLeaveEnd,
    onVisibleChanged = _ref.onVisibleChanged;
  // Used for outer render usage to avoid `visible: false & status: none` to render nothing
  var _useState = useSafeState(),
    _useState2 = _slicedToArray(_useState, 2),
    asyncVisible = _useState2[0],
    setAsyncVisible = _useState2[1];
  var _useState3 = useSafeState(STATUS_NONE),
    _useState4 = _slicedToArray(_useState3, 2),
    status = _useState4[0],
    setStatus = _useState4[1];
  var _useState5 = useSafeState(null),
    _useState6 = _slicedToArray(_useState5, 2),
    style = _useState6[0],
    setStyle = _useState6[1];
  var mountedRef = React.useRef(false);
  var deadlineRef = React.useRef(null);

  // =========================== Dom Node ===========================
  function getDomElement() {
    return getElement();
  }

  // ========================== Motion End ==========================
  var activeRef = React.useRef(false);

  /**
   * Clean up status & style
   */
  function updateMotionEndStatus() {
    setStatus(STATUS_NONE, true);
    setStyle(null, true);
  }
  function onInternalMotionEnd(event) {
    var element = getDomElement();
    if (event && !event.deadline && event.target !== element) {
      // event exists
      // not initiated by deadline
      // transitionEnd not fired by inner elements
      return;
    }
    var currentActive = activeRef.current;
    var canEnd;
    if (status === STATUS_APPEAR && currentActive) {
      canEnd = onAppearEnd === null || onAppearEnd === void 0 ? void 0 : onAppearEnd(element, event);
    } else if (status === STATUS_ENTER && currentActive) {
      canEnd = onEnterEnd === null || onEnterEnd === void 0 ? void 0 : onEnterEnd(element, event);
    } else if (status === STATUS_LEAVE && currentActive) {
      canEnd = onLeaveEnd === null || onLeaveEnd === void 0 ? void 0 : onLeaveEnd(element, event);
    }

    // Only update status when `canEnd` and not destroyed
    if (status !== STATUS_NONE && currentActive && canEnd !== false) {
      updateMotionEndStatus();
    }
  }
  var _useDomMotionEvents = useDomMotionEvents(onInternalMotionEnd),
    _useDomMotionEvents2 = _slicedToArray(_useDomMotionEvents, 1),
    patchMotionEvents = _useDomMotionEvents2[0];

  // ============================= Step =============================
  var getEventHandlers = function getEventHandlers(targetStatus) {
    var _ref2, _ref3, _ref4;
    switch (targetStatus) {
      case STATUS_APPEAR:
        return _ref2 = {}, _defineProperty$1(_ref2, STEP_PREPARE, onAppearPrepare), _defineProperty$1(_ref2, STEP_START, onAppearStart), _defineProperty$1(_ref2, STEP_ACTIVE, onAppearActive), _ref2;
      case STATUS_ENTER:
        return _ref3 = {}, _defineProperty$1(_ref3, STEP_PREPARE, onEnterPrepare), _defineProperty$1(_ref3, STEP_START, onEnterStart), _defineProperty$1(_ref3, STEP_ACTIVE, onEnterActive), _ref3;
      case STATUS_LEAVE:
        return _ref4 = {}, _defineProperty$1(_ref4, STEP_PREPARE, onLeavePrepare), _defineProperty$1(_ref4, STEP_START, onLeaveStart), _defineProperty$1(_ref4, STEP_ACTIVE, onLeaveActive), _ref4;
      default:
        return {};
    }
  };
  var eventHandlers = React__namespace.useMemo(function () {
    return getEventHandlers(status);
  }, [status]);
  var _useStepQueue = useStepQueue(status, !supportMotion, function (newStep) {
      // Only prepare step can be skip
      if (newStep === STEP_PREPARE) {
        var onPrepare = eventHandlers[STEP_PREPARE];
        if (!onPrepare) {
          return SkipStep;
        }
        return onPrepare(getDomElement());
      }

      // Rest step is sync update
      if (step in eventHandlers) {
        var _eventHandlers$step;
        setStyle(((_eventHandlers$step = eventHandlers[step]) === null || _eventHandlers$step === void 0 ? void 0 : _eventHandlers$step.call(eventHandlers, getDomElement(), null)) || null);
      }
      if (step === STEP_ACTIVE) {
        // Patch events when motion needed
        patchMotionEvents(getDomElement());
        if (motionDeadline > 0) {
          clearTimeout(deadlineRef.current);
          deadlineRef.current = setTimeout(function () {
            onInternalMotionEnd({
              deadline: true
            });
          }, motionDeadline);
        }
      }
      if (step === STEP_PREPARED) {
        updateMotionEndStatus();
      }
      return DoStep;
    }),
    _useStepQueue2 = _slicedToArray(_useStepQueue, 2),
    startStep = _useStepQueue2[0],
    step = _useStepQueue2[1];
  var active = isActive(step);
  activeRef.current = active;

  // ============================ Status ============================
  // Update with new status
  useIsomorphicLayoutEffect(function () {
    setAsyncVisible(visible);
    var isMounted = mountedRef.current;
    mountedRef.current = true;

    // if (!supportMotion) {
    //   return;
    // }

    var nextStatus;

    // Appear
    if (!isMounted && visible && motionAppear) {
      nextStatus = STATUS_APPEAR;
    }

    // Enter
    if (isMounted && visible && motionEnter) {
      nextStatus = STATUS_ENTER;
    }

    // Leave
    if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {
      nextStatus = STATUS_LEAVE;
    }
    var nextEventHandlers = getEventHandlers(nextStatus);

    // Update to next status
    if (nextStatus && (supportMotion || nextEventHandlers[STEP_PREPARE])) {
      setStatus(nextStatus);
      startStep();
    } else {
      // Set back in case no motion but prev status has prepare step
      setStatus(STATUS_NONE);
    }
  }, [visible]);

  // ============================ Effect ============================
  // Reset when motion changed
  React.useEffect(function () {
    if (
    // Cancel appear
    status === STATUS_APPEAR && !motionAppear ||
    // Cancel enter
    status === STATUS_ENTER && !motionEnter ||
    // Cancel leave
    status === STATUS_LEAVE && !motionLeave) {
      setStatus(STATUS_NONE);
    }
  }, [motionAppear, motionEnter, motionLeave]);
  React.useEffect(function () {
    return function () {
      mountedRef.current = false;
      clearTimeout(deadlineRef.current);
    };
  }, []);

  // Trigger `onVisibleChanged`
  var firstMountChangeRef = React__namespace.useRef(false);
  React.useEffect(function () {
    // [visible & motion not end] => [!visible & motion end] still need trigger onVisibleChanged
    if (asyncVisible) {
      firstMountChangeRef.current = true;
    }
    if (asyncVisible !== undefined && status === STATUS_NONE) {
      // Skip first render is invisible since it's nothing changed
      if (firstMountChangeRef.current || asyncVisible) {
        onVisibleChanged === null || onVisibleChanged === void 0 ? void 0 : onVisibleChanged(asyncVisible);
      }
      firstMountChangeRef.current = true;
    }
  }, [asyncVisible, status]);

  // ============================ Styles ============================
  var mergedStyle = style;
  if (eventHandlers[STEP_PREPARE] && step === STEP_START) {
    mergedStyle = _objectSpread2$1({
      transition: 'none'
    }, mergedStyle);
  }
  return [status, step, mergedStyle, asyncVisible !== null && asyncVisible !== void 0 ? asyncVisible : visible];
}

/**
 * `transitionSupport` is used for none transition test case.
 * Default we use browser transition event support check.
 */
function genCSSMotion(config) {
  var transitionSupport = config;
  if (_typeof$1(config) === 'object') {
    transitionSupport = config.transitionSupport;
  }
  function isSupportTransition(props, contextMotion) {
    return !!(props.motionName && transitionSupport && contextMotion !== false);
  }
  var CSSMotion = /*#__PURE__*/React__namespace.forwardRef(function (props, ref) {
    var _props$visible = props.visible,
      visible = _props$visible === void 0 ? true : _props$visible,
      _props$removeOnLeave = props.removeOnLeave,
      removeOnLeave = _props$removeOnLeave === void 0 ? true : _props$removeOnLeave,
      forceRender = props.forceRender,
      children = props.children,
      motionName = props.motionName,
      leavedClassName = props.leavedClassName,
      eventProps = props.eventProps;
    var _React$useContext = React__namespace.useContext(Context),
      contextMotion = _React$useContext.motion;
    var supportMotion = isSupportTransition(props, contextMotion);

    // Ref to the react node, it may be a HTMLElement
    var nodeRef = React.useRef();
    // Ref to the dom wrapper in case ref can not pass to HTMLElement
    var wrapperNodeRef = React.useRef();
    function getDomElement() {
      try {
        // Here we're avoiding call for findDOMNode since it's deprecated
        // in strict mode. We're calling it only when node ref is not
        // an instance of DOM HTMLElement. Otherwise use
        // findDOMNode as a final resort
        return nodeRef.current instanceof HTMLElement ? nodeRef.current : findDOMNode(wrapperNodeRef.current);
      } catch (e) {
        // Only happen when `motionDeadline` trigger but element removed.
        return null;
      }
    }
    var _useStatus = useStatus(supportMotion, visible, getDomElement, props),
      _useStatus2 = _slicedToArray(_useStatus, 4),
      status = _useStatus2[0],
      statusStep = _useStatus2[1],
      statusStyle = _useStatus2[2],
      mergedVisible = _useStatus2[3];

    // Record whether content has rendered
    // Will return null for un-rendered even when `removeOnLeave={false}`
    var renderedRef = React__namespace.useRef(mergedVisible);
    if (mergedVisible) {
      renderedRef.current = true;
    }

    // ====================== Refs ======================
    var setNodeRef = React__namespace.useCallback(function (node) {
      nodeRef.current = node;
      fillRef(ref, node);
    }, [ref]);

    // ===================== Render =====================
    var motionChildren;
    var mergedProps = _objectSpread2$1(_objectSpread2$1({}, eventProps), {}, {
      visible: visible
    });
    if (!children) {
      // No children
      motionChildren = null;
    } else if (status === STATUS_NONE) {
      // Stable children
      if (mergedVisible) {
        motionChildren = children(_objectSpread2$1({}, mergedProps), setNodeRef);
      } else if (!removeOnLeave && renderedRef.current && leavedClassName) {
        motionChildren = children(_objectSpread2$1(_objectSpread2$1({}, mergedProps), {}, {
          className: leavedClassName
        }), setNodeRef);
      } else if (forceRender || !removeOnLeave && !leavedClassName) {
        motionChildren = children(_objectSpread2$1(_objectSpread2$1({}, mergedProps), {}, {
          style: {
            display: 'none'
          }
        }), setNodeRef);
      } else {
        motionChildren = null;
      }
    } else {
      var _classNames;
      // In motion
      var statusSuffix;
      if (statusStep === STEP_PREPARE) {
        statusSuffix = 'prepare';
      } else if (isActive(statusStep)) {
        statusSuffix = 'active';
      } else if (statusStep === STEP_START) {
        statusSuffix = 'start';
      }
      var motionCls = getTransitionName$2(motionName, "".concat(status, "-").concat(statusSuffix));
      motionChildren = children(_objectSpread2$1(_objectSpread2$1({}, mergedProps), {}, {
        className: classNames(getTransitionName$2(motionName, status), (_classNames = {}, _defineProperty$1(_classNames, motionCls, motionCls && statusSuffix), _defineProperty$1(_classNames, motionName, typeof motionName === 'string'), _classNames)),
        style: statusStyle
      }), setNodeRef);
    }

    // Auto inject ref if child node not have `ref` props
    if ( /*#__PURE__*/React__namespace.isValidElement(motionChildren) && supportRef(motionChildren)) {
      var _ref = motionChildren,
        originNodeRef = _ref.ref;
      if (!originNodeRef) {
        motionChildren = /*#__PURE__*/React__namespace.cloneElement(motionChildren, {
          ref: setNodeRef
        });
      }
    }
    return /*#__PURE__*/React__namespace.createElement(DomWrapper, {
      ref: wrapperNodeRef
    }, motionChildren);
  });
  CSSMotion.displayName = 'CSSMotion';
  return CSSMotion;
}
var CSSMotion = genCSSMotion(supportTransition);

var STATUS_ADD = 'add';
var STATUS_KEEP = 'keep';
var STATUS_REMOVE = 'remove';
var STATUS_REMOVED = 'removed';
function wrapKeyToObject(key) {
  var keyObj;
  if (key && _typeof$1(key) === 'object' && 'key' in key) {
    keyObj = key;
  } else {
    keyObj = {
      key: key
    };
  }
  return _objectSpread2$1(_objectSpread2$1({}, keyObj), {}, {
    key: String(keyObj.key)
  });
}
function parseKeys() {
  var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return keys.map(wrapKeyToObject);
}
function diffKeys() {
  var prevKeys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var currentKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var list = [];
  var currentIndex = 0;
  var currentLen = currentKeys.length;
  var prevKeyObjects = parseKeys(prevKeys);
  var currentKeyObjects = parseKeys(currentKeys);

  // Check prev keys to insert or keep
  prevKeyObjects.forEach(function (keyObj) {
    var hit = false;
    for (var i = currentIndex; i < currentLen; i += 1) {
      var currentKeyObj = currentKeyObjects[i];
      if (currentKeyObj.key === keyObj.key) {
        // New added keys should add before current key
        if (currentIndex < i) {
          list = list.concat(currentKeyObjects.slice(currentIndex, i).map(function (obj) {
            return _objectSpread2$1(_objectSpread2$1({}, obj), {}, {
              status: STATUS_ADD
            });
          }));
          currentIndex = i;
        }
        list.push(_objectSpread2$1(_objectSpread2$1({}, currentKeyObj), {}, {
          status: STATUS_KEEP
        }));
        currentIndex += 1;
        hit = true;
        break;
      }
    }

    // If not hit, it means key is removed
    if (!hit) {
      list.push(_objectSpread2$1(_objectSpread2$1({}, keyObj), {}, {
        status: STATUS_REMOVE
      }));
    }
  });

  // Add rest to the list
  if (currentIndex < currentLen) {
    list = list.concat(currentKeyObjects.slice(currentIndex).map(function (obj) {
      return _objectSpread2$1(_objectSpread2$1({}, obj), {}, {
        status: STATUS_ADD
      });
    }));
  }

  /**
   * Merge same key when it remove and add again:
   *    [1 - add, 2 - keep, 1 - remove] -> [1 - keep, 2 - keep]
   */
  var keys = {};
  list.forEach(function (_ref) {
    var key = _ref.key;
    keys[key] = (keys[key] || 0) + 1;
  });
  var duplicatedKeys = Object.keys(keys).filter(function (key) {
    return keys[key] > 1;
  });
  duplicatedKeys.forEach(function (matchKey) {
    // Remove `STATUS_REMOVE` node.
    list = list.filter(function (_ref2) {
      var key = _ref2.key,
        status = _ref2.status;
      return key !== matchKey || status !== STATUS_REMOVE;
    });

    // Update `STATUS_ADD` to `STATUS_KEEP`
    list.forEach(function (node) {
      if (node.key === matchKey) {
        // eslint-disable-next-line no-param-reassign
        node.status = STATUS_KEEP;
      }
    });
  });
  return list;
}

var _excluded$3 = ["component", "children", "onVisibleChanged", "onAllRemoved"],
  _excluded2 = ["status"];
var MOTION_PROP_NAMES = ['eventProps', 'visible', 'children', 'motionName', 'motionAppear', 'motionEnter', 'motionLeave', 'motionLeaveImmediately', 'motionDeadline', 'removeOnLeave', 'leavedClassName', 'onAppearPrepare', 'onAppearStart', 'onAppearActive', 'onAppearEnd', 'onEnterStart', 'onEnterActive', 'onEnterEnd', 'onLeaveStart', 'onLeaveActive', 'onLeaveEnd'];
/**
 * Generate a CSSMotionList component with config
 * @param transitionSupport No need since CSSMotionList no longer depends on transition support
 * @param CSSMotion CSSMotion component
 */
function genCSSMotionList(transitionSupport) {
  var CSSMotion$1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CSSMotion;
  var CSSMotionList = /*#__PURE__*/function (_React$Component) {
    _inherits(CSSMotionList, _React$Component);
    var _super = _createSuper(CSSMotionList);
    function CSSMotionList() {
      var _this;
      _classCallCheck(this, CSSMotionList);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty$1(_assertThisInitialized(_this), "state", {
        keyEntities: []
      });
      // ZombieJ: Return the count of rest keys. It's safe to refactor if need more info.
      _defineProperty$1(_assertThisInitialized(_this), "removeKey", function (removeKey) {
        var keyEntities = _this.state.keyEntities;
        var nextKeyEntities = keyEntities.map(function (entity) {
          if (entity.key !== removeKey) return entity;
          return _objectSpread2$1(_objectSpread2$1({}, entity), {}, {
            status: STATUS_REMOVED
          });
        });
        _this.setState({
          keyEntities: nextKeyEntities
        });
        return nextKeyEntities.filter(function (_ref) {
          var status = _ref.status;
          return status !== STATUS_REMOVED;
        }).length;
      });
      return _this;
    }
    _createClass(CSSMotionList, [{
      key: "render",
      value: function render() {
        var _this2 = this;
        var keyEntities = this.state.keyEntities;
        var _this$props = this.props,
          component = _this$props.component,
          children = _this$props.children,
          _onVisibleChanged = _this$props.onVisibleChanged,
          onAllRemoved = _this$props.onAllRemoved,
          restProps = _objectWithoutProperties(_this$props, _excluded$3);
        var Component = component || React__namespace.Fragment;
        var motionProps = {};
        MOTION_PROP_NAMES.forEach(function (prop) {
          motionProps[prop] = restProps[prop];
          delete restProps[prop];
        });
        delete restProps.keys;
        return /*#__PURE__*/React__namespace.createElement(Component, restProps, keyEntities.map(function (_ref2) {
          var status = _ref2.status,
            eventProps = _objectWithoutProperties(_ref2, _excluded2);
          var visible = status === STATUS_ADD || status === STATUS_KEEP;
          return /*#__PURE__*/React__namespace.createElement(CSSMotion$1, _extends({}, motionProps, {
            key: eventProps.key,
            visible: visible,
            eventProps: eventProps,
            onVisibleChanged: function onVisibleChanged(changedVisible) {
              _onVisibleChanged === null || _onVisibleChanged === void 0 ? void 0 : _onVisibleChanged(changedVisible, {
                key: eventProps.key
              });
              if (!changedVisible) {
                var restKeysCount = _this2.removeKey(eventProps.key);
                if (restKeysCount === 0 && onAllRemoved) {
                  onAllRemoved();
                }
              }
            }
          }), children);
        }));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref3, _ref4) {
        var keys = _ref3.keys;
        var keyEntities = _ref4.keyEntities;
        var parsedKeyObjects = parseKeys(keys);
        var mixedKeyEntities = diffKeys(keyEntities, parsedKeyObjects);
        return {
          keyEntities: mixedKeyEntities.filter(function (entity) {
            var prevEntity = keyEntities.find(function (_ref5) {
              var key = _ref5.key;
              return entity.key === key;
            });

            // Remove if already mark as removed
            if (prevEntity && prevEntity.status === STATUS_REMOVED && entity.status === STATUS_REMOVE) {
              return false;
            }
            return true;
          })
        };
      }
    }]);
    return CSSMotionList;
  }(React__namespace.Component);
  _defineProperty$1(CSSMotionList, "defaultProps", {
    component: 'div'
  });
  return CSSMotionList;
}
var CSSMotionList = genCSSMotionList(supportTransition);

// This icon file is generated automatically.
var CloseOutlined$2 = { "icon": { "tag": "svg", "attrs": { "fill-rule": "evenodd", "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z" } }] }, "name": "close", "theme": "outlined" };
var CloseOutlinedSvg = CloseOutlined$2;

var CloseOutlined = function CloseOutlined(props, ref) {
  return /*#__PURE__*/React__namespace.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref: ref,
    icon: CloseOutlinedSvg
  }));
};
CloseOutlined.displayName = 'CloseOutlined';
var CloseOutlined$1 = /*#__PURE__*/React__namespace.forwardRef(CloseOutlined);

var defaultGetPrefixCls = function defaultGetPrefixCls(suffixCls, customizePrefixCls) {
  if (customizePrefixCls) return customizePrefixCls;
  return suffixCls ? "ant-".concat(suffixCls) : 'ant';
};
// zombieJ: 🚨 Do not pass `defaultRenderEmpty` here since it will case circular dependency.
var ConfigContext = /*#__PURE__*/React__namespace.createContext({
  // We provide a default function for Context without provider
  getPrefixCls: defaultGetPrefixCls
});
var ConfigConsumer = ConfigContext.Consumer;

var DisabledContext = /*#__PURE__*/React__namespace.createContext(false);
var DisabledContext$1 = DisabledContext;

var SizeContext = /*#__PURE__*/React__namespace.createContext(undefined);
var SizeContext$1 = SizeContext;

function addEventListenerWrap(target, eventType, cb, option) {
  /* eslint camelcase: 2 */
  var callback = ReactDOM.unstable_batchedUpdates ? function run(e) {
    ReactDOM.unstable_batchedUpdates(cb, e);
  } : cb;
  if (target !== null && target !== void 0 && target.addEventListener) {
    target.addEventListener(eventType, callback, option);
  }
  return {
    remove: function remove() {
      if (target !== null && target !== void 0 && target.removeEventListener) {
        target.removeEventListener(eventType, callback, option);
      }
    }
  };
}

var isValidElement = React__namespace.isValidElement;
function isFragment(child) {
  return child && isValidElement(child) && child.type === React__namespace.Fragment;
}
function replaceElement(element, replacement, props) {
  if (!isValidElement(element)) {
    return replacement;
  }
  return /*#__PURE__*/React__namespace.cloneElement(element, typeof props === 'function' ? props(element.props || {}) : props);
}
function cloneElement(element, props) {
  return replaceElement(element, element, props);
}

function useEvent(callback) {
  var fnRef = React__namespace.useRef();
  fnRef.current = callback;
  var memoFn = React__namespace.useCallback(function () {
    var _fnRef$current;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));
  }, []);
  return memoFn;
}

/**
 * Wrap `React.useLayoutEffect` which will not throw warning message in test env
 */
var useInternalLayoutEffect = process.env.NODE_ENV !== 'test' && canUseDom() ? React__namespace.useLayoutEffect : React__namespace.useEffect;
var useLayoutEffect = function useLayoutEffect(callback, deps) {
  var firstMountRef = React__namespace.useRef(true);
  useInternalLayoutEffect(function () {
    return callback(firstMountRef.current);
  }, deps);

  // We tell react that first mount has passed
  useInternalLayoutEffect(function () {
    firstMountRef.current = false;
    return function () {
      firstMountRef.current = true;
    };
  }, []);
};
var useLayoutUpdateEffect = function useLayoutUpdateEffect(callback, deps) {
  useLayoutEffect(function (firstMount) {
    if (!firstMount) {
      return callback();
    }
  }, deps);
};

/** We only think `undefined` is empty */
function hasValue(value) {
  return value !== undefined;
}

/**
 * Similar to `useState` but will use props value if provided.
 * Note that internal use rc-util `useState` hook.
 */
function useMergedState(defaultStateValue, option) {
  var _ref = option || {},
    defaultValue = _ref.defaultValue,
    value = _ref.value,
    onChange = _ref.onChange,
    postState = _ref.postState;

  // ======================= Init =======================
  var _useState = useSafeState(function () {
      if (hasValue(value)) {
        return value;
      } else if (hasValue(defaultValue)) {
        return typeof defaultValue === 'function' ? defaultValue() : defaultValue;
      } else {
        return typeof defaultStateValue === 'function' ? defaultStateValue() : defaultStateValue;
      }
    }),
    _useState2 = _slicedToArray(_useState, 2),
    innerValue = _useState2[0],
    setInnerValue = _useState2[1];
  var mergedValue = value !== undefined ? value : innerValue;
  var postMergedValue = postState ? postState(mergedValue) : mergedValue;

  // ====================== Change ======================
  var onChangeFn = useEvent(onChange);
  var _useState3 = useSafeState([mergedValue]),
    _useState4 = _slicedToArray(_useState3, 2),
    prevValue = _useState4[0],
    setPrevValue = _useState4[1];
  useLayoutUpdateEffect(function () {
    var prev = prevValue[0];
    if (innerValue !== prev) {
      onChangeFn(innerValue, prev);
    }
  }, [prevValue]);

  // Sync value back to `undefined` when it from control to un-control
  useLayoutUpdateEffect(function () {
    if (!hasValue(value)) {
      setInnerValue(value);
    }
  }, [value]);

  // ====================== Update ======================
  var triggerChange = useEvent(function (updater, ignoreDestroy) {
    setInnerValue(updater, ignoreDestroy);
    setPrevValue([mergedValue], ignoreDestroy);
  });
  return [postMergedValue, triggerChange];
}

var isMobile = (function () {
  if (typeof navigator === 'undefined' || typeof window === 'undefined') {
    return false;
  }
  var agent = navigator.userAgent || navigator.vendor || window.opera;
  return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(agent === null || agent === void 0 ? void 0 : agent.substr(0, 4));
});

var attributes = "accept acceptCharset accessKey action allowFullScreen allowTransparency\n    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge\n    charSet checked classID className colSpan cols content contentEditable contextMenu\n    controls coords crossOrigin data dateTime default defer dir disabled download draggable\n    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder\n    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity\n    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media\n    mediaGroup method min minLength multiple muted name noValidate nonce open\n    optimum pattern placeholder poster preload radioGroup readOnly rel required\n    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected\n    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style\n    summary tabIndex target title type useMap value width wmode wrap";
var eventsName = "onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown\n    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick\n    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown\n    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel\n    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough\n    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata\n    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError";
var propList = "".concat(attributes, " ").concat(eventsName).split(/[\s\n]+/);

/* eslint-enable max-len */
var ariaPrefix = 'aria-';
var dataPrefix = 'data-';
function match(key, prefix) {
  return key.indexOf(prefix) === 0;
}
/**
 * Picker props from exist props with filter
 * @param props Passed props
 * @param ariaOnly boolean | { aria?: boolean; data?: boolean; attr?: boolean; } filter config
 */
function pickAttrs(props) {
  var ariaOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var mergedConfig;
  if (ariaOnly === false) {
    mergedConfig = {
      aria: true,
      data: true,
      attr: true
    };
  } else if (ariaOnly === true) {
    mergedConfig = {
      aria: true
    };
  } else {
    mergedConfig = _objectSpread2$1({}, ariaOnly);
  }
  var attrs = {};
  Object.keys(props).forEach(function (key) {
    if (
    // Aria
    mergedConfig.aria && (key === 'role' || match(key, ariaPrefix)) ||
    // Data
    mergedConfig.data && match(key, dataPrefix) ||
    // Attr
    mergedConfig.attr && propList.includes(key)) {
      attrs[key] = props[key];
    }
  });
  return attrs;
}

var Portal = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var didUpdate = props.didUpdate,
    getContainer = props.getContainer,
    children = props.children;
  var parentRef = React.useRef();
  var containerRef = React.useRef();

  // Ref return nothing, only for wrapper check exist
  React.useImperativeHandle(ref, function () {
    return {};
  });

  // Create container in client side with sync to avoid useEffect not get ref
  var initRef = React.useRef(false);
  if (!initRef.current && canUseDom()) {
    containerRef.current = getContainer();
    parentRef.current = containerRef.current.parentNode;
    initRef.current = true;
  }

  // [Legacy] Used by `rc-trigger`
  React.useEffect(function () {
    didUpdate === null || didUpdate === void 0 ? void 0 : didUpdate(props);
  });
  React.useEffect(function () {
    // Restore container to original place
    // React 18 StrictMode will unmount first and mount back for effect test:
    // https://reactjs.org/blog/2022/03/29/react-v18.html#new-strict-mode-behaviors
    if (containerRef.current.parentNode === null && parentRef.current !== null) {
      parentRef.current.appendChild(containerRef.current);
    }
    return function () {
      var _containerRef$current, _containerRef$current2;
      // [Legacy] This should not be handle by Portal but parent PortalWrapper instead.
      // Since some component use `Portal` directly, we have to keep the logic here.
      (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : (_containerRef$current2 = _containerRef$current.parentNode) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.removeChild(containerRef.current);
    };
  }, []);
  return containerRef.current ? /*#__PURE__*/ReactDOM.createPortal(children, containerRef.current) : null;
});

function isPointsEq(a1, a2, isAlignPoint) {
  if (isAlignPoint) {
    return a1[0] === a2[0];
  }

  return a1[0] === a2[0] && a1[1] === a2[1];
}

function getAlignFromPlacement(builtinPlacements, placementStr, align) {
  var baseAlign = builtinPlacements[placementStr] || {};
  return _objectSpread2$1(_objectSpread2$1({}, baseAlign), align);
}
function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
  var points = align.points;
  var placements = Object.keys(builtinPlacements);

  for (var i = 0; i < placements.length; i += 1) {
    var placement = placements[i];

    if (isPointsEq(builtinPlacements[placement].points, points, isAlignPoint)) {
      return "".concat(prefixCls, "-placement-").concat(placement);
    }
  }

  return '';
}

function getMotion(_ref) {
  var prefixCls = _ref.prefixCls,
      motion = _ref.motion,
      animation = _ref.animation,
      transitionName = _ref.transitionName;

  if (motion) {
    return motion;
  }

  if (animation) {
    return {
      motionName: "".concat(prefixCls, "-").concat(animation)
    };
  }

  if (transitionName) {
    return {
      motionName: transitionName
    };
  }

  return null;
}

function Mask(props) {
  var prefixCls = props.prefixCls,
      visible = props.visible,
      zIndex = props.zIndex,
      mask = props.mask,
      maskMotion = props.maskMotion,
      maskAnimation = props.maskAnimation,
      maskTransitionName = props.maskTransitionName;

  if (!mask) {
    return null;
  }

  var motion = {};

  if (maskMotion || maskTransitionName || maskAnimation) {
    motion = _objectSpread2$1({
      motionAppear: true
    }, getMotion({
      motion: maskMotion,
      prefixCls: prefixCls,
      transitionName: maskTransitionName,
      animation: maskAnimation
    }));
  }

  return /*#__PURE__*/React__namespace.createElement(CSSMotion, _extends({}, motion, {
    visible: visible,
    removeOnLeave: true
  }), function (_ref) {
    var className = _ref.className;
    return /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        zIndex: zIndex
      },
      className: classNames("".concat(prefixCls, "-mask"), className)
    });
  });
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

var vendorPrefix;
var jsCssMap = {
  Webkit: '-webkit-',
  Moz: '-moz-',
  // IE did it wrong again ...
  ms: '-ms-',
  O: '-o-'
};
function getVendorPrefix() {
  if (vendorPrefix !== undefined) {
    return vendorPrefix;
  }
  vendorPrefix = '';
  var style = document.createElement('p').style;
  var testProp = 'Transform';
  for (var key in jsCssMap) {
    if (key + testProp in style) {
      vendorPrefix = key;
    }
  }
  return vendorPrefix;
}
function getTransitionName$1() {
  return getVendorPrefix() ? "".concat(getVendorPrefix(), "TransitionProperty") : 'transitionProperty';
}
function getTransformName() {
  return getVendorPrefix() ? "".concat(getVendorPrefix(), "Transform") : 'transform';
}
function setTransitionProperty(node, value) {
  var name = getTransitionName$1();
  if (name) {
    node.style[name] = value;
    if (name !== 'transitionProperty') {
      node.style.transitionProperty = value;
    }
  }
}
function setTransform(node, value) {
  var name = getTransformName();
  if (name) {
    node.style[name] = value;
    if (name !== 'transform') {
      node.style.transform = value;
    }
  }
}
function getTransitionProperty(node) {
  return node.style.transitionProperty || node.style[getTransitionName$1()];
}
function getTransformXY(node) {
  var style = window.getComputedStyle(node, null);
  var transform = style.getPropertyValue('transform') || style.getPropertyValue(getTransformName());
  if (transform && transform !== 'none') {
    var matrix = transform.replace(/[^0-9\-.,]/g, '').split(',');
    return {
      x: parseFloat(matrix[12] || matrix[4], 0),
      y: parseFloat(matrix[13] || matrix[5], 0)
    };
  }
  return {
    x: 0,
    y: 0
  };
}
var matrix2d = /matrix\((.*)\)/;
var matrix3d = /matrix3d\((.*)\)/;
function setTransformXY(node, xy) {
  var style = window.getComputedStyle(node, null);
  var transform = style.getPropertyValue('transform') || style.getPropertyValue(getTransformName());
  if (transform && transform !== 'none') {
    var arr;
    var match2d = transform.match(matrix2d);
    if (match2d) {
      match2d = match2d[1];
      arr = match2d.split(',').map(function (item) {
        return parseFloat(item, 10);
      });
      arr[4] = xy.x;
      arr[5] = xy.y;
      setTransform(node, "matrix(".concat(arr.join(','), ")"));
    } else {
      var match3d = transform.match(matrix3d)[1];
      arr = match3d.split(',').map(function (item) {
        return parseFloat(item, 10);
      });
      arr[12] = xy.x;
      arr[13] = xy.y;
      setTransform(node, "matrix3d(".concat(arr.join(','), ")"));
    }
  } else {
    setTransform(node, "translateX(".concat(xy.x, "px) translateY(").concat(xy.y, "px) translateZ(0)"));
  }
}

var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;
var getComputedStyleX;

// https://stackoverflow.com/a/3485654/3040605
function forceRelayout(elem) {
  var originalStyle = elem.style.display;
  elem.style.display = 'none';
  elem.offsetHeight; // eslint-disable-line
  elem.style.display = originalStyle;
}
function css(el, name, v) {
  var value = v;
  if (_typeof(name) === 'object') {
    for (var i in name) {
      if (name.hasOwnProperty(i)) {
        css(el, i, name[i]);
      }
    }
    return undefined;
  }
  if (typeof value !== 'undefined') {
    if (typeof value === 'number') {
      value = "".concat(value, "px");
    }
    el.style[name] = value;
    return undefined;
  }
  return getComputedStyleX(el, name);
}
function getClientPosition(elem) {
  var box;
  var x;
  var y;
  var doc = elem.ownerDocument;
  var body = doc.body;
  var docElem = doc && doc.documentElement;
  // 根据 GBS 最新数据，A-Grade Browsers 都已支持 getBoundingClientRect 方法，不用再考虑传统的实现方式
  box = elem.getBoundingClientRect();

  // 注：jQuery 还考虑减去 docElem.clientLeft/clientTop
  // 但测试发现，这样反而会导致当 html 和 body 有边距/边框样式时，获取的值不正确
  // 此外，ie6 会忽略 html 的 margin 值，幸运地是没有谁会去设置 html 的 margin

  x = Math.floor(box.left);
  y = Math.floor(box.top);

  // In IE, most of the time, 2 extra pixels are added to the top and left
  // due to the implicit 2-pixel inset border.  In IE6/7 quirks mode and
  // IE6 standards mode, this border can be overridden by setting the
  // document element's border to zero -- thus, we cannot rely on the
  // offset always being 2 pixels.

  // In quirks mode, the offset can be determined by querying the body's
  // clientLeft/clientTop, but in standards mode, it is found by querying
  // the document element's clientLeft/clientTop.  Since we already called
  // getClientBoundingRect we have already forced a reflow, so it is not
  // too expensive just to query them all.

  // ie 下应该减去窗口的边框吧，毕竟默认 absolute 都是相对窗口定位的
  // 窗口边框标准是设 documentElement ,quirks 时设置 body
  // 最好禁止在 body 和 html 上边框 ，但 ie < 9 html 默认有 2px ，减去
  // 但是非 ie 不可能设置窗口边框，body html 也不是窗口 ,ie 可以通过 html,body 设置
  // 标准 ie 下 docElem.clientTop 就是 border-top
  // ie7 html 即窗口边框改变不了。永远为 2
  // 但标准 firefox/chrome/ie9 下 docElem.clientTop 是窗口边框，即使设了 border-top 也为 0

  x -= docElem.clientLeft || body.clientLeft || 0;
  y -= docElem.clientTop || body.clientTop || 0;
  return {
    left: x,
    top: y
  };
}
function getScroll(w, top) {
  var ret = w["page".concat(top ? 'Y' : 'X', "Offset")];
  var method = "scroll".concat(top ? 'Top' : 'Left');
  if (typeof ret !== 'number') {
    var d = w.document;
    // ie6,7,8 standard mode
    ret = d.documentElement[method];
    if (typeof ret !== 'number') {
      // quirks mode
      ret = d.body[method];
    }
  }
  return ret;
}
function getScrollLeft(w) {
  return getScroll(w);
}
function getScrollTop(w) {
  return getScroll(w, true);
}
function getOffset(el) {
  var pos = getClientPosition(el);
  var doc = el.ownerDocument;
  var w = doc.defaultView || doc.parentWindow;
  pos.left += getScrollLeft(w);
  pos.top += getScrollTop(w);
  return pos;
}

/**
 * A crude way of determining if an object is a window
 * @member util
 */
function isWindow(obj) {
  // must use == for ie8
  /* eslint eqeqeq:0 */
  return obj !== null && obj !== undefined && obj == obj.window;
}
function getDocument(node) {
  if (isWindow(node)) {
    return node.document;
  }
  if (node.nodeType === 9) {
    return node;
  }
  return node.ownerDocument;
}
function _getComputedStyle(elem, name, cs) {
  var computedStyle = cs;
  var val = '';
  var d = getDocument(elem);
  computedStyle = computedStyle || d.defaultView.getComputedStyle(elem, null);

  // https://github.com/kissyteam/kissy/issues/61
  if (computedStyle) {
    val = computedStyle.getPropertyValue(name) || computedStyle[name];
  }
  return val;
}
var _RE_NUM_NO_PX = new RegExp("^(".concat(RE_NUM, ")(?!px)[a-z%]+$"), 'i');
var RE_POS = /^(top|right|bottom|left)$/;
var CURRENT_STYLE = 'currentStyle';
var RUNTIME_STYLE = 'runtimeStyle';
var LEFT = 'left';
var PX = 'px';
function _getComputedStyleIE(elem, name) {
  // currentStyle maybe null
  // http://msdn.microsoft.com/en-us/library/ms535231.aspx
  var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name];

  // 当 width/height 设置为百分比时，通过 pixelLeft 方式转换的 width/height 值
  // 一开始就处理了! CUSTOM_STYLE.height,CUSTOM_STYLE.width ,cssHook 解决@2011-08-19
  // 在 ie 下不对，需要直接用 offset 方式
  // borderWidth 等值也有问题，但考虑到 borderWidth 设为百分比的概率很小，这里就不考虑了

  // From the awesome hack by Dean Edwards
  // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
  // If we're not dealing with a regular pixel number
  // but a number that has a weird ending, we need to convert it to pixels
  // exclude left right for relativity
  if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
    // Remember the original values
    var style = elem.style;
    var left = style[LEFT];
    var rsLeft = elem[RUNTIME_STYLE][LEFT];

    // prevent flashing of content
    elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT];

    // Put in the new values to get a computed value out
    style[LEFT] = name === 'fontSize' ? '1em' : ret || 0;
    ret = style.pixelLeft + PX;

    // Revert the changed values
    style[LEFT] = left;
    elem[RUNTIME_STYLE][LEFT] = rsLeft;
  }
  return ret === '' ? 'auto' : ret;
}
if (typeof window !== 'undefined') {
  getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
}
function getOffsetDirection(dir, option) {
  if (dir === 'left') {
    return option.useCssRight ? 'right' : dir;
  }
  return option.useCssBottom ? 'bottom' : dir;
}
function oppositeOffsetDirection(dir) {
  if (dir === 'left') {
    return 'right';
  } else if (dir === 'right') {
    return 'left';
  } else if (dir === 'top') {
    return 'bottom';
  } else if (dir === 'bottom') {
    return 'top';
  }
}

// 设置 elem 相对 elem.ownerDocument 的坐标
function setLeftTop(elem, offset, option) {
  // set position first, in-case top/left are set even on static elem
  if (css(elem, 'position') === 'static') {
    elem.style.position = 'relative';
  }
  var presetH = -999;
  var presetV = -999;
  var horizontalProperty = getOffsetDirection('left', option);
  var verticalProperty = getOffsetDirection('top', option);
  var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);
  var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);
  if (horizontalProperty !== 'left') {
    presetH = 999;
  }
  if (verticalProperty !== 'top') {
    presetV = 999;
  }
  var originalTransition = '';
  var originalOffset = getOffset(elem);
  if ('left' in offset || 'top' in offset) {
    originalTransition = getTransitionProperty(elem) || '';
    setTransitionProperty(elem, 'none');
  }
  if ('left' in offset) {
    elem.style[oppositeHorizontalProperty] = '';
    elem.style[horizontalProperty] = "".concat(presetH, "px");
  }
  if ('top' in offset) {
    elem.style[oppositeVerticalProperty] = '';
    elem.style[verticalProperty] = "".concat(presetV, "px");
  }
  // force relayout
  forceRelayout(elem);
  var old = getOffset(elem);
  var originalStyle = {};
  for (var key in offset) {
    if (offset.hasOwnProperty(key)) {
      var dir = getOffsetDirection(key, option);
      var preset = key === 'left' ? presetH : presetV;
      var off = originalOffset[key] - old[key];
      if (dir === key) {
        originalStyle[dir] = preset + off;
      } else {
        originalStyle[dir] = preset - off;
      }
    }
  }
  css(elem, originalStyle);
  // force relayout
  forceRelayout(elem);
  if ('left' in offset || 'top' in offset) {
    setTransitionProperty(elem, originalTransition);
  }
  var ret = {};
  for (var _key in offset) {
    if (offset.hasOwnProperty(_key)) {
      var _dir = getOffsetDirection(_key, option);
      var _off = offset[_key] - originalOffset[_key];
      if (_key === _dir) {
        ret[_dir] = originalStyle[_dir] + _off;
      } else {
        ret[_dir] = originalStyle[_dir] - _off;
      }
    }
  }
  css(elem, ret);
}
function setTransform$1(elem, offset) {
  var originalOffset = getOffset(elem);
  var originalXY = getTransformXY(elem);
  var resultXY = {
    x: originalXY.x,
    y: originalXY.y
  };
  if ('left' in offset) {
    resultXY.x = originalXY.x + offset.left - originalOffset.left;
  }
  if ('top' in offset) {
    resultXY.y = originalXY.y + offset.top - originalOffset.top;
  }
  setTransformXY(elem, resultXY);
}
function setOffset(elem, offset, option) {
  if (option.ignoreShake) {
    var oriOffset = getOffset(elem);
    var oLeft = oriOffset.left.toFixed(0);
    var oTop = oriOffset.top.toFixed(0);
    var tLeft = offset.left.toFixed(0);
    var tTop = offset.top.toFixed(0);
    if (oLeft === tLeft && oTop === tTop) {
      return;
    }
  }
  if (option.useCssRight || option.useCssBottom) {
    setLeftTop(elem, offset, option);
  } else if (option.useCssTransform && getTransformName() in document.body.style) {
    setTransform$1(elem, offset);
  } else {
    setLeftTop(elem, offset, option);
  }
}
function each(arr, fn) {
  for (var i = 0; i < arr.length; i++) {
    fn(arr[i]);
  }
}
function isBorderBoxFn(elem) {
  return getComputedStyleX(elem, 'boxSizing') === 'border-box';
}
var BOX_MODELS = ['margin', 'border', 'padding'];
var CONTENT_INDEX = -1;
var PADDING_INDEX = 2;
var BORDER_INDEX = 1;
var MARGIN_INDEX = 0;
function swap(elem, options, callback) {
  var old = {};
  var style = elem.style;
  var name;

  // Remember the old values, and insert the new ones
  for (name in options) {
    if (options.hasOwnProperty(name)) {
      old[name] = style[name];
      style[name] = options[name];
    }
  }
  callback.call(elem);

  // Revert the old values
  for (name in options) {
    if (options.hasOwnProperty(name)) {
      style[name] = old[name];
    }
  }
}
function getPBMWidth(elem, props, which) {
  var value = 0;
  var prop;
  var j;
  var i;
  for (j = 0; j < props.length; j++) {
    prop = props[j];
    if (prop) {
      for (i = 0; i < which.length; i++) {
        var cssProp = void 0;
        if (prop === 'border') {
          cssProp = "".concat(prop).concat(which[i], "Width");
        } else {
          cssProp = prop + which[i];
        }
        value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
      }
    }
  }
  return value;
}
var domUtils = {
  getParent: function getParent(element) {
    var parent = element;
    do {
      if (parent.nodeType === 11 && parent.host) {
        parent = parent.host;
      } else {
        parent = parent.parentNode;
      }
    } while (parent && parent.nodeType !== 1 && parent.nodeType !== 9);
    return parent;
  }
};
each(['Width', 'Height'], function (name) {
  domUtils["doc".concat(name)] = function (refWin) {
    var d = refWin.document;
    return Math.max(
    // firefox chrome documentElement.scrollHeight< body.scrollHeight
    // ie standard mode : documentElement.scrollHeight> body.scrollHeight
    d.documentElement["scroll".concat(name)],
    // quirks : documentElement.scrollHeight 最大等于可视窗口多一点？
    d.body["scroll".concat(name)], domUtils["viewport".concat(name)](d));
  };
  domUtils["viewport".concat(name)] = function (win) {
    // pc browser includes scrollbar in window.innerWidth
    var prop = "client".concat(name);
    var doc = win.document;
    var body = doc.body;
    var documentElement = doc.documentElement;
    var documentElementProp = documentElement[prop];
    // 标准模式取 documentElement
    // backcompat 取 body
    return doc.compatMode === 'CSS1Compat' && documentElementProp || body && body[prop] || documentElementProp;
  };
});

/*
 得到元素的大小信息
 @param elem
 @param name
 @param {String} [extra]  'padding' : (css width) + padding
 'border' : (css width) + padding + border
 'margin' : (css width) + padding + border + margin
 */
function getWH(elem, name, ex) {
  var extra = ex;
  if (isWindow(elem)) {
    return name === 'width' ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
  } else if (elem.nodeType === 9) {
    return name === 'width' ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
  }
  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];
  var borderBoxValue = name === 'width' ? Math.floor(elem.getBoundingClientRect().width) : Math.floor(elem.getBoundingClientRect().height);
  var isBorderBox = isBorderBoxFn(elem);
  var cssBoxValue = 0;
  if (borderBoxValue === null || borderBoxValue === undefined || borderBoxValue <= 0) {
    borderBoxValue = undefined;
    // Fall back to computed then un computed css if necessary
    cssBoxValue = getComputedStyleX(elem, name);
    if (cssBoxValue === null || cssBoxValue === undefined || Number(cssBoxValue) < 0) {
      cssBoxValue = elem.style[name] || 0;
    }
    // Normalize '', auto, and prepare for extra
    cssBoxValue = Math.floor(parseFloat(cssBoxValue)) || 0;
  }
  if (extra === undefined) {
    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
  }
  var borderBoxValueOrIsBorderBox = borderBoxValue !== undefined || isBorderBox;
  var val = borderBoxValue || cssBoxValue;
  if (extra === CONTENT_INDEX) {
    if (borderBoxValueOrIsBorderBox) {
      return val - getPBMWidth(elem, ['border', 'padding'], which);
    }
    return cssBoxValue;
  } else if (borderBoxValueOrIsBorderBox) {
    if (extra === BORDER_INDEX) {
      return val;
    }
    return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, ['border'], which) : getPBMWidth(elem, ['margin'], which));
  }
  return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which);
}
var cssShow = {
  position: 'absolute',
  visibility: 'hidden',
  display: 'block'
};

// fix #119 : https://github.com/kissyteam/kissy/issues/119
function getWHIgnoreDisplay() {
  for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
    args[_key2] = arguments[_key2];
  }
  var val;
  var elem = args[0];
  // in case elem is window
  // elem.offsetWidth === undefined
  if (elem.offsetWidth !== 0) {
    val = getWH.apply(undefined, args);
  } else {
    swap(elem, cssShow, function () {
      val = getWH.apply(undefined, args);
    });
  }
  return val;
}
each(['width', 'height'], function (name) {
  var first = name.charAt(0).toUpperCase() + name.slice(1);
  domUtils["outer".concat(first)] = function (el, includeMargin) {
    return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
  };
  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];
  domUtils[name] = function (elem, v) {
    var val = v;
    if (val !== undefined) {
      if (elem) {
        var isBorderBox = isBorderBoxFn(elem);
        if (isBorderBox) {
          val += getPBMWidth(elem, ['padding', 'border'], which);
        }
        return css(elem, name, val);
      }
      return undefined;
    }
    return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
  };
});
function mix(to, from) {
  for (var i in from) {
    if (from.hasOwnProperty(i)) {
      to[i] = from[i];
    }
  }
  return to;
}
var utils = {
  getWindow: function getWindow(node) {
    if (node && node.document && node.setTimeout) {
      return node;
    }
    var doc = node.ownerDocument || node;
    return doc.defaultView || doc.parentWindow;
  },
  getDocument: getDocument,
  offset: function offset(el, value, option) {
    if (typeof value !== 'undefined') {
      setOffset(el, value, option || {});
    } else {
      return getOffset(el);
    }
  },
  isWindow: isWindow,
  each: each,
  css: css,
  clone: function clone(obj) {
    var i;
    var ret = {};
    for (i in obj) {
      if (obj.hasOwnProperty(i)) {
        ret[i] = obj[i];
      }
    }
    var overflow = obj.overflow;
    if (overflow) {
      for (i in obj) {
        if (obj.hasOwnProperty(i)) {
          ret.overflow[i] = obj.overflow[i];
        }
      }
    }
    return ret;
  },
  mix: mix,
  getWindowScrollLeft: function getWindowScrollLeft(w) {
    return getScrollLeft(w);
  },
  getWindowScrollTop: function getWindowScrollTop(w) {
    return getScrollTop(w);
  },
  merge: function merge() {
    var ret = {};
    for (var i = 0; i < arguments.length; i++) {
      utils.mix(ret, i < 0 || arguments.length <= i ? undefined : arguments[i]);
    }
    return ret;
  },
  viewportWidth: 0,
  viewportHeight: 0
};
mix(utils, domUtils);

/**
 * 得到会导致元素显示不全的祖先元素
 */
var getParent = utils.getParent;
function getOffsetParent(element) {
  if (utils.isWindow(element) || element.nodeType === 9) {
    return null;
  }
  // ie 这个也不是完全可行
  /*
   <div style="width: 50px;height: 100px;overflow: hidden">
   <div style="width: 50px;height: 100px;position: relative;" id="d6">
   元素 6 高 100px 宽 50px<br/>
   </div>
   </div>
   */
  // element.offsetParent does the right thing in ie7 and below. Return parent with layout!
  //  In other browsers it only includes elements with position absolute, relative or
  // fixed, not elements with overflow set to auto or scroll.
  //        if (UA.ie && ieMode < 8) {
  //            return element.offsetParent;
  //        }
  // 统一的 offsetParent 方法
  var doc = utils.getDocument(element);
  var body = doc.body;
  var parent;
  var positionStyle = utils.css(element, 'position');
  var skipStatic = positionStyle === 'fixed' || positionStyle === 'absolute';
  if (!skipStatic) {
    return element.nodeName.toLowerCase() === 'html' ? null : getParent(element);
  }
  for (parent = getParent(element); parent && parent !== body && parent.nodeType !== 9; parent = getParent(parent)) {
    positionStyle = utils.css(parent, 'position');
    if (positionStyle !== 'static') {
      return parent;
    }
  }
  return null;
}

var getParent$1 = utils.getParent;
function isAncestorFixed(element) {
  if (utils.isWindow(element) || element.nodeType === 9) {
    return false;
  }
  var doc = utils.getDocument(element);
  var body = doc.body;
  var parent = null;
  for (parent = getParent$1(element);
  // 修复元素位于 document.documentElement 下导致崩溃问题
  parent && parent !== body && parent !== doc; parent = getParent$1(parent)) {
    var positionStyle = utils.css(parent, 'position');
    if (positionStyle === 'fixed') {
      return true;
    }
  }
  return false;
}

/**
 * 获得元素的显示部分的区域
 */
function getVisibleRectForElement(element, alwaysByViewport) {
  var visibleRect = {
    left: 0,
    right: Infinity,
    top: 0,
    bottom: Infinity
  };
  var el = getOffsetParent(element);
  var doc = utils.getDocument(element);
  var win = doc.defaultView || doc.parentWindow;
  var body = doc.body;
  var documentElement = doc.documentElement;

  // Determine the size of the visible rect by climbing the dom accounting for
  // all scrollable containers.
  while (el) {
    // clientWidth is zero for inline block elements in ie.
    if ((navigator.userAgent.indexOf('MSIE') === -1 || el.clientWidth !== 0) &&
    // body may have overflow set on it, yet we still get the entire
    // viewport. In some browsers, el.offsetParent may be
    // document.documentElement, so check for that too.
    el !== body && el !== documentElement && utils.css(el, 'overflow') !== 'visible') {
      var pos = utils.offset(el);
      // add border
      pos.left += el.clientLeft;
      pos.top += el.clientTop;
      visibleRect.top = Math.max(visibleRect.top, pos.top);
      visibleRect.right = Math.min(visibleRect.right,
      // consider area without scrollBar
      pos.left + el.clientWidth);
      visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);
      visibleRect.left = Math.max(visibleRect.left, pos.left);
    } else if (el === body || el === documentElement) {
      break;
    }
    el = getOffsetParent(el);
  }

  // Set element position to fixed
  // make sure absolute element itself don't affect it's visible area
  // https://github.com/ant-design/ant-design/issues/7601
  var originalPosition = null;
  if (!utils.isWindow(element) && element.nodeType !== 9) {
    originalPosition = element.style.position;
    var position = utils.css(element, 'position');
    if (position === 'absolute') {
      element.style.position = 'fixed';
    }
  }
  var scrollX = utils.getWindowScrollLeft(win);
  var scrollY = utils.getWindowScrollTop(win);
  var viewportWidth = utils.viewportWidth(win);
  var viewportHeight = utils.viewportHeight(win);
  var documentWidth = documentElement.scrollWidth;
  var documentHeight = documentElement.scrollHeight;

  // scrollXXX on html is sync with body which means overflow: hidden on body gets wrong scrollXXX.
  // We should cut this ourself.
  var bodyStyle = window.getComputedStyle(body);
  if (bodyStyle.overflowX === 'hidden') {
    documentWidth = win.innerWidth;
  }
  if (bodyStyle.overflowY === 'hidden') {
    documentHeight = win.innerHeight;
  }

  // Reset element position after calculate the visible area
  if (element.style) {
    element.style.position = originalPosition;
  }
  if (alwaysByViewport || isAncestorFixed(element)) {
    // Clip by viewport's size.
    visibleRect.left = Math.max(visibleRect.left, scrollX);
    visibleRect.top = Math.max(visibleRect.top, scrollY);
    visibleRect.right = Math.min(visibleRect.right, scrollX + viewportWidth);
    visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + viewportHeight);
  } else {
    // Clip by document's size.
    var maxVisibleWidth = Math.max(documentWidth, scrollX + viewportWidth);
    visibleRect.right = Math.min(visibleRect.right, maxVisibleWidth);
    var maxVisibleHeight = Math.max(documentHeight, scrollY + viewportHeight);
    visibleRect.bottom = Math.min(visibleRect.bottom, maxVisibleHeight);
  }
  return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
}

function adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {
  var pos = utils.clone(elFuturePos);
  var size = {
    width: elRegion.width,
    height: elRegion.height
  };
  if (overflow.adjustX && pos.left < visibleRect.left) {
    pos.left = visibleRect.left;
  }

  // Left edge inside and right edge outside viewport, try to resize it.
  if (overflow.resizeWidth && pos.left >= visibleRect.left && pos.left + size.width > visibleRect.right) {
    size.width -= pos.left + size.width - visibleRect.right;
  }

  // Right edge outside viewport, try to move it.
  if (overflow.adjustX && pos.left + size.width > visibleRect.right) {
    // 保证左边界和可视区域左边界对齐
    pos.left = Math.max(visibleRect.right - size.width, visibleRect.left);
  }

  // Top edge outside viewport, try to move it.
  if (overflow.adjustY && pos.top < visibleRect.top) {
    pos.top = visibleRect.top;
  }

  // Top edge inside and bottom edge outside viewport, try to resize it.
  if (overflow.resizeHeight && pos.top >= visibleRect.top && pos.top + size.height > visibleRect.bottom) {
    size.height -= pos.top + size.height - visibleRect.bottom;
  }

  // Bottom edge outside viewport, try to move it.
  if (overflow.adjustY && pos.top + size.height > visibleRect.bottom) {
    // 保证上边界和可视区域上边界对齐
    pos.top = Math.max(visibleRect.bottom - size.height, visibleRect.top);
  }
  return utils.mix(pos, size);
}

function getRegion(node) {
  var offset;
  var w;
  var h;
  if (!utils.isWindow(node) && node.nodeType !== 9) {
    offset = utils.offset(node);
    w = utils.outerWidth(node);
    h = utils.outerHeight(node);
  } else {
    var win = utils.getWindow(node);
    offset = {
      left: utils.getWindowScrollLeft(win),
      top: utils.getWindowScrollTop(win)
    };
    w = utils.viewportWidth(win);
    h = utils.viewportHeight(win);
  }
  offset.width = w;
  offset.height = h;
  return offset;
}

/**
 * 获取 node 上的 align 对齐点 相对于页面的坐标
 */

function getAlignOffset(region, align) {
  var V = align.charAt(0);
  var H = align.charAt(1);
  var w = region.width;
  var h = region.height;
  var x = region.left;
  var y = region.top;
  if (V === 'c') {
    y += h / 2;
  } else if (V === 'b') {
    y += h;
  }
  if (H === 'c') {
    x += w / 2;
  } else if (H === 'r') {
    x += w;
  }
  return {
    left: x,
    top: y
  };
}

function getElFuturePos(elRegion, refNodeRegion, points, offset, targetOffset) {
  var p1 = getAlignOffset(refNodeRegion, points[1]);
  var p2 = getAlignOffset(elRegion, points[0]);
  var diff = [p2.left - p1.left, p2.top - p1.top];
  return {
    left: Math.round(elRegion.left - diff[0] + offset[0] - targetOffset[0]),
    top: Math.round(elRegion.top - diff[1] + offset[1] - targetOffset[1])
  };
}

/**
 * align dom node flexibly
 * @author yiminghe@gmail.com
 */

// http://yiminghe.iteye.com/blog/1124720

function isFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;
}
function isFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;
}
function isCompleteFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;
}
function isCompleteFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;
}
function flip(points, reg, map) {
  var ret = [];
  utils.each(points, function (p) {
    ret.push(p.replace(reg, function (m) {
      return map[m];
    }));
  });
  return ret;
}
function flipOffset(offset, index) {
  offset[index] = -offset[index];
  return offset;
}
function convertOffset(str, offsetLen) {
  var n;
  if (/%$/.test(str)) {
    n = parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen;
  } else {
    n = parseInt(str, 10);
  }
  return n || 0;
}
function normalizeOffset(offset, el) {
  offset[0] = convertOffset(offset[0], el.width);
  offset[1] = convertOffset(offset[1], el.height);
}

/**
 * @param el
 * @param tgtRegion 参照节点所占的区域: { left, top, width, height }
 * @param align
 */
function doAlign(el, tgtRegion, align, isTgtRegionVisible) {
  var points = align.points;
  var offset = align.offset || [0, 0];
  var targetOffset = align.targetOffset || [0, 0];
  var overflow = align.overflow;
  var source = align.source || el;
  offset = [].concat(offset);
  targetOffset = [].concat(targetOffset);
  overflow = overflow || {};
  var newOverflowCfg = {};
  var fail = 0;
  var alwaysByViewport = !!(overflow && overflow.alwaysByViewport);
  // 当前节点可以被放置的显示区域
  var visibleRect = getVisibleRectForElement(source, alwaysByViewport);
  // 当前节点所占的区域, left/top/width/height
  var elRegion = getRegion(source);
  // 将 offset 转换成数值，支持百分比
  normalizeOffset(offset, elRegion);
  normalizeOffset(targetOffset, tgtRegion);
  // 当前节点将要被放置的位置
  var elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset, targetOffset);
  // 当前节点将要所处的区域
  var newElRegion = utils.merge(elRegion, elFuturePos);

  // 如果可视区域不能完全放置当前节点时允许调整
  if (visibleRect && (overflow.adjustX || overflow.adjustY) && isTgtRegionVisible) {
    if (overflow.adjustX) {
      // 如果横向不能放下
      if (isFailX(elFuturePos, elRegion, visibleRect)) {
        // 对齐位置反下
        var newPoints = flip(points, /[lr]/gi, {
          l: 'r',
          r: 'l'
        });
        // 偏移量也反下
        var newOffset = flipOffset(offset, 0);
        var newTargetOffset = flipOffset(targetOffset, 0);
        var newElFuturePos = getElFuturePos(elRegion, tgtRegion, newPoints, newOffset, newTargetOffset);
        if (!isCompleteFailX(newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = newPoints;
          offset = newOffset;
          targetOffset = newTargetOffset;
        }
      }
    }
    if (overflow.adjustY) {
      // 如果纵向不能放下
      if (isFailY(elFuturePos, elRegion, visibleRect)) {
        // 对齐位置反下
        var _newPoints = flip(points, /[tb]/gi, {
          t: 'b',
          b: 't'
        });
        // 偏移量也反下
        var _newOffset = flipOffset(offset, 1);
        var _newTargetOffset = flipOffset(targetOffset, 1);
        var _newElFuturePos = getElFuturePos(elRegion, tgtRegion, _newPoints, _newOffset, _newTargetOffset);
        if (!isCompleteFailY(_newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = _newPoints;
          offset = _newOffset;
          targetOffset = _newTargetOffset;
        }
      }
    }

    // 如果失败，重新计算当前节点将要被放置的位置
    if (fail) {
      elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset, targetOffset);
      utils.mix(newElRegion, elFuturePos);
    }
    var isStillFailX = isFailX(elFuturePos, elRegion, visibleRect);
    var isStillFailY = isFailY(elFuturePos, elRegion, visibleRect);
    // 检查反下后的位置是否可以放下了，如果仍然放不下：
    // 1. 复原修改过的定位参数
    if (isStillFailX || isStillFailY) {
      var _newPoints2 = points;

      // 重置对应部分的翻转逻辑
      if (isStillFailX) {
        _newPoints2 = flip(points, /[lr]/gi, {
          l: 'r',
          r: 'l'
        });
      }
      if (isStillFailY) {
        _newPoints2 = flip(points, /[tb]/gi, {
          t: 'b',
          b: 't'
        });
      }
      points = _newPoints2;
      offset = align.offset || [0, 0];
      targetOffset = align.targetOffset || [0, 0];
    }
    // 2. 只有指定了可以调整当前方向才调整
    newOverflowCfg.adjustX = overflow.adjustX && isStillFailX;
    newOverflowCfg.adjustY = overflow.adjustY && isStillFailY;

    // 确实要调整，甚至可能会调整高度宽度
    if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {
      newElRegion = adjustForViewport(elFuturePos, elRegion, visibleRect, newOverflowCfg);
    }
  }

  // need judge to in case set fixed with in css on height auto element
  if (newElRegion.width !== elRegion.width) {
    utils.css(source, 'width', utils.width(source) + newElRegion.width - elRegion.width);
  }
  if (newElRegion.height !== elRegion.height) {
    utils.css(source, 'height', utils.height(source) + newElRegion.height - elRegion.height);
  }

  // https://github.com/kissyteam/kissy/issues/190
  // 相对于屏幕位置没变，而 left/top 变了
  // 例如 <div 'relative'><el absolute></div>
  utils.offset(source, {
    left: newElRegion.left,
    top: newElRegion.top
  }, {
    useCssRight: align.useCssRight,
    useCssBottom: align.useCssBottom,
    useCssTransform: align.useCssTransform,
    ignoreShake: align.ignoreShake
  });
  return {
    points: points,
    offset: offset,
    targetOffset: targetOffset,
    overflow: newOverflowCfg
  };
}
/**
 *  2012-04-26 yiminghe@gmail.com
 *   - 优化智能对齐算法
 *   - 慎用 resizeXX
 *
 *  2011-07-13 yiminghe@gmail.com note:
 *   - 增加智能对齐，以及大小调整选项
 **/

function isOutOfVisibleRect(target, alwaysByViewport) {
  var visibleRect = getVisibleRectForElement(target, alwaysByViewport);
  var targetRegion = getRegion(target);
  return !visibleRect || targetRegion.left + targetRegion.width <= visibleRect.left || targetRegion.top + targetRegion.height <= visibleRect.top || targetRegion.left >= visibleRect.right || targetRegion.top >= visibleRect.bottom;
}
function alignElement(el, refNode, align) {
  var target = align.target || refNode;
  var refNodeRegion = getRegion(target);
  var isTargetNotOutOfVisible = !isOutOfVisibleRect(target, align.overflow && align.overflow.alwaysByViewport);
  return doAlign(el, refNodeRegion, align, isTargetNotOutOfVisible);
}
alignElement.__getOffsetParent = getOffsetParent;
alignElement.__getVisibleRectForElement = getVisibleRectForElement;

/**
 * `tgtPoint`: { pageX, pageY } or { clientX, clientY }.
 * If client position provided, will internal convert to page position.
 */

function alignPoint(el, tgtPoint, align) {
  var pageX;
  var pageY;
  var doc = utils.getDocument(el);
  var win = doc.defaultView || doc.parentWindow;
  var scrollX = utils.getWindowScrollLeft(win);
  var scrollY = utils.getWindowScrollTop(win);
  var viewportWidth = utils.viewportWidth(win);
  var viewportHeight = utils.viewportHeight(win);
  if ('pageX' in tgtPoint) {
    pageX = tgtPoint.pageX;
  } else {
    pageX = scrollX + tgtPoint.clientX;
  }
  if ('pageY' in tgtPoint) {
    pageY = tgtPoint.pageY;
  } else {
    pageY = scrollY + tgtPoint.clientY;
  }
  var tgtRegion = {
    left: pageX,
    top: pageY,
    width: 0,
    height: 0
  };
  var pointInView = pageX >= 0 && pageX <= scrollX + viewportWidth && pageY >= 0 && pageY <= scrollY + viewportHeight;

  // Provide default target point
  var points = [align.points[0], 'cc'];
  return doAlign(el, tgtRegion, _objectSpread2(_objectSpread2({}, align), {}, {
    points: points
  }), pointInView);
}

/**
 * Deeply compares two object literals.
 * @param obj1 object 1
 * @param obj2 object 2
 * @param shallow shallow compare
 * @returns
 */
function isEqual(obj1, obj2) {
  var shallow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  // https://github.com/mapbox/mapbox-gl-js/pull/5979/files#diff-fde7145050c47cc3a306856efd5f9c3016e86e859de9afbd02c879be5067e58f
  var refSet = new Set();
  function deepEqual(a, b) {
    var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var circular = refSet.has(a);
    warningOnce(!circular, 'Warning: There may be circular references');
    if (circular) {
      return false;
    }
    if (a === b) {
      return true;
    }
    if (shallow && level > 1) {
      return false;
    }
    refSet.add(a);
    var newLevel = level + 1;
    if (Array.isArray(a)) {
      if (!Array.isArray(b) || a.length !== b.length) {
        return false;
      }
      for (var i = 0; i < a.length; i++) {
        if (!deepEqual(a[i], b[i], newLevel)) {
          return false;
        }
      }
      return true;
    }
    if (a && b && _typeof$1(a) === 'object' && _typeof$1(b) === 'object') {
      var keys = Object.keys(a);
      if (keys.length !== Object.keys(b).length) {
        return false;
      }
      return keys.every(function (key) {
        return deepEqual(a[key], b[key], newLevel);
      });
    }
    // other
    return false;
  }
  return deepEqual(obj1, obj2);
}

var isVisible = (function (element) {
  if (!element) {
    return false;
  }
  if (element instanceof Element) {
    if (element.offsetParent) {
      return true;
    }
    if (element.getBBox) {
      var _getBBox = element.getBBox(),
        width = _getBBox.width,
        height = _getBBox.height;
      if (width || height) {
        return true;
      }
    }
    if (element.getBoundingClientRect) {
      var _element$getBoundingC = element.getBoundingClientRect(),
        _width = _element$getBoundingC.width,
        _height = _element$getBoundingC.height;
      if (_width || _height) {
        return true;
      }
    }
  }
  return false;
});

var useBuffer = (function (callback, buffer) {
  var calledRef = React.useRef(false);
  var timeoutRef = React.useRef(null);

  function cancelTrigger() {
    window.clearTimeout(timeoutRef.current);
  }

  function trigger(force) {
    cancelTrigger();

    if (!calledRef.current || force === true) {
      if (callback(force) === false) {
        // Not delay since callback cancelled self
        return;
      }

      calledRef.current = true;
      timeoutRef.current = window.setTimeout(function () {
        calledRef.current = false;
      }, buffer);
    } else {
      timeoutRef.current = window.setTimeout(function () {
        calledRef.current = false;
        trigger();
      }, buffer);
    }
  }

  return [trigger, function () {
    calledRef.current = false;
    cancelTrigger();
  }];
});

function isSamePoint(prev, next) {
  if (prev === next) return true;
  if (!prev || !next) return false;

  if ('pageX' in next && 'pageY' in next) {
    return prev.pageX === next.pageX && prev.pageY === next.pageY;
  }

  if ('clientX' in next && 'clientY' in next) {
    return prev.clientX === next.clientX && prev.clientY === next.clientY;
  }

  return false;
}
function restoreFocus(activeElement, container) {
  // Focus back if is in the container
  if (activeElement !== document.activeElement && contains(container, activeElement) && typeof activeElement.focus === 'function') {
    activeElement.focus();
  }
}
function monitorResize(element, callback) {
  var prevWidth = null;
  var prevHeight = null;

  function onResize(_ref) {
    var _ref2 = _slicedToArray(_ref, 1),
        target = _ref2[0].target;

    if (!document.documentElement.contains(target)) return;

    var _target$getBoundingCl = target.getBoundingClientRect(),
        width = _target$getBoundingCl.width,
        height = _target$getBoundingCl.height;

    var fixedWidth = Math.floor(width);
    var fixedHeight = Math.floor(height);

    if (prevWidth !== fixedWidth || prevHeight !== fixedHeight) {
      // https://webkit.org/blog/9997/resizeobserver-in-webkit/
      Promise.resolve().then(function () {
        callback({
          width: fixedWidth,
          height: fixedHeight
        });
      });
    }

    prevWidth = fixedWidth;
    prevHeight = fixedHeight;
  }

  var resizeObserver = new index$1(onResize);

  if (element) {
    resizeObserver.observe(element);
  }

  return function () {
    resizeObserver.disconnect();
  };
}

function getElement(func) {
  if (typeof func !== 'function') return null;
  return func();
}

function getPoint(point) {
  if (_typeof$1(point) !== 'object' || !point) return null;
  return point;
}

var Align = function Align(_ref, ref) {
  var children = _ref.children,
      disabled = _ref.disabled,
      target = _ref.target,
      align = _ref.align,
      onAlign = _ref.onAlign,
      monitorWindowResize = _ref.monitorWindowResize,
      _ref$monitorBufferTim = _ref.monitorBufferTime,
      monitorBufferTime = _ref$monitorBufferTim === void 0 ? 0 : _ref$monitorBufferTim;
  var cacheRef = React.useRef({});
  /** Popup node ref */

  var nodeRef = React.useRef();
  var childNode = React.Children.only(children); // ===================== Align ======================
  // We save the props here to avoid closure makes props ood

  var forceAlignPropsRef = React.useRef({});
  forceAlignPropsRef.current.disabled = disabled;
  forceAlignPropsRef.current.target = target;
  forceAlignPropsRef.current.align = align;
  forceAlignPropsRef.current.onAlign = onAlign;

  var _useBuffer = useBuffer(function () {
    var _forceAlignPropsRef$c = forceAlignPropsRef.current,
        latestDisabled = _forceAlignPropsRef$c.disabled,
        latestTarget = _forceAlignPropsRef$c.target,
        latestAlign = _forceAlignPropsRef$c.align,
        latestOnAlign = _forceAlignPropsRef$c.onAlign;
    var source = nodeRef.current;

    if (!latestDisabled && latestTarget && source) {
      var _result;

      var _element = getElement(latestTarget);

      var _point = getPoint(latestTarget);

      cacheRef.current.element = _element;
      cacheRef.current.point = _point;
      cacheRef.current.align = latestAlign; // IE lose focus after element realign
      // We should record activeElement and restore later

      var _document = document,
          activeElement = _document.activeElement; // We only align when element is visible

      if (_element && isVisible(_element)) {
        _result = alignElement(source, _element, latestAlign);
      } else if (_point) {
        _result = alignPoint(source, _point, latestAlign);
      }

      restoreFocus(activeElement, source);

      if (latestOnAlign && _result) {
        latestOnAlign(source, _result);
      }

      return true;
    }

    return false;
  }, monitorBufferTime),
      _useBuffer2 = _slicedToArray(_useBuffer, 2),
      _forceAlign = _useBuffer2[0],
      cancelForceAlign = _useBuffer2[1]; // ===================== Effect =====================
  // Handle props change


  var _React$useState = React.useState(),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      element = _React$useState2[0],
      setElement = _React$useState2[1];

  var _React$useState3 = React.useState(),
      _React$useState4 = _slicedToArray(_React$useState3, 2),
      point = _React$useState4[0],
      setPoint = _React$useState4[1];

  useLayoutEffect(function () {
    setElement(getElement(target));
    setPoint(getPoint(target));
  });
  React.useEffect(function () {
    if (cacheRef.current.element !== element || !isSamePoint(cacheRef.current.point, point) || !isEqual(cacheRef.current.align, align)) {
      _forceAlign();
    }
  }); // Watch popup element resize

  React.useEffect(function () {
    var cancelFn = monitorResize(nodeRef.current, _forceAlign);
    return cancelFn;
  }, [nodeRef.current]); // Watch target element resize

  React.useEffect(function () {
    var cancelFn = monitorResize(element, _forceAlign);
    return cancelFn;
  }, [element]); // Listen for disabled change

  React.useEffect(function () {
    if (!disabled) {
      _forceAlign();
    } else {
      cancelForceAlign();
    }
  }, [disabled]); // Listen for window resize

  React.useEffect(function () {
    if (monitorWindowResize) {
      var cancelFn = addEventListenerWrap(window, 'resize', _forceAlign);
      return cancelFn.remove;
    }
  }, [monitorWindowResize]); // Clear all if unmount

  React.useEffect(function () {
    return function () {
      cancelForceAlign();
    };
  }, []); // ====================== Ref =======================

  React.useImperativeHandle(ref, function () {
    return {
      forceAlign: function forceAlign() {
        return _forceAlign(true);
      }
    };
  }); // ===================== Render =====================

  if ( /*#__PURE__*/React.isValidElement(childNode)) {
    childNode = /*#__PURE__*/React.cloneElement(childNode, {
      ref: composeRef(childNode.ref, nodeRef)
    });
  }

  return childNode;
};

var RcAlign = /*#__PURE__*/React.forwardRef(Align);
RcAlign.displayName = 'Align';

/**
 * Popup should follow the steps for each component work correctly:
 * measure - check for the current stretch size
 * align - let component align the position
 * aligned - re-align again in case additional className changed the size
 * afterAlign - choice next step is trigger motion or finished
 * beforeMotion - should reset motion to invisible so that CSSMotion can do normal motion
 * motion - play the motion
 * stable - everything is done
 */

var StatusQueue = ['measure', 'alignPre', 'align', null, 'motion'];
var useVisibleStatus = (function (visible, doMeasure) {
  var _useState = useSafeState(null),
      _useState2 = _slicedToArray(_useState, 2),
      status = _useState2[0],
      setInternalStatus = _useState2[1];

  var rafRef = React.useRef();

  function setStatus(nextStatus) {
    setInternalStatus(nextStatus, true);
  }

  function cancelRaf() {
    wrapperRaf$1.cancel(rafRef.current);
  }

  function goNextStatus(callback) {
    cancelRaf();
    rafRef.current = wrapperRaf$1(function () {
      // Only align should be manually trigger
      setStatus(function (prev) {
        switch (status) {
          case 'align':
            return 'motion';

          case 'motion':
            return 'stable';
        }

        return prev;
      });
      callback === null || callback === void 0 ? void 0 : callback();
    });
  } // Init status


  React.useEffect(function () {
    setStatus('measure');
  }, [visible]); // Go next status

  React.useEffect(function () {
    switch (status) {
      case 'measure':
        doMeasure();
        break;
    }

    if (status) {
      rafRef.current = wrapperRaf$1( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var index, nextStatus;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                index = StatusQueue.indexOf(status);
                nextStatus = StatusQueue[index + 1];

                if (nextStatus && index !== -1) {
                  setStatus(nextStatus);
                }

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      })));
    }
  }, [status]);
  React.useEffect(function () {
    return function () {
      cancelRaf();
    };
  }, []);
  return [status, goNextStatus];
});

var useStretchStyle = (function (stretch) {
  var _React$useState = React__namespace.useState({
    width: 0,
    height: 0
  }),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      targetSize = _React$useState2[0],
      setTargetSize = _React$useState2[1];

  function measureStretch(element) {
    var tgtWidth = element.offsetWidth,
        tgtHeight = element.offsetHeight;

    var _element$getBoundingC = element.getBoundingClientRect(),
        width = _element$getBoundingC.width,
        height = _element$getBoundingC.height; // Rect is more accurate than offset, use if near


    if (Math.abs(tgtWidth - width) < 1 && Math.abs(tgtHeight - height) < 1) {
      tgtWidth = width;
      tgtHeight = height;
    }

    setTargetSize({
      width: tgtWidth,
      height: tgtHeight
    });
  } // Merge stretch style


  var style = React__namespace.useMemo(function () {
    var sizeStyle = {};

    if (stretch) {
      var width = targetSize.width,
          height = targetSize.height; // Stretch with target

      if (stretch.indexOf('height') !== -1 && height) {
        sizeStyle.height = height;
      } else if (stretch.indexOf('minHeight') !== -1 && height) {
        sizeStyle.minHeight = height;
      }

      if (stretch.indexOf('width') !== -1 && width) {
        sizeStyle.width = width;
      } else if (stretch.indexOf('minWidth') !== -1 && width) {
        sizeStyle.minWidth = width;
      }
    }

    return sizeStyle;
  }, [stretch, targetSize]);
  return [style, measureStretch];
});

var PopupInner = /*#__PURE__*/React__namespace.forwardRef(function (props, ref) {
  var visible = props.visible,
      prefixCls = props.prefixCls,
      className = props.className,
      style = props.style,
      children = props.children,
      zIndex = props.zIndex,
      stretch = props.stretch,
      destroyPopupOnHide = props.destroyPopupOnHide,
      forceRender = props.forceRender,
      align = props.align,
      point = props.point,
      getRootDomNode = props.getRootDomNode,
      getClassNameFromAlign = props.getClassNameFromAlign,
      onAlign = props.onAlign,
      onMouseEnter = props.onMouseEnter,
      onMouseLeave = props.onMouseLeave,
      onMouseDown = props.onMouseDown,
      onTouchStart = props.onTouchStart,
      onClick = props.onClick;
  var alignRef = React.useRef();
  var elementRef = React.useRef();

  var _useState = React.useState(),
      _useState2 = _slicedToArray(_useState, 2),
      alignedClassName = _useState2[0],
      setAlignedClassName = _useState2[1]; // ======================= Measure ========================


  var _useStretchStyle = useStretchStyle(stretch),
      _useStretchStyle2 = _slicedToArray(_useStretchStyle, 2),
      stretchStyle = _useStretchStyle2[0],
      measureStretchStyle = _useStretchStyle2[1];

  function doMeasure() {
    if (stretch) {
      measureStretchStyle(getRootDomNode());
    }
  } // ======================== Status ========================


  var _useVisibleStatus = useVisibleStatus(visible, doMeasure),
      _useVisibleStatus2 = _slicedToArray(_useVisibleStatus, 2),
      status = _useVisibleStatus2[0],
      goNextStatus = _useVisibleStatus2[1]; // ======================== Aligns ========================

  /**
   * `alignedClassName` may modify `source` size,
   * which means one time align may not move to the correct position at once.
   *
   * We will reset `alignTimes` for each status switch to `alignPre`
   * and let `rc-align` to align for multiple times to ensure get final stable place.
   * Currently we mark `alignTimes < 2` repeat align, it will increase if user report for align issue.
   * 
   * Update:
   * In React 18. `rc-align` effect of align may faster than ref called trigger `forceAlign`.
   * We adjust this to `alignTimes < 2`.
   * We need refactor `rc-align` to support mark of `forceAlign` call if this still happen.
   */


  var _useState3 = React.useState(0),
      _useState4 = _slicedToArray(_useState3, 2),
      alignTimes = _useState4[0],
      setAlignTimes = _useState4[1];

  var prepareResolveRef = React.useRef();
  useLayoutEffect(function () {
    if (status === 'alignPre') {
      setAlignTimes(0);
    }
  }, [status]); // `target` on `rc-align` can accept as a function to get the bind element or a point.
  // ref: https://www.npmjs.com/package/rc-align

  function getAlignTarget() {
    if (point) {
      return point;
    }

    return getRootDomNode;
  }

  function forceAlign() {
    var _alignRef$current;

    (_alignRef$current = alignRef.current) === null || _alignRef$current === void 0 ? void 0 : _alignRef$current.forceAlign();
  }

  function onInternalAlign(popupDomNode, matchAlign) {
    var nextAlignedClassName = getClassNameFromAlign(matchAlign);

    if (alignedClassName !== nextAlignedClassName) {
      setAlignedClassName(nextAlignedClassName);
    } // We will retry multi times to make sure that the element has been align in the right position.


    setAlignTimes(function (val) {
      return val + 1;
    });

    if (status === 'align') {
      onAlign === null || onAlign === void 0 ? void 0 : onAlign(popupDomNode, matchAlign);
    }
  } // Delay to go to next status


  useLayoutEffect(function () {
    if (status === 'align') {
      // Repeat until not more align needed
      if (alignTimes < 3) {
        forceAlign();
      } else {
        goNextStatus(function () {
          var _prepareResolveRef$cu;

          (_prepareResolveRef$cu = prepareResolveRef.current) === null || _prepareResolveRef$cu === void 0 ? void 0 : _prepareResolveRef$cu.call(prepareResolveRef);
        });
      }
    }
  }, [alignTimes]); // ======================== Motion ========================

  var motion = _objectSpread2$1({}, getMotion(props));

  ['onAppearEnd', 'onEnterEnd', 'onLeaveEnd'].forEach(function (eventName) {
    var originHandler = motion[eventName];

    motion[eventName] = function (element, event) {
      goNextStatus();
      return originHandler === null || originHandler === void 0 ? void 0 : originHandler(element, event);
    };
  });

  function onShowPrepare() {
    return new Promise(function (resolve) {
      prepareResolveRef.current = resolve;
    });
  } // Go to stable directly when motion not provided


  React__namespace.useEffect(function () {
    if (!motion.motionName && status === 'motion') {
      goNextStatus();
    }
  }, [motion.motionName, status]); // ========================= Refs =========================

  React__namespace.useImperativeHandle(ref, function () {
    return {
      forceAlign: forceAlign,
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  }); // ======================== Render ========================

  var mergedStyle = _objectSpread2$1(_objectSpread2$1({}, stretchStyle), {}, {
    zIndex: zIndex,
    opacity: status === 'motion' || status === 'stable' || !visible ? undefined : 0,
    // Cannot interact with disappearing elements
    // https://github.com/ant-design/ant-design/issues/35051#issuecomment-1101340714
    pointerEvents: !visible && status !== 'stable' ? 'none' : undefined
  }, style); // Align status


  var alignDisabled = true;

  if (align !== null && align !== void 0 && align.points && (status === 'align' || status === 'stable')) {
    alignDisabled = false;
  }

  var childNode = children; // Wrapper when multiple children

  if (React__namespace.Children.count(children) > 1) {
    childNode = /*#__PURE__*/React__namespace.createElement("div", {
      className: "".concat(prefixCls, "-content")
    }, children);
  }

  return /*#__PURE__*/React__namespace.createElement(CSSMotion, _extends({
    visible: visible,
    ref: elementRef,
    leavedClassName: "".concat(prefixCls, "-hidden")
  }, motion, {
    onAppearPrepare: onShowPrepare,
    onEnterPrepare: onShowPrepare,
    removeOnLeave: destroyPopupOnHide,
    forceRender: forceRender
  }), function (_ref, motionRef) {
    var motionClassName = _ref.className,
        motionStyle = _ref.style;
    var mergedClassName = classNames(prefixCls, className, alignedClassName, motionClassName);
    return /*#__PURE__*/React__namespace.createElement(RcAlign, {
      target: getAlignTarget(),
      key: "popup",
      ref: alignRef,
      monitorWindowResize: true,
      disabled: alignDisabled,
      align: align,
      onAlign: onInternalAlign
    }, /*#__PURE__*/React__namespace.createElement("div", {
      ref: motionRef,
      className: mergedClassName,
      onMouseEnter: onMouseEnter,
      onMouseLeave: onMouseLeave,
      onMouseDownCapture: onMouseDown,
      onTouchStartCapture: onTouchStart,
      onClick: onClick,
      style: _objectSpread2$1(_objectSpread2$1({}, motionStyle), mergedStyle)
    }, childNode));
  });
});
PopupInner.displayName = 'PopupInner';

var MobilePopupInner = /*#__PURE__*/React__namespace.forwardRef(function (props, ref) {
  var prefixCls = props.prefixCls,
      visible = props.visible,
      zIndex = props.zIndex,
      children = props.children,
      _props$mobile = props.mobile;
  _props$mobile = _props$mobile === void 0 ? {} : _props$mobile;
  var popupClassName = _props$mobile.popupClassName,
      popupStyle = _props$mobile.popupStyle,
      _props$mobile$popupMo = _props$mobile.popupMotion,
      popupMotion = _props$mobile$popupMo === void 0 ? {} : _props$mobile$popupMo,
      popupRender = _props$mobile.popupRender,
      onClick = props.onClick;
  var elementRef = React__namespace.useRef(); // ========================= Refs =========================

  React__namespace.useImperativeHandle(ref, function () {
    return {
      forceAlign: function forceAlign() {},
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  }); // ======================== Render ========================

  var mergedStyle = _objectSpread2$1({
    zIndex: zIndex
  }, popupStyle);

  var childNode = children; // Wrapper when multiple children

  if (React__namespace.Children.count(children) > 1) {
    childNode = /*#__PURE__*/React__namespace.createElement("div", {
      className: "".concat(prefixCls, "-content")
    }, children);
  } // Mobile support additional render


  if (popupRender) {
    childNode = popupRender(childNode);
  }

  return /*#__PURE__*/React__namespace.createElement(CSSMotion, _extends({
    visible: visible,
    ref: elementRef,
    removeOnLeave: true
  }, popupMotion), function (_ref, motionRef) {
    var motionClassName = _ref.className,
        motionStyle = _ref.style;
    var mergedClassName = classNames(prefixCls, popupClassName, motionClassName);
    return /*#__PURE__*/React__namespace.createElement("div", {
      ref: motionRef,
      className: mergedClassName,
      onClick: onClick,
      style: _objectSpread2$1(_objectSpread2$1({}, motionStyle), mergedStyle)
    }, childNode);
  });
});
MobilePopupInner.displayName = 'MobilePopupInner';

var _excluded$2 = ["visible", "mobile"];
var Popup$1 = /*#__PURE__*/React__namespace.forwardRef(function (_ref, ref) {
  var visible = _ref.visible,
      mobile = _ref.mobile,
      props = _objectWithoutProperties(_ref, _excluded$2);

  var _useState = React.useState(visible),
      _useState2 = _slicedToArray(_useState, 2),
      innerVisible = _useState2[0],
      serInnerVisible = _useState2[1];

  var _useState3 = React.useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      inMobile = _useState4[0],
      setInMobile = _useState4[1];

  var cloneProps = _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    visible: innerVisible
  }); // We check mobile in visible changed here.
  // And this also delay set `innerVisible` to avoid popup component render flash


  React.useEffect(function () {
    serInnerVisible(visible);

    if (visible && mobile) {
      setInMobile(isMobile());
    }
  }, [visible, mobile]);
  var popupNode = inMobile ? /*#__PURE__*/React__namespace.createElement(MobilePopupInner, _extends({}, cloneProps, {
    mobile: mobile,
    ref: ref
  })) : /*#__PURE__*/React__namespace.createElement(PopupInner, _extends({}, cloneProps, {
    ref: ref
  })); // We can use fragment directly but this may failed some selector usage. Keep as origin logic

  return /*#__PURE__*/React__namespace.createElement("div", null, /*#__PURE__*/React__namespace.createElement(Mask, cloneProps), popupNode);
});
Popup$1.displayName = 'Popup';

var TriggerContext = /*#__PURE__*/React__namespace.createContext(null);

function noop() {}

function returnEmptyString() {
  return '';
}

function returnDocument(element) {
  if (element) {
    return element.ownerDocument;
  }

  return window.document;
}

var ALL_HANDLERS = ['onClick', 'onMouseDown', 'onTouchStart', 'onMouseEnter', 'onMouseLeave', 'onFocus', 'onBlur', 'onContextMenu'];

/**
 * Internal usage. Do not use in your code since this will be removed.
 */
function generateTrigger(PortalComponent) {
  var Trigger = /*#__PURE__*/function (_React$Component) {
    _inherits(Trigger, _React$Component);

    var _super = _createSuper(Trigger);

    // ensure `getContainer` will be called only once
    function Trigger(props) {
      var _this;

      _classCallCheck(this, Trigger);

      _this = _super.call(this, props);

      _defineProperty$1(_assertThisInitialized(_this), "popupRef", /*#__PURE__*/React__namespace.createRef());

      _defineProperty$1(_assertThisInitialized(_this), "triggerRef", /*#__PURE__*/React__namespace.createRef());

      _defineProperty$1(_assertThisInitialized(_this), "portalContainer", void 0);

      _defineProperty$1(_assertThisInitialized(_this), "attachId", void 0);

      _defineProperty$1(_assertThisInitialized(_this), "clickOutsideHandler", void 0);

      _defineProperty$1(_assertThisInitialized(_this), "touchOutsideHandler", void 0);

      _defineProperty$1(_assertThisInitialized(_this), "contextMenuOutsideHandler1", void 0);

      _defineProperty$1(_assertThisInitialized(_this), "contextMenuOutsideHandler2", void 0);

      _defineProperty$1(_assertThisInitialized(_this), "mouseDownTimeout", void 0);

      _defineProperty$1(_assertThisInitialized(_this), "focusTime", void 0);

      _defineProperty$1(_assertThisInitialized(_this), "preClickTime", void 0);

      _defineProperty$1(_assertThisInitialized(_this), "preTouchTime", void 0);

      _defineProperty$1(_assertThisInitialized(_this), "delayTimer", void 0);

      _defineProperty$1(_assertThisInitialized(_this), "hasPopupMouseDown", void 0);

      _defineProperty$1(_assertThisInitialized(_this), "onMouseEnter", function (e) {
        var mouseEnterDelay = _this.props.mouseEnterDelay;

        _this.fireEvents('onMouseEnter', e);

        _this.delaySetPopupVisible(true, mouseEnterDelay, mouseEnterDelay ? null : e);
      });

      _defineProperty$1(_assertThisInitialized(_this), "onMouseMove", function (e) {
        _this.fireEvents('onMouseMove', e);

        _this.setPoint(e);
      });

      _defineProperty$1(_assertThisInitialized(_this), "onMouseLeave", function (e) {
        _this.fireEvents('onMouseLeave', e);

        _this.delaySetPopupVisible(false, _this.props.mouseLeaveDelay);
      });

      _defineProperty$1(_assertThisInitialized(_this), "onPopupMouseEnter", function () {
        _this.clearDelayTimer();
      });

      _defineProperty$1(_assertThisInitialized(_this), "onPopupMouseLeave", function (e) {
        var _this$popupRef$curren;

        // https://github.com/react-component/trigger/pull/13
        // react bug?
        if (e.relatedTarget && !e.relatedTarget.setTimeout && contains((_this$popupRef$curren = _this.popupRef.current) === null || _this$popupRef$curren === void 0 ? void 0 : _this$popupRef$curren.getElement(), e.relatedTarget)) {
          return;
        }

        _this.delaySetPopupVisible(false, _this.props.mouseLeaveDelay);
      });

      _defineProperty$1(_assertThisInitialized(_this), "onFocus", function (e) {
        _this.fireEvents('onFocus', e); // incase focusin and focusout


        _this.clearDelayTimer();

        if (_this.isFocusToShow()) {
          _this.focusTime = Date.now();

          _this.delaySetPopupVisible(true, _this.props.focusDelay);
        }
      });

      _defineProperty$1(_assertThisInitialized(_this), "onMouseDown", function (e) {
        _this.fireEvents('onMouseDown', e);

        _this.preClickTime = Date.now();
      });

      _defineProperty$1(_assertThisInitialized(_this), "onTouchStart", function (e) {
        _this.fireEvents('onTouchStart', e);

        _this.preTouchTime = Date.now();
      });

      _defineProperty$1(_assertThisInitialized(_this), "onBlur", function (e) {
        _this.fireEvents('onBlur', e);

        _this.clearDelayTimer();

        if (_this.isBlurToHide()) {
          _this.delaySetPopupVisible(false, _this.props.blurDelay);
        }
      });

      _defineProperty$1(_assertThisInitialized(_this), "onContextMenu", function (e) {
        e.preventDefault();

        _this.fireEvents('onContextMenu', e);

        _this.setPopupVisible(true, e);
      });

      _defineProperty$1(_assertThisInitialized(_this), "onContextMenuClose", function () {
        if (_this.isContextMenuToShow()) {
          _this.close();
        }
      });

      _defineProperty$1(_assertThisInitialized(_this), "onClick", function (event) {
        _this.fireEvents('onClick', event); // focus will trigger click


        if (_this.focusTime) {
          var preTime;

          if (_this.preClickTime && _this.preTouchTime) {
            preTime = Math.min(_this.preClickTime, _this.preTouchTime);
          } else if (_this.preClickTime) {
            preTime = _this.preClickTime;
          } else if (_this.preTouchTime) {
            preTime = _this.preTouchTime;
          }

          if (Math.abs(preTime - _this.focusTime) < 20) {
            return;
          }

          _this.focusTime = 0;
        }

        _this.preClickTime = 0;
        _this.preTouchTime = 0; // Only prevent default when all the action is click.
        // https://github.com/ant-design/ant-design/issues/17043
        // https://github.com/ant-design/ant-design/issues/17291

        if (_this.isClickToShow() && (_this.isClickToHide() || _this.isBlurToHide()) && event && event.preventDefault) {
          event.preventDefault();
        }

        var nextVisible = !_this.state.popupVisible;

        if (_this.isClickToHide() && !nextVisible || nextVisible && _this.isClickToShow()) {
          _this.setPopupVisible(!_this.state.popupVisible, event);
        }
      });

      _defineProperty$1(_assertThisInitialized(_this), "onPopupMouseDown", function () {
        _this.hasPopupMouseDown = true;
        clearTimeout(_this.mouseDownTimeout);
        _this.mouseDownTimeout = window.setTimeout(function () {
          _this.hasPopupMouseDown = false;
        }, 0);

        if (_this.context) {
          var _this$context;

          (_this$context = _this.context).onPopupMouseDown.apply(_this$context, arguments);
        }
      });

      _defineProperty$1(_assertThisInitialized(_this), "onDocumentClick", function (event) {
        if (_this.props.mask && !_this.props.maskClosable) {
          return;
        }

        var target = event.target;

        var root = _this.getRootDomNode();

        var popupNode = _this.getPopupDomNode();

        if ( // mousedown on the target should also close popup when action is contextMenu.
        // https://github.com/ant-design/ant-design/issues/29853
        (!contains(root, target) || _this.isContextMenuOnly()) && !contains(popupNode, target) && !_this.hasPopupMouseDown) {
          _this.close();
        }
      });

      _defineProperty$1(_assertThisInitialized(_this), "getRootDomNode", function () {
        var getTriggerDOMNode = _this.props.getTriggerDOMNode;

        if (getTriggerDOMNode) {
          return getTriggerDOMNode(_this.triggerRef.current);
        }

        try {
          var domNode = findDOMNode(_this.triggerRef.current);

          if (domNode) {
            return domNode;
          }
        } catch (err) {// Do nothing
        }

        return ReactDOM.findDOMNode(_assertThisInitialized(_this));
      });

      _defineProperty$1(_assertThisInitialized(_this), "getPopupClassNameFromAlign", function (align) {
        var className = [];
        var _this$props = _this.props,
            popupPlacement = _this$props.popupPlacement,
            builtinPlacements = _this$props.builtinPlacements,
            prefixCls = _this$props.prefixCls,
            alignPoint = _this$props.alignPoint,
            getPopupClassNameFromAlign = _this$props.getPopupClassNameFromAlign;

        if (popupPlacement && builtinPlacements) {
          className.push(getAlignPopupClassName(builtinPlacements, prefixCls, align, alignPoint));
        }

        if (getPopupClassNameFromAlign) {
          className.push(getPopupClassNameFromAlign(align));
        }

        return className.join(' ');
      });

      _defineProperty$1(_assertThisInitialized(_this), "getComponent", function () {
        var _this$props2 = _this.props,
            prefixCls = _this$props2.prefixCls,
            destroyPopupOnHide = _this$props2.destroyPopupOnHide,
            popupClassName = _this$props2.popupClassName,
            onPopupAlign = _this$props2.onPopupAlign,
            popupMotion = _this$props2.popupMotion,
            popupAnimation = _this$props2.popupAnimation,
            popupTransitionName = _this$props2.popupTransitionName,
            popupStyle = _this$props2.popupStyle,
            mask = _this$props2.mask,
            maskAnimation = _this$props2.maskAnimation,
            maskTransitionName = _this$props2.maskTransitionName,
            maskMotion = _this$props2.maskMotion,
            zIndex = _this$props2.zIndex,
            popup = _this$props2.popup,
            stretch = _this$props2.stretch,
            alignPoint = _this$props2.alignPoint,
            mobile = _this$props2.mobile,
            forceRender = _this$props2.forceRender,
            onPopupClick = _this$props2.onPopupClick;
        var _this$state = _this.state,
            popupVisible = _this$state.popupVisible,
            point = _this$state.point;

        var align = _this.getPopupAlign();

        var mouseProps = {};

        if (_this.isMouseEnterToShow()) {
          mouseProps.onMouseEnter = _this.onPopupMouseEnter;
        }

        if (_this.isMouseLeaveToHide()) {
          mouseProps.onMouseLeave = _this.onPopupMouseLeave;
        }

        mouseProps.onMouseDown = _this.onPopupMouseDown;
        mouseProps.onTouchStart = _this.onPopupMouseDown;
        return /*#__PURE__*/React__namespace.createElement(Popup$1, _extends({
          prefixCls: prefixCls,
          destroyPopupOnHide: destroyPopupOnHide,
          visible: popupVisible,
          point: alignPoint && point,
          className: popupClassName,
          align: align,
          onAlign: onPopupAlign,
          animation: popupAnimation,
          getClassNameFromAlign: _this.getPopupClassNameFromAlign
        }, mouseProps, {
          stretch: stretch,
          getRootDomNode: _this.getRootDomNode,
          style: popupStyle,
          mask: mask,
          zIndex: zIndex,
          transitionName: popupTransitionName,
          maskAnimation: maskAnimation,
          maskTransitionName: maskTransitionName,
          maskMotion: maskMotion,
          ref: _this.popupRef,
          motion: popupMotion,
          mobile: mobile,
          forceRender: forceRender,
          onClick: onPopupClick
        }), typeof popup === 'function' ? popup() : popup);
      });

      _defineProperty$1(_assertThisInitialized(_this), "attachParent", function (popupContainer) {
        wrapperRaf$1.cancel(_this.attachId);
        var _this$props3 = _this.props,
            getPopupContainer = _this$props3.getPopupContainer,
            getDocument = _this$props3.getDocument;

        var domNode = _this.getRootDomNode();

        var mountNode;

        if (!getPopupContainer) {
          mountNode = getDocument(_this.getRootDomNode()).body;
        } else if (domNode || getPopupContainer.length === 0) {
          // Compatible for legacy getPopupContainer with domNode argument.
          // If no need `domNode` argument, will call directly.
          // https://codesandbox.io/s/eloquent-mclean-ss93m?file=/src/App.js
          mountNode = getPopupContainer(domNode);
        }

        if (mountNode) {
          mountNode.appendChild(popupContainer);
        } else {
          // Retry after frame render in case parent not ready
          _this.attachId = wrapperRaf$1(function () {
            _this.attachParent(popupContainer);
          });
        }
      });

      _defineProperty$1(_assertThisInitialized(_this), "getContainer", function () {
        if (!_this.portalContainer) {
          // In React.StrictMode component will call render multiple time in first mount.
          // When you want to refactor with FC, useRef will also init multiple time and
          // point to different useRef instance which will create multiple element
          // (This multiple render will not trigger effect so you can not clean up this
          // in effect). But this is safe with class component since it always point to same class instance.
          var getDocument = _this.props.getDocument;
          var popupContainer = getDocument(_this.getRootDomNode()).createElement('div'); // Make sure default popup container will never cause scrollbar appearing
          // https://github.com/react-component/trigger/issues/41

          popupContainer.style.position = 'absolute';
          popupContainer.style.top = '0';
          popupContainer.style.left = '0';
          popupContainer.style.width = '100%';
          _this.portalContainer = popupContainer;
        }

        _this.attachParent(_this.portalContainer);

        return _this.portalContainer;
      });

      _defineProperty$1(_assertThisInitialized(_this), "setPoint", function (point) {
        var alignPoint = _this.props.alignPoint;
        if (!alignPoint || !point) return;

        _this.setState({
          point: {
            pageX: point.pageX,
            pageY: point.pageY
          }
        });
      });

      _defineProperty$1(_assertThisInitialized(_this), "handlePortalUpdate", function () {
        if (_this.state.prevPopupVisible !== _this.state.popupVisible) {
          _this.props.afterPopupVisibleChange(_this.state.popupVisible);
        }
      });

      _defineProperty$1(_assertThisInitialized(_this), "triggerContextValue", {
        onPopupMouseDown: _this.onPopupMouseDown
      });

      var _popupVisible;

      if ('popupVisible' in props) {
        _popupVisible = !!props.popupVisible;
      } else {
        _popupVisible = !!props.defaultPopupVisible;
      }

      _this.state = {
        prevPopupVisible: _popupVisible,
        popupVisible: _popupVisible
      };
      ALL_HANDLERS.forEach(function (h) {
        _this["fire".concat(h)] = function (e) {
          _this.fireEvents(h, e);
        };
      });
      return _this;
    }

    _createClass(Trigger, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.componentDidUpdate();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        var props = this.props;
        var state = this.state; // We must listen to `mousedown` or `touchstart`, edge case:
        // https://github.com/ant-design/ant-design/issues/5804
        // https://github.com/react-component/calendar/issues/250
        // https://github.com/react-component/trigger/issues/50

        if (state.popupVisible) {
          var currentDocument;

          if (!this.clickOutsideHandler && (this.isClickToHide() || this.isContextMenuToShow())) {
            currentDocument = props.getDocument(this.getRootDomNode());
            this.clickOutsideHandler = addEventListenerWrap(currentDocument, 'mousedown', this.onDocumentClick);
          } // always hide on mobile


          if (!this.touchOutsideHandler) {
            currentDocument = currentDocument || props.getDocument(this.getRootDomNode());
            this.touchOutsideHandler = addEventListenerWrap(currentDocument, 'touchstart', this.onDocumentClick);
          } // close popup when trigger type contains 'onContextMenu' and document is scrolling.


          if (!this.contextMenuOutsideHandler1 && this.isContextMenuToShow()) {
            currentDocument = currentDocument || props.getDocument(this.getRootDomNode());
            this.contextMenuOutsideHandler1 = addEventListenerWrap(currentDocument, 'scroll', this.onContextMenuClose);
          } // close popup when trigger type contains 'onContextMenu' and window is blur.


          if (!this.contextMenuOutsideHandler2 && this.isContextMenuToShow()) {
            this.contextMenuOutsideHandler2 = addEventListenerWrap(window, 'blur', this.onContextMenuClose);
          }

          return;
        }

        this.clearOutsideHandler();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.clearDelayTimer();
        this.clearOutsideHandler();
        clearTimeout(this.mouseDownTimeout);
        wrapperRaf$1.cancel(this.attachId);
      }
    }, {
      key: "getPopupDomNode",
      value: function getPopupDomNode() {
        var _this$popupRef$curren2;

        // for test
        return ((_this$popupRef$curren2 = this.popupRef.current) === null || _this$popupRef$curren2 === void 0 ? void 0 : _this$popupRef$curren2.getElement()) || null;
      }
    }, {
      key: "getPopupAlign",
      value: function getPopupAlign() {
        var props = this.props;
        var popupPlacement = props.popupPlacement,
            popupAlign = props.popupAlign,
            builtinPlacements = props.builtinPlacements;

        if (popupPlacement && builtinPlacements) {
          return getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign);
        }

        return popupAlign;
      }
    }, {
      key: "setPopupVisible",
      value:
      /**
       * @param popupVisible    Show or not the popup element
       * @param event           SyntheticEvent, used for `pointAlign`
       */
      function setPopupVisible(popupVisible, event) {
        var alignPoint = this.props.alignPoint;
        var prevPopupVisible = this.state.popupVisible;
        this.clearDelayTimer();

        if (prevPopupVisible !== popupVisible) {
          if (!('popupVisible' in this.props)) {
            this.setState({
              popupVisible: popupVisible,
              prevPopupVisible: prevPopupVisible
            });
          }

          this.props.onPopupVisibleChange(popupVisible);
        } // Always record the point position since mouseEnterDelay will delay the show


        if (alignPoint && event && popupVisible) {
          this.setPoint(event);
        }
      }
    }, {
      key: "delaySetPopupVisible",
      value: function delaySetPopupVisible(visible, delayS, event) {
        var _this2 = this;

        var delay = delayS * 1000;
        this.clearDelayTimer();

        if (delay) {
          var point = event ? {
            pageX: event.pageX,
            pageY: event.pageY
          } : null;
          this.delayTimer = window.setTimeout(function () {
            _this2.setPopupVisible(visible, point);

            _this2.clearDelayTimer();
          }, delay);
        } else {
          this.setPopupVisible(visible, event);
        }
      }
    }, {
      key: "clearDelayTimer",
      value: function clearDelayTimer() {
        if (this.delayTimer) {
          clearTimeout(this.delayTimer);
          this.delayTimer = null;
        }
      }
    }, {
      key: "clearOutsideHandler",
      value: function clearOutsideHandler() {
        if (this.clickOutsideHandler) {
          this.clickOutsideHandler.remove();
          this.clickOutsideHandler = null;
        }

        if (this.contextMenuOutsideHandler1) {
          this.contextMenuOutsideHandler1.remove();
          this.contextMenuOutsideHandler1 = null;
        }

        if (this.contextMenuOutsideHandler2) {
          this.contextMenuOutsideHandler2.remove();
          this.contextMenuOutsideHandler2 = null;
        }

        if (this.touchOutsideHandler) {
          this.touchOutsideHandler.remove();
          this.touchOutsideHandler = null;
        }
      }
    }, {
      key: "createTwoChains",
      value: function createTwoChains(event) {
        var childPros = this.props.children.props;
        var props = this.props;

        if (childPros[event] && props[event]) {
          return this["fire".concat(event)];
        }

        return childPros[event] || props[event];
      }
    }, {
      key: "isClickToShow",
      value: function isClickToShow() {
        var _this$props4 = this.props,
            action = _this$props4.action,
            showAction = _this$props4.showAction;
        return action.indexOf('click') !== -1 || showAction.indexOf('click') !== -1;
      }
    }, {
      key: "isContextMenuOnly",
      value: function isContextMenuOnly() {
        var action = this.props.action;
        return action === 'contextMenu' || action.length === 1 && action[0] === 'contextMenu';
      }
    }, {
      key: "isContextMenuToShow",
      value: function isContextMenuToShow() {
        var _this$props5 = this.props,
            action = _this$props5.action,
            showAction = _this$props5.showAction;
        return action.indexOf('contextMenu') !== -1 || showAction.indexOf('contextMenu') !== -1;
      }
    }, {
      key: "isClickToHide",
      value: function isClickToHide() {
        var _this$props6 = this.props,
            action = _this$props6.action,
            hideAction = _this$props6.hideAction;
        return action.indexOf('click') !== -1 || hideAction.indexOf('click') !== -1;
      }
    }, {
      key: "isMouseEnterToShow",
      value: function isMouseEnterToShow() {
        var _this$props7 = this.props,
            action = _this$props7.action,
            showAction = _this$props7.showAction;
        return action.indexOf('hover') !== -1 || showAction.indexOf('mouseEnter') !== -1;
      }
    }, {
      key: "isMouseLeaveToHide",
      value: function isMouseLeaveToHide() {
        var _this$props8 = this.props,
            action = _this$props8.action,
            hideAction = _this$props8.hideAction;
        return action.indexOf('hover') !== -1 || hideAction.indexOf('mouseLeave') !== -1;
      }
    }, {
      key: "isFocusToShow",
      value: function isFocusToShow() {
        var _this$props9 = this.props,
            action = _this$props9.action,
            showAction = _this$props9.showAction;
        return action.indexOf('focus') !== -1 || showAction.indexOf('focus') !== -1;
      }
    }, {
      key: "isBlurToHide",
      value: function isBlurToHide() {
        var _this$props10 = this.props,
            action = _this$props10.action,
            hideAction = _this$props10.hideAction;
        return action.indexOf('focus') !== -1 || hideAction.indexOf('blur') !== -1;
      }
    }, {
      key: "forcePopupAlign",
      value: function forcePopupAlign() {
        if (this.state.popupVisible) {
          var _this$popupRef$curren3;

          (_this$popupRef$curren3 = this.popupRef.current) === null || _this$popupRef$curren3 === void 0 ? void 0 : _this$popupRef$curren3.forceAlign();
        }
      }
    }, {
      key: "fireEvents",
      value: function fireEvents(type, e) {
        var childCallback = this.props.children.props[type];

        if (childCallback) {
          childCallback(e);
        }

        var callback = this.props[type];

        if (callback) {
          callback(e);
        }
      }
    }, {
      key: "close",
      value: function close() {
        this.setPopupVisible(false);
      }
    }, {
      key: "render",
      value: function render() {
        var popupVisible = this.state.popupVisible;
        var _this$props11 = this.props,
            children = _this$props11.children,
            forceRender = _this$props11.forceRender,
            alignPoint = _this$props11.alignPoint,
            className = _this$props11.className,
            autoDestroy = _this$props11.autoDestroy;
        var child = React__namespace.Children.only(children);
        var newChildProps = {
          key: 'trigger'
        }; // ============================== Visible Handlers ==============================
        // >>> ContextMenu

        if (this.isContextMenuToShow()) {
          newChildProps.onContextMenu = this.onContextMenu;
        } else {
          newChildProps.onContextMenu = this.createTwoChains('onContextMenu');
        } // >>> Click


        if (this.isClickToHide() || this.isClickToShow()) {
          newChildProps.onClick = this.onClick;
          newChildProps.onMouseDown = this.onMouseDown;
          newChildProps.onTouchStart = this.onTouchStart;
        } else {
          newChildProps.onClick = this.createTwoChains('onClick');
          newChildProps.onMouseDown = this.createTwoChains('onMouseDown');
          newChildProps.onTouchStart = this.createTwoChains('onTouchStart');
        } // >>> Hover(enter)


        if (this.isMouseEnterToShow()) {
          newChildProps.onMouseEnter = this.onMouseEnter; // Point align

          if (alignPoint) {
            newChildProps.onMouseMove = this.onMouseMove;
          }
        } else {
          newChildProps.onMouseEnter = this.createTwoChains('onMouseEnter');
        } // >>> Hover(leave)


        if (this.isMouseLeaveToHide()) {
          newChildProps.onMouseLeave = this.onMouseLeave;
        } else {
          newChildProps.onMouseLeave = this.createTwoChains('onMouseLeave');
        } // >>> Focus


        if (this.isFocusToShow() || this.isBlurToHide()) {
          newChildProps.onFocus = this.onFocus;
          newChildProps.onBlur = this.onBlur;
        } else {
          newChildProps.onFocus = this.createTwoChains('onFocus');
          newChildProps.onBlur = this.createTwoChains('onBlur');
        } // =================================== Render ===================================


        var childrenClassName = classNames(child && child.props && child.props.className, className);

        if (childrenClassName) {
          newChildProps.className = childrenClassName;
        }

        var cloneProps = _objectSpread2$1({}, newChildProps);

        if (supportRef(child)) {
          cloneProps.ref = composeRef(this.triggerRef, child.ref);
        }

        var trigger = /*#__PURE__*/React__namespace.cloneElement(child, cloneProps);
        var portal; // prevent unmounting after it's rendered

        if (popupVisible || this.popupRef.current || forceRender) {
          portal = /*#__PURE__*/React__namespace.createElement(PortalComponent, {
            key: "portal",
            getContainer: this.getContainer,
            didUpdate: this.handlePortalUpdate
          }, this.getComponent());
        }

        if (!popupVisible && autoDestroy) {
          portal = null;
        }

        return /*#__PURE__*/React__namespace.createElement(TriggerContext.Provider, {
          value: this.triggerContextValue
        }, trigger, portal);
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref, prevState) {
        var popupVisible = _ref.popupVisible;
        var newState = {};

        if (popupVisible !== undefined && prevState.popupVisible !== popupVisible) {
          newState.popupVisible = popupVisible;
          newState.prevPopupVisible = prevState.popupVisible;
        }

        return newState;
      }
    }]);

    return Trigger;
  }(React__namespace.Component);

  _defineProperty$1(Trigger, "contextType", TriggerContext);

  _defineProperty$1(Trigger, "defaultProps", {
    prefixCls: 'rc-trigger-popup',
    getPopupClassNameFromAlign: returnEmptyString,
    getDocument: returnDocument,
    onPopupVisibleChange: noop,
    afterPopupVisibleChange: noop,
    onPopupAlign: noop,
    popupClassName: '',
    mouseEnterDelay: 0,
    mouseLeaveDelay: 0.1,
    focusDelay: 0,
    blurDelay: 0.15,
    popupStyle: {},
    destroyPopupOnHide: false,
    popupAlign: {},
    defaultPopupVisible: false,
    mask: false,
    maskClosable: true,
    action: [],
    showAction: [],
    hideAction: [],
    autoDestroy: false
  });

  return Trigger;
}
var Trigger = generateTrigger(Portal);

// https://stackoverflow.com/questions/46176165/ways-to-get-string-literal-type-of-array-values-without-enum-overhead
var tuple = function tuple() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return args;
};

// ================== Collapse Motion ==================
var getCollapsedHeight = function getCollapsedHeight() {
  return {
    height: 0,
    opacity: 0
  };
};
var getRealHeight = function getRealHeight(node) {
  var scrollHeight = node.scrollHeight;
  return {
    height: scrollHeight,
    opacity: 1
  };
};
var getCurrentHeight = function getCurrentHeight(node) {
  return {
    height: node ? node.offsetHeight : 0
  };
};
var skipOpacityTransition = function skipOpacityTransition(_, event) {
  return (event === null || event === void 0 ? void 0 : event.deadline) === true || event.propertyName === 'height';
};
var collapseMotion = {
  motionName: 'ant-motion-collapse',
  onAppearStart: getCollapsedHeight,
  onEnterStart: getCollapsedHeight,
  onAppearActive: getRealHeight,
  onEnterActive: getRealHeight,
  onLeaveStart: getCurrentHeight,
  onLeaveActive: getCollapsedHeight,
  onAppearEnd: skipOpacityTransition,
  onEnterEnd: skipOpacityTransition,
  onLeaveEnd: skipOpacityTransition,
  motionDeadline: 500
};
tuple('bottomLeft', 'bottomRight', 'topLeft', 'topRight');
var getTransitionName = function getTransitionName(rootPrefixCls, motion, transitionName) {
  if (transitionName !== undefined) {
    return transitionName;
  }
  return "".concat(rootPrefixCls, "-").concat(motion);
};
var collapseMotion$1 = collapseMotion;

// This icon file is generated automatically.
var CheckOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" } }] }, "name": "check", "theme": "outlined" };
var CheckOutlinedSvg = CheckOutlined$2;

var CheckOutlined = function CheckOutlined(props, ref) {
  return /*#__PURE__*/React__namespace.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref: ref,
    icon: CheckOutlinedSvg
  }));
};
CheckOutlined.displayName = 'CheckOutlined';
var CheckOutlined$1 = /*#__PURE__*/React__namespace.forwardRef(CheckOutlined);

undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var SpaceCompactItemContext = /*#__PURE__*/React__namespace.createContext(null);
var useCompactItemContext = function useCompactItemContext(prefixCls, direction) {
  var compactItemContext = React__namespace.useContext(SpaceCompactItemContext);
  var compactItemClassnames = React__namespace.useMemo(function () {
    var _classNames;
    if (!compactItemContext) return '';
    var compactDirection = compactItemContext.compactDirection,
      isFirstItem = compactItemContext.isFirstItem,
      isLastItem = compactItemContext.isLastItem;
    var separator = compactDirection === 'vertical' ? '-vertical-' : '-';
    return classNames((_classNames = {}, _defineProperty$1(_classNames, "".concat(prefixCls, "-compact").concat(separator, "item"), true), _defineProperty$1(_classNames, "".concat(prefixCls, "-compact").concat(separator, "first-item"), isFirstItem), _defineProperty$1(_classNames, "".concat(prefixCls, "-compact").concat(separator, "last-item"), isLastItem), _defineProperty$1(_classNames, "".concat(prefixCls, "-compact").concat(separator, "item-rtl"), direction === 'rtl'), _classNames));
  }, [prefixCls, direction, compactItemContext]);
  return {
    compactSize: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactSize,
    compactDirection: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactDirection,
    compactItemClassnames: compactItemClassnames
  };
};

function useForceUpdate() {
  var _React$useReducer = React__namespace.useReducer(function (x) {
      return x + 1;
    }, 0),
    _React$useReducer2 = _slicedToArray(_React$useReducer, 2),
    forceUpdate = _React$useReducer2[1];
  return forceUpdate;
}

var autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};
var targetOffset$1 = [0, 0];
var placements = {
  left: {
    points: ['cr', 'cl'],
    overflow: autoAdjustOverflow,
    offset: [-4, 0],
    targetOffset: targetOffset$1
  },
  right: {
    points: ['cl', 'cr'],
    overflow: autoAdjustOverflow,
    offset: [4, 0],
    targetOffset: targetOffset$1
  },
  top: {
    points: ['bc', 'tc'],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset$1
  },
  bottom: {
    points: ['tc', 'bc'],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset$1
  },
  topLeft: {
    points: ['bl', 'tl'],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset$1
  },
  leftTop: {
    points: ['tr', 'tl'],
    overflow: autoAdjustOverflow,
    offset: [-4, 0],
    targetOffset: targetOffset$1
  },
  topRight: {
    points: ['br', 'tr'],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset$1
  },
  rightTop: {
    points: ['tl', 'tr'],
    overflow: autoAdjustOverflow,
    offset: [4, 0],
    targetOffset: targetOffset$1
  },
  bottomRight: {
    points: ['tr', 'br'],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset$1
  },
  rightBottom: {
    points: ['bl', 'br'],
    overflow: autoAdjustOverflow,
    offset: [4, 0],
    targetOffset: targetOffset$1
  },
  bottomLeft: {
    points: ['tl', 'bl'],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset$1
  },
  leftBottom: {
    points: ['br', 'bl'],
    overflow: autoAdjustOverflow,
    offset: [-4, 0],
    targetOffset: targetOffset$1
  }
};

function Popup(props) {
  var showArrow = props.showArrow,
      arrowContent = props.arrowContent,
      children = props.children,
      prefixCls = props.prefixCls,
      id = props.id,
      overlayInnerStyle = props.overlayInnerStyle,
      className = props.className,
      style = props.style;
  return /*#__PURE__*/React__namespace.createElement("div", {
    className: classNames("".concat(prefixCls, "-content"), className),
    style: style
  }, showArrow !== false && /*#__PURE__*/React__namespace.createElement("div", {
    className: "".concat(prefixCls, "-arrow"),
    key: "arrow"
  }, arrowContent), /*#__PURE__*/React__namespace.createElement("div", {
    className: "".concat(prefixCls, "-inner"),
    id: id,
    role: "tooltip",
    style: overlayInnerStyle
  }, typeof children === 'function' ? children() : children));
}

var Tooltip$2 = function Tooltip(props, ref) {
  var overlayClassName = props.overlayClassName,
      _props$trigger = props.trigger,
      trigger = _props$trigger === void 0 ? ['hover'] : _props$trigger,
      _props$mouseEnterDela = props.mouseEnterDelay,
      mouseEnterDelay = _props$mouseEnterDela === void 0 ? 0 : _props$mouseEnterDela,
      _props$mouseLeaveDela = props.mouseLeaveDelay,
      mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela,
      overlayStyle = props.overlayStyle,
      _props$prefixCls = props.prefixCls,
      prefixCls = _props$prefixCls === void 0 ? 'rc-tooltip' : _props$prefixCls,
      children = props.children,
      onVisibleChange = props.onVisibleChange,
      afterVisibleChange = props.afterVisibleChange,
      transitionName = props.transitionName,
      animation = props.animation,
      motion = props.motion,
      _props$placement = props.placement,
      placement = _props$placement === void 0 ? 'right' : _props$placement,
      _props$align = props.align,
      align = _props$align === void 0 ? {} : _props$align,
      _props$destroyTooltip = props.destroyTooltipOnHide,
      destroyTooltipOnHide = _props$destroyTooltip === void 0 ? false : _props$destroyTooltip,
      defaultVisible = props.defaultVisible,
      getTooltipContainer = props.getTooltipContainer,
      overlayInnerStyle = props.overlayInnerStyle,
      arrowContent = props.arrowContent,
      overlay = props.overlay,
      id = props.id,
      showArrow = props.showArrow,
      restProps = _objectWithoutProperties(props, ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "children", "onVisibleChange", "afterVisibleChange", "transitionName", "animation", "motion", "placement", "align", "destroyTooltipOnHide", "defaultVisible", "getTooltipContainer", "overlayInnerStyle", "arrowContent", "overlay", "id", "showArrow"]);

  var domRef = React.useRef(null);
  React.useImperativeHandle(ref, function () {
    return domRef.current;
  });

  var extraProps = _objectSpread2$1({}, restProps);

  if ('visible' in props) {
    extraProps.popupVisible = props.visible;
  }

  var getPopupElement = function getPopupElement() {
    return /*#__PURE__*/React__namespace.createElement(Popup, {
      showArrow: showArrow,
      arrowContent: arrowContent,
      key: "content",
      prefixCls: prefixCls,
      id: id,
      overlayInnerStyle: overlayInnerStyle
    }, overlay);
  };

  var destroyTooltip = false;
  var autoDestroy = false;

  if (typeof destroyTooltipOnHide === 'boolean') {
    destroyTooltip = destroyTooltipOnHide;
  } else if (destroyTooltipOnHide && _typeof$1(destroyTooltipOnHide) === 'object') {
    var keepParent = destroyTooltipOnHide.keepParent;
    destroyTooltip = keepParent === true;
    autoDestroy = keepParent === false;
  }

  return /*#__PURE__*/React__namespace.createElement(Trigger, _extends({
    popupClassName: overlayClassName,
    prefixCls: prefixCls,
    popup: getPopupElement,
    action: trigger,
    builtinPlacements: placements,
    popupPlacement: placement,
    ref: domRef,
    popupAlign: align,
    getPopupContainer: getTooltipContainer,
    onPopupVisibleChange: onVisibleChange,
    afterPopupVisibleChange: afterVisibleChange,
    popupTransitionName: transitionName,
    popupAnimation: animation,
    popupMotion: motion,
    defaultPopupVisible: defaultVisible,
    destroyPopupOnHide: destroyTooltip,
    autoDestroy: autoDestroy,
    mouseLeaveDelay: mouseLeaveDelay,
    popupStyle: overlayStyle,
    mouseEnterDelay: mouseEnterDelay
  }, extraProps), children);
};

var Tooltip$3 = /*#__PURE__*/React.forwardRef(Tooltip$2);

tuple('success', 'processing', 'error', 'default', 'warning');
// eslint-disable-next-line import/prefer-default-export
var PresetColorTypes = tuple('pink', 'red', 'yellow', 'orange', 'cyan', 'green', 'blue', 'purple', 'geekblue', 'magenta', 'volcano', 'gold', 'lime');

var autoAdjustOverflowEnabled = {
  adjustX: 1,
  adjustY: 1
};
var autoAdjustOverflowDisabled = {
  adjustX: 0,
  adjustY: 0
};
var targetOffset = [0, 0];
function getOverflowOptions(autoAdjustOverflow) {
  if (typeof autoAdjustOverflow === 'boolean') {
    return autoAdjustOverflow ? autoAdjustOverflowEnabled : autoAdjustOverflowDisabled;
  }
  return _extends(_extends({}, autoAdjustOverflowDisabled), autoAdjustOverflow);
}
function getPlacements(config) {
  var _config$arrowWidth = config.arrowWidth,
    arrowWidth = _config$arrowWidth === void 0 ? 4 : _config$arrowWidth,
    _config$horizontalArr = config.horizontalArrowShift,
    horizontalArrowShift = _config$horizontalArr === void 0 ? 16 : _config$horizontalArr,
    _config$verticalArrow = config.verticalArrowShift,
    verticalArrowShift = _config$verticalArrow === void 0 ? 8 : _config$verticalArrow,
    autoAdjustOverflow = config.autoAdjustOverflow,
    arrowPointAtCenter = config.arrowPointAtCenter;
  var placementMap = {
    left: {
      points: ['cr', 'cl'],
      offset: [-4, 0]
    },
    right: {
      points: ['cl', 'cr'],
      offset: [4, 0]
    },
    top: {
      points: ['bc', 'tc'],
      offset: [0, -4]
    },
    bottom: {
      points: ['tc', 'bc'],
      offset: [0, 4]
    },
    topLeft: {
      points: ['bl', 'tc'],
      offset: [-(horizontalArrowShift + arrowWidth), -4]
    },
    leftTop: {
      points: ['tr', 'cl'],
      offset: [-4, -(verticalArrowShift + arrowWidth)]
    },
    topRight: {
      points: ['br', 'tc'],
      offset: [horizontalArrowShift + arrowWidth, -4]
    },
    rightTop: {
      points: ['tl', 'cr'],
      offset: [4, -(verticalArrowShift + arrowWidth)]
    },
    bottomRight: {
      points: ['tr', 'bc'],
      offset: [horizontalArrowShift + arrowWidth, 4]
    },
    rightBottom: {
      points: ['bl', 'cr'],
      offset: [4, verticalArrowShift + arrowWidth]
    },
    bottomLeft: {
      points: ['tl', 'bc'],
      offset: [-(horizontalArrowShift + arrowWidth), 4]
    },
    leftBottom: {
      points: ['br', 'cl'],
      offset: [-4, verticalArrowShift + arrowWidth]
    }
  };
  Object.keys(placementMap).forEach(function (key) {
    placementMap[key] = arrowPointAtCenter ? _extends(_extends({}, placementMap[key]), {
      overflow: getOverflowOptions(autoAdjustOverflow),
      targetOffset: targetOffset
    }) : _extends(_extends({}, placements[key]), {
      overflow: getOverflowOptions(autoAdjustOverflow)
    });
    placementMap[key].ignoreShake = true;
  });
  return placementMap;
}

var __rest$7 = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var splitObject = function splitObject(obj, keys) {
  var picked = {};
  var omitted = _extends({}, obj);
  keys.forEach(function (key) {
    if (obj && key in obj) {
      picked[key] = obj[key];
      delete omitted[key];
    }
  });
  return {
    picked: picked,
    omitted: omitted
  };
};
var PresetColorRegex = new RegExp("^(".concat(PresetColorTypes.join('|'), ")(-inverse)?$"));
// Fix Tooltip won't hide at disabled button
// mouse events don't trigger at disabled button in Chrome
// https://github.com/react-component/tooltip/issues/18
function getDisabledCompatibleChildren(element, prefixCls) {
  var elementType = element.type;
  if ((elementType.__ANT_BUTTON === true || element.type === 'button') && element.props.disabled || elementType.__ANT_SWITCH === true && (element.props.disabled || element.props.loading) || elementType.__ANT_RADIO === true && element.props.disabled) {
    // Pick some layout related style properties up to span
    // Prevent layout bugs like https://github.com/ant-design/ant-design/issues/5254
    var _splitObject = splitObject(element.props.style, ['position', 'left', 'right', 'top', 'bottom', 'float', 'display', 'zIndex']),
      picked = _splitObject.picked,
      omitted = _splitObject.omitted;
    var spanStyle = _extends(_extends({
      display: 'inline-block'
    }, picked), {
      cursor: 'not-allowed',
      width: element.props.block ? '100%' : undefined
    });
    var buttonStyle = _extends(_extends({}, omitted), {
      pointerEvents: 'none'
    });
    var child = cloneElement(element, {
      style: buttonStyle,
      className: null
    });
    return /*#__PURE__*/React__namespace.createElement("span", {
      style: spanStyle,
      className: classNames(element.props.className, "".concat(prefixCls, "-disabled-compatible-wrapper"))
    }, child);
  }
  return element;
}
var Tooltip = /*#__PURE__*/React__namespace.forwardRef(function (props, ref) {
  var _classNames2;
  var _React$useContext = React__namespace.useContext(ConfigContext),
    getContextPopupContainer = _React$useContext.getPopupContainer,
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction;
  // Warning for deprecated usage
  if (process.env.NODE_ENV !== 'production') {
    [['visible', 'open'], ['defaultVisible', 'defaultOpen'], ['onVisibleChange', 'onOpenChange'], ['afterVisibleChange', 'afterOpenChange']].forEach(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
        deprecatedName = _ref2[0],
        newName = _ref2[1];
      process.env.NODE_ENV !== "production" ? warning$2(!(deprecatedName in props), 'Tooltip', "`".concat(deprecatedName, "` is deprecated which will be removed in next major version, please use `").concat(newName, "` instead.")) : void 0;
    });
  }
  var _useMergedState = useMergedState(false, {
      value: props.open !== undefined ? props.open : props.visible,
      defaultValue: props.defaultOpen !== undefined ? props.defaultOpen : props.defaultVisible
    }),
    _useMergedState2 = _slicedToArray(_useMergedState, 2),
    open = _useMergedState2[0],
    setOpen = _useMergedState2[1];
  var isNoTitle = function isNoTitle() {
    var title = props.title,
      overlay = props.overlay;
    return !title && !overlay && title !== 0; // overlay for old version compatibility
  };

  var onOpenChange = function onOpenChange(vis) {
    var _a, _b;
    setOpen(isNoTitle() ? false : vis);
    if (!isNoTitle()) {
      (_a = props.onOpenChange) === null || _a === void 0 ? void 0 : _a.call(props, vis);
      (_b = props.onVisibleChange) === null || _b === void 0 ? void 0 : _b.call(props, vis);
    }
  };
  var getTooltipPlacements = function getTooltipPlacements() {
    var builtinPlacements = props.builtinPlacements,
      _props$arrowPointAtCe = props.arrowPointAtCenter,
      arrowPointAtCenter = _props$arrowPointAtCe === void 0 ? false : _props$arrowPointAtCe,
      _props$autoAdjustOver = props.autoAdjustOverflow,
      autoAdjustOverflow = _props$autoAdjustOver === void 0 ? true : _props$autoAdjustOver;
    return builtinPlacements || getPlacements({
      arrowPointAtCenter: arrowPointAtCenter,
      autoAdjustOverflow: autoAdjustOverflow
    });
  };
  // 动态设置动画点
  var onPopupAlign = function onPopupAlign(domNode, align) {
    var placements = getTooltipPlacements();
    // 当前返回的位置
    var placement = Object.keys(placements).find(function (key) {
      var _a, _b;
      return placements[key].points[0] === ((_a = align.points) === null || _a === void 0 ? void 0 : _a[0]) && placements[key].points[1] === ((_b = align.points) === null || _b === void 0 ? void 0 : _b[1]);
    });
    if (!placement) {
      return;
    }
    // 根据当前坐标设置动画点
    var rect = domNode.getBoundingClientRect();
    var transformOrigin = {
      top: '50%',
      left: '50%'
    };
    if (/top|Bottom/.test(placement)) {
      transformOrigin.top = "".concat(rect.height - align.offset[1], "px");
    } else if (/Top|bottom/.test(placement)) {
      transformOrigin.top = "".concat(-align.offset[1], "px");
    }
    if (/left|Right/.test(placement)) {
      transformOrigin.left = "".concat(rect.width - align.offset[0], "px");
    } else if (/right|Left/.test(placement)) {
      transformOrigin.left = "".concat(-align.offset[0], "px");
    }
    domNode.style.transformOrigin = "".concat(transformOrigin.left, " ").concat(transformOrigin.top);
  };
  var getOverlay = function getOverlay() {
    var title = props.title,
      overlay = props.overlay;
    if (title === 0) {
      return title;
    }
    return overlay || title || '';
  };
  var getPopupContainer = props.getPopupContainer,
    _props$placement = props.placement,
    placement = _props$placement === void 0 ? 'top' : _props$placement,
    _props$mouseEnterDela = props.mouseEnterDelay,
    mouseEnterDelay = _props$mouseEnterDela === void 0 ? 0.1 : _props$mouseEnterDela,
    _props$mouseLeaveDela = props.mouseLeaveDelay,
    mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela,
    otherProps = __rest$7(props, ["getPopupContainer", "placement", "mouseEnterDelay", "mouseLeaveDelay"]);
  var customizePrefixCls = props.prefixCls,
    openClassName = props.openClassName,
    getTooltipContainer = props.getTooltipContainer,
    overlayClassName = props.overlayClassName,
    color = props.color,
    overlayInnerStyle = props.overlayInnerStyle,
    children = props.children;
  var prefixCls = getPrefixCls('tooltip', customizePrefixCls);
  var rootPrefixCls = getPrefixCls();
  var tempOpen = open;
  // Hide tooltip when there is no title
  if (!('open' in props) && !('visible' in props) && isNoTitle()) {
    tempOpen = false;
  }
  var child = getDisabledCompatibleChildren(isValidElement(children) && !isFragment(children) ? children : /*#__PURE__*/React__namespace.createElement("span", null, children), prefixCls);
  var childProps = child.props;
  var childCls = !childProps.className || typeof childProps.className === 'string' ? classNames(childProps.className, _defineProperty$1({}, openClassName || "".concat(prefixCls, "-open"), true)) : childProps.className;
  var customOverlayClassName = classNames(overlayClassName, (_classNames2 = {}, _defineProperty$1(_classNames2, "".concat(prefixCls, "-rtl"), direction === 'rtl'), _defineProperty$1(_classNames2, "".concat(prefixCls, "-").concat(color), color && PresetColorRegex.test(color)), _classNames2));
  var formattedOverlayInnerStyle = overlayInnerStyle;
  var arrowContentStyle = {};
  if (color && !PresetColorRegex.test(color)) {
    formattedOverlayInnerStyle = _extends(_extends({}, overlayInnerStyle), {
      background: color
    });
    // @ts-ignore
    arrowContentStyle = {
      '--antd-arrow-background-color': color
    };
  }
  return /*#__PURE__*/React__namespace.createElement(Tooltip$3, _extends({}, otherProps, {
    placement: placement,
    mouseEnterDelay: mouseEnterDelay,
    mouseLeaveDelay: mouseLeaveDelay,
    prefixCls: prefixCls,
    overlayClassName: customOverlayClassName,
    getTooltipContainer: getPopupContainer || getTooltipContainer || getContextPopupContainer,
    ref: ref,
    builtinPlacements: getTooltipPlacements(),
    overlay: getOverlay(),
    visible: tempOpen,
    onVisibleChange: onOpenChange,
    onPopupAlign: onPopupAlign,
    overlayInnerStyle: formattedOverlayInnerStyle,
    arrowContent: /*#__PURE__*/React__namespace.createElement("span", {
      className: "".concat(prefixCls, "-arrow-content"),
      style: arrowContentStyle
    }),
    motion: {
      motionName: getTransitionName(rootPrefixCls, 'zoom-big-fast', props.transitionName),
      motionDeadline: 1000
    }
  }), tempOpen ? cloneElement(child, {
    className: childCls
  }) : child);
});
if (process.env.NODE_ENV !== 'production') {
  Tooltip.displayName = 'Tooltip';
}
var Tooltip$1 = Tooltip;

var id = 0;
var ids = {};
// Support call raf with delay specified frame
function wrapperRaf(callback) {
  var delayFrames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var myId = id++;
  var restFrames = delayFrames;
  function internalCallback() {
    restFrames -= 1;
    if (restFrames <= 0) {
      callback();
      delete ids[myId];
    } else {
      ids[myId] = wrapperRaf$1(internalCallback);
    }
  }
  ids[myId] = wrapperRaf$1(internalCallback);
  return myId;
}
wrapperRaf.cancel = function cancel(pid) {
  if (pid === undefined) return;
  wrapperRaf$1.cancel(ids[pid]);
  delete ids[pid];
};
wrapperRaf.ids = ids; // export this for test usage

var styleForPseudo;
// Where el is the DOM element you'd like to test for visibility
function isHidden(element) {
  if (process.env.NODE_ENV === 'test') {
    return false;
  }
  return !element || element.offsetParent === null || element.hidden;
}
function getValidateContainer(nodeRoot) {
  if (nodeRoot instanceof Document) {
    return nodeRoot.body;
  }
  return Array.from(nodeRoot.childNodes).find(function (ele) {
    return (ele === null || ele === void 0 ? void 0 : ele.nodeType) === Node.ELEMENT_NODE;
  });
}
function isNotGrey(color) {
  // eslint-disable-next-line no-useless-escape
  var match = (color || '').match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
  if (match && match[1] && match[2] && match[3]) {
    return !(match[1] === match[2] && match[2] === match[3]);
  }
  return true;
}
var Wave = /*#__PURE__*/function (_React$Component) {
  _inherits(Wave, _React$Component);
  var _super = _createSuper(Wave);
  function Wave() {
    var _this;
    _classCallCheck(this, Wave);
    _this = _super.apply(this, arguments);
    _this.containerRef = /*#__PURE__*/React__namespace.createRef();
    _this.animationStart = false;
    _this.destroyed = false;
    _this.onClick = function (node, waveColor) {
      var _a, _b;
      var _this$props = _this.props,
        insertExtraNode = _this$props.insertExtraNode,
        disabled = _this$props.disabled;
      if (disabled || !node || isHidden(node) || node.className.includes('-leave')) {
        return;
      }
      _this.extraNode = document.createElement('div');
      var _assertThisInitialize = _assertThisInitialized(_this),
        extraNode = _assertThisInitialize.extraNode;
      var getPrefixCls = _this.context.getPrefixCls;
      extraNode.className = "".concat(getPrefixCls(''), "-click-animating-node");
      var attributeName = _this.getAttributeName();
      node.setAttribute(attributeName, 'true');
      // Not white or transparent or grey
      if (waveColor && waveColor !== '#fff' && waveColor !== '#ffffff' && waveColor !== 'rgb(255, 255, 255)' && waveColor !== 'rgba(255, 255, 255, 1)' && isNotGrey(waveColor) && !/rgba\((?:\d*, ){3}0\)/.test(waveColor) &&
      // any transparent rgba color
      waveColor !== 'transparent') {
        extraNode.style.borderColor = waveColor;
        var nodeRoot = ((_a = node.getRootNode) === null || _a === void 0 ? void 0 : _a.call(node)) || node.ownerDocument;
        var nodeBody = (_b = getValidateContainer(nodeRoot)) !== null && _b !== void 0 ? _b : nodeRoot;
        styleForPseudo = updateCSS("\n      [".concat(getPrefixCls(''), "-click-animating-without-extra-node='true']::after, .").concat(getPrefixCls(''), "-click-animating-node {\n        --antd-wave-shadow-color: ").concat(waveColor, ";\n      }"), 'antd-wave', {
          csp: _this.csp,
          attachTo: nodeBody
        });
      }
      if (insertExtraNode) {
        node.appendChild(extraNode);
      }
      ['transition', 'animation'].forEach(function (name) {
        node.addEventListener("".concat(name, "start"), _this.onTransitionStart);
        node.addEventListener("".concat(name, "end"), _this.onTransitionEnd);
      });
    };
    _this.onTransitionStart = function (e) {
      if (_this.destroyed) {
        return;
      }
      var node = _this.containerRef.current;
      if (!e || e.target !== node || _this.animationStart) {
        return;
      }
      _this.resetEffect(node);
    };
    _this.onTransitionEnd = function (e) {
      if (!e || e.animationName !== 'fadeEffect') {
        return;
      }
      _this.resetEffect(e.target);
    };
    _this.bindAnimationEvent = function (node) {
      if (!node || !node.getAttribute || node.getAttribute('disabled') || node.className.includes('disabled')) {
        return;
      }
      var onClick = function onClick(e) {
        // Fix radio button click twice
        if (e.target.tagName === 'INPUT' || isHidden(e.target)) {
          return;
        }
        _this.resetEffect(node);
        // Get wave color from target
        var waveColor = getComputedStyle(node).getPropertyValue('border-top-color') ||
        // Firefox Compatible
        getComputedStyle(node).getPropertyValue('border-color') || getComputedStyle(node).getPropertyValue('background-color');
        _this.clickWaveTimeoutId = window.setTimeout(function () {
          return _this.onClick(node, waveColor);
        }, 0);
        wrapperRaf.cancel(_this.animationStartId);
        _this.animationStart = true;
        // Render to trigger transition event cost 3 frames. Let's delay 10 frames to reset this.
        _this.animationStartId = wrapperRaf(function () {
          _this.animationStart = false;
        }, 10);
      };
      node.addEventListener('click', onClick, true);
      return {
        cancel: function cancel() {
          node.removeEventListener('click', onClick, true);
        }
      };
    };
    _this.renderWave = function (_ref) {
      var csp = _ref.csp;
      var children = _this.props.children;
      _this.csp = csp;
      if (! /*#__PURE__*/React__namespace.isValidElement(children)) return children;
      var ref = _this.containerRef;
      if (supportRef(children)) {
        ref = composeRef(children.ref, _this.containerRef);
      }
      return cloneElement(children, {
        ref: ref
      });
    };
    return _this;
  }
  _createClass(Wave, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.destroyed = false;
      var node = this.containerRef.current;
      if (!node || node.nodeType !== 1) {
        return;
      }
      this.instance = this.bindAnimationEvent(node);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.instance) {
        this.instance.cancel();
      }
      if (this.clickWaveTimeoutId) {
        clearTimeout(this.clickWaveTimeoutId);
      }
      this.destroyed = true;
    }
  }, {
    key: "getAttributeName",
    value: function getAttributeName() {
      var getPrefixCls = this.context.getPrefixCls;
      var insertExtraNode = this.props.insertExtraNode;
      return insertExtraNode ? "".concat(getPrefixCls(''), "-click-animating") : "".concat(getPrefixCls(''), "-click-animating-without-extra-node");
    }
  }, {
    key: "resetEffect",
    value: function resetEffect(node) {
      var _this2 = this;
      if (!node || node === this.extraNode || !(node instanceof Element)) {
        return;
      }
      var insertExtraNode = this.props.insertExtraNode;
      var attributeName = this.getAttributeName();
      node.setAttribute(attributeName, 'false'); // edge has bug on `removeAttribute` #14466
      if (styleForPseudo) {
        styleForPseudo.innerHTML = '';
      }
      if (insertExtraNode && this.extraNode && node.contains(this.extraNode)) {
        node.removeChild(this.extraNode);
      }
      ['transition', 'animation'].forEach(function (name) {
        node.removeEventListener("".concat(name, "start"), _this2.onTransitionStart);
        node.removeEventListener("".concat(name, "end"), _this2.onTransitionEnd);
      });
    }
  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/React__namespace.createElement(ConfigConsumer, null, this.renderWave);
    }
  }]);
  return Wave;
}(React__namespace.Component);
Wave.contextType = ConfigContext;
var Wave$1 = Wave;

var __rest$6 = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var GroupSizeContext = /*#__PURE__*/React__namespace.createContext(undefined);
var ButtonGroup = function ButtonGroup(props) {
  var _classNames;
  var _React$useContext = React__namespace.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction;
  var customizePrefixCls = props.prefixCls,
    size = props.size,
    className = props.className,
    others = __rest$6(props, ["prefixCls", "size", "className"]);
  var prefixCls = getPrefixCls('btn-group', customizePrefixCls);
  // large => lg
  // small => sm
  var sizeCls = '';
  switch (size) {
    case 'large':
      sizeCls = 'lg';
      break;
    case 'small':
      sizeCls = 'sm';
      break;
    case 'middle':
    case undefined:
      break;
    default:
      process.env.NODE_ENV !== "production" ? warning$2(!size, 'Button.Group', 'Invalid prop `size`.') : void 0;
  }
  var classes = classNames(prefixCls, (_classNames = {}, _defineProperty$1(_classNames, "".concat(prefixCls, "-").concat(sizeCls), sizeCls), _defineProperty$1(_classNames, "".concat(prefixCls, "-rtl"), direction === 'rtl'), _classNames), className);
  return /*#__PURE__*/React__namespace.createElement(GroupSizeContext.Provider, {
    value: size
  }, /*#__PURE__*/React__namespace.createElement("div", _extends({}, others, {
    className: classes
  })));
};
var Group = ButtonGroup;

var getCollapsedWidth = function getCollapsedWidth() {
  return {
    width: 0,
    opacity: 0,
    transform: 'scale(0)'
  };
};
var getRealWidth = function getRealWidth(node) {
  return {
    width: node.scrollWidth,
    opacity: 1,
    transform: 'scale(1)'
  };
};
var LoadingIcon = function LoadingIcon(_ref) {
  var prefixCls = _ref.prefixCls,
    loading = _ref.loading,
    existIcon = _ref.existIcon;
  var visible = !!loading;
  if (existIcon) {
    return /*#__PURE__*/React.createElement("span", {
      className: "".concat(prefixCls, "-loading-icon")
    }, /*#__PURE__*/React.createElement(LoadingOutlined$1, null));
  }
  return /*#__PURE__*/React.createElement(CSSMotion, {
    visible: visible,
    // We do not really use this motionName
    motionName: "".concat(prefixCls, "-loading-icon-motion"),
    removeOnLeave: true,
    onAppearStart: getCollapsedWidth,
    onAppearActive: getRealWidth,
    onEnterStart: getCollapsedWidth,
    onEnterActive: getRealWidth,
    onLeaveStart: getRealWidth,
    onLeaveActive: getCollapsedWidth
  }, function (_ref2, ref) {
    var className = _ref2.className,
      style = _ref2.style;
    return /*#__PURE__*/React.createElement("span", {
      className: "".concat(prefixCls, "-loading-icon"),
      style: style,
      ref: ref
    }, /*#__PURE__*/React.createElement(LoadingOutlined$1, {
      className: className
    }));
  });
};
var LoadingIcon$1 = LoadingIcon;

var __rest$5 = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var rxTwoCNChar = /^[\u4e00-\u9fa5]{2}$/;
var isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
function isString(str) {
  return typeof str === 'string';
}
function isUnBorderedButtonType(type) {
  return type === 'text' || type === 'link';
}
// Insert one space between two chinese characters automatically.
function insertSpace(child, needInserted) {
  // Check the child if is undefined or null.
  if (child === null || child === undefined) {
    return;
  }
  var SPACE = needInserted ? ' ' : '';
  // strictNullChecks oops.
  if (typeof child !== 'string' && typeof child !== 'number' && isString(child.type) && isTwoCNChar(child.props.children)) {
    return cloneElement(child, {
      children: child.props.children.split('').join(SPACE)
    });
  }
  if (typeof child === 'string') {
    return isTwoCNChar(child) ? /*#__PURE__*/React__namespace.createElement("span", null, child.split('').join(SPACE)) : /*#__PURE__*/React__namespace.createElement("span", null, child);
  }
  if (isFragment(child)) {
    return /*#__PURE__*/React__namespace.createElement("span", null, child);
  }
  return child;
}
function spaceChildren(children, needInserted) {
  var isPrevChildPure = false;
  var childList = [];
  React__namespace.Children.forEach(children, function (child) {
    var type = _typeof$1(child);
    var isCurrentChildPure = type === 'string' || type === 'number';
    if (isPrevChildPure && isCurrentChildPure) {
      var lastIndex = childList.length - 1;
      var lastChild = childList[lastIndex];
      childList[lastIndex] = "".concat(lastChild).concat(child);
    } else {
      childList.push(child);
    }
    isPrevChildPure = isCurrentChildPure;
  });
  // Pass to React.Children.map to auto fill key
  return React__namespace.Children.map(childList, function (child) {
    return insertSpace(child, needInserted);
  });
}
tuple('default', 'primary', 'ghost', 'dashed', 'link', 'text');
tuple('default', 'circle', 'round');
tuple('submit', 'button', 'reset');
var InternalButton = function InternalButton(props, ref) {
  var _classNames;
  var _props$loading = props.loading,
    loading = _props$loading === void 0 ? false : _props$loading,
    customizePrefixCls = props.prefixCls,
    _props$type = props.type,
    type = _props$type === void 0 ? 'default' : _props$type,
    danger = props.danger,
    _props$shape = props.shape,
    shape = _props$shape === void 0 ? 'default' : _props$shape,
    customizeSize = props.size,
    customDisabled = props.disabled,
    className = props.className,
    children = props.children,
    icon = props.icon,
    _props$ghost = props.ghost,
    ghost = _props$ghost === void 0 ? false : _props$ghost,
    _props$block = props.block,
    block = _props$block === void 0 ? false : _props$block,
    _props$htmlType = props.htmlType,
    htmlType = _props$htmlType === void 0 ? 'button' : _props$htmlType,
    rest = __rest$5(props, ["loading", "prefixCls", "type", "danger", "shape", "size", "disabled", "className", "children", "icon", "ghost", "block", "htmlType"]);
  var size = React__namespace.useContext(SizeContext$1);
  // ===================== Disabled =====================
  var disabled = React__namespace.useContext(DisabledContext$1);
  var mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
  var groupSize = React__namespace.useContext(GroupSizeContext);
  var _React$useState = React__namespace.useState(!!loading),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    innerLoading = _React$useState2[0],
    setLoading = _React$useState2[1];
  var _React$useState3 = React__namespace.useState(false),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    hasTwoCNChar = _React$useState4[0],
    setHasTwoCNChar = _React$useState4[1];
  var _React$useContext = React__namespace.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    autoInsertSpaceInButton = _React$useContext.autoInsertSpaceInButton,
    direction = _React$useContext.direction;
  var buttonRef = ref || /*#__PURE__*/React__namespace.createRef();
  var isNeedInserted = function isNeedInserted() {
    return React__namespace.Children.count(children) === 1 && !icon && !isUnBorderedButtonType(type);
  };
  var fixTwoCNChar = function fixTwoCNChar() {
    // Fix for HOC usage like <FormatMessage />
    if (!buttonRef || !buttonRef.current || autoInsertSpaceInButton === false) {
      return;
    }
    var buttonText = buttonRef.current.textContent;
    if (isNeedInserted() && isTwoCNChar(buttonText)) {
      if (!hasTwoCNChar) {
        setHasTwoCNChar(true);
      }
    } else if (hasTwoCNChar) {
      setHasTwoCNChar(false);
    }
  };
  // =============== Update Loading ===============
  var loadingOrDelay = typeof loading === 'boolean' ? loading : (loading === null || loading === void 0 ? void 0 : loading.delay) || true;
  React__namespace.useEffect(function () {
    var delayTimer = null;
    if (typeof loadingOrDelay === 'number') {
      delayTimer = window.setTimeout(function () {
        delayTimer = null;
        setLoading(loadingOrDelay);
      }, loadingOrDelay);
    } else {
      setLoading(loadingOrDelay);
    }
    return function () {
      if (delayTimer) {
        // in order to not perform a React state update on an unmounted component
        // and clear timer after 'loadingOrDelay' updated.
        window.clearTimeout(delayTimer);
        delayTimer = null;
      }
    };
  }, [loadingOrDelay]);
  React__namespace.useEffect(fixTwoCNChar, [buttonRef]);
  var handleClick = function handleClick(e) {
    var onClick = props.onClick;
    // https://github.com/ant-design/ant-design/issues/30207
    if (innerLoading || mergedDisabled) {
      e.preventDefault();
      return;
    }
    onClick === null || onClick === void 0 ? void 0 : onClick(e);
  };
  process.env.NODE_ENV !== "production" ? warning$2(!(typeof icon === 'string' && icon.length > 2), 'Button', "`icon` is using ReactNode instead of string naming in v4. Please check `".concat(icon, "` at https://ant.design/components/icon")) : void 0;
  process.env.NODE_ENV !== "production" ? warning$2(!(ghost && isUnBorderedButtonType(type)), 'Button', "`link` or `text` button can't be a `ghost` button.") : void 0;
  var prefixCls = getPrefixCls('btn', customizePrefixCls);
  var autoInsertSpace = autoInsertSpaceInButton !== false;
  var _useCompactItemContex = useCompactItemContext(prefixCls, direction),
    compactSize = _useCompactItemContex.compactSize,
    compactItemClassnames = _useCompactItemContex.compactItemClassnames;
  var sizeClassNameMap = {
    large: 'lg',
    small: 'sm',
    middle: undefined
  };
  var sizeFullname = compactSize || groupSize || customizeSize || size;
  var sizeCls = sizeFullname ? sizeClassNameMap[sizeFullname] || '' : '';
  var iconType = innerLoading ? 'loading' : icon;
  var linkButtonRestProps = omit(rest, ['navigate']);
  var classes = classNames(prefixCls, (_classNames = {}, _defineProperty$1(_classNames, "".concat(prefixCls, "-").concat(shape), shape !== 'default' && shape), _defineProperty$1(_classNames, "".concat(prefixCls, "-").concat(type), type), _defineProperty$1(_classNames, "".concat(prefixCls, "-").concat(sizeCls), sizeCls), _defineProperty$1(_classNames, "".concat(prefixCls, "-icon-only"), !children && children !== 0 && !!iconType), _defineProperty$1(_classNames, "".concat(prefixCls, "-background-ghost"), ghost && !isUnBorderedButtonType(type)), _defineProperty$1(_classNames, "".concat(prefixCls, "-loading"), innerLoading), _defineProperty$1(_classNames, "".concat(prefixCls, "-two-chinese-chars"), hasTwoCNChar && autoInsertSpace && !innerLoading), _defineProperty$1(_classNames, "".concat(prefixCls, "-block"), block), _defineProperty$1(_classNames, "".concat(prefixCls, "-dangerous"), !!danger), _defineProperty$1(_classNames, "".concat(prefixCls, "-rtl"), direction === 'rtl'), _defineProperty$1(_classNames, "".concat(prefixCls, "-disabled"), linkButtonRestProps.href !== undefined && mergedDisabled), _classNames), compactItemClassnames, className);
  var iconNode = icon && !innerLoading ? icon : /*#__PURE__*/React__namespace.createElement(LoadingIcon$1, {
    existIcon: !!icon,
    prefixCls: prefixCls,
    loading: !!innerLoading
  });
  var kids = children || children === 0 ? spaceChildren(children, isNeedInserted() && autoInsertSpace) : null;
  if (linkButtonRestProps.href !== undefined) {
    return /*#__PURE__*/React__namespace.createElement("a", _extends({}, linkButtonRestProps, {
      className: classes,
      onClick: handleClick,
      ref: buttonRef
    }), iconNode, kids);
  }
  var buttonNode = /*#__PURE__*/React__namespace.createElement("button", _extends({}, rest, {
    type: htmlType,
    className: classes,
    onClick: handleClick,
    disabled: mergedDisabled,
    ref: buttonRef
  }), iconNode, kids);
  if (isUnBorderedButtonType(type)) {
    return buttonNode;
  }
  return /*#__PURE__*/React__namespace.createElement(Wave$1, {
    disabled: !!innerLoading
  }, buttonNode);
};
var Button = /*#__PURE__*/React__namespace.forwardRef(InternalButton);
if (process.env.NODE_ENV !== 'production') {
  Button.displayName = 'Button';
}
Button.Group = Group;
Button.__ANT_BUTTON = true;
var Button$1 = Button;

// This icon file is generated automatically.
var EyeOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, "name": "eye", "theme": "outlined" };
var EyeOutlinedSvg = EyeOutlined$2;

var EyeOutlined = function EyeOutlined(props, ref) {
  return /*#__PURE__*/React__namespace.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref: ref,
    icon: EyeOutlinedSvg
  }));
};
EyeOutlined.displayName = 'EyeOutlined';
var EyeOutlined$1 = /*#__PURE__*/React__namespace.forwardRef(EyeOutlined);

var defaultProps = {
  percent: 0,
  prefixCls: 'rc-progress',
  strokeColor: '#2db7f5',
  strokeLinecap: 'round',
  strokeWidth: 1,
  trailColor: '#D9D9D9',
  trailWidth: 1,
  gapPosition: 'bottom'
};
var useTransitionDuration = function useTransitionDuration() {
  var pathsRef = React.useRef([]);
  var prevTimeStamp = React.useRef(null);
  React.useEffect(function () {
    var now = Date.now();
    var updated = false;
    pathsRef.current.forEach(function (path) {
      if (!path) {
        return;
      }
      updated = true;
      var pathStyle = path.style;
      pathStyle.transitionDuration = '.3s, .3s, .3s, .06s';
      if (prevTimeStamp.current && now - prevTimeStamp.current < 100) {
        pathStyle.transitionDuration = '0s, 0s';
      }
    });
    if (updated) {
      prevTimeStamp.current = Date.now();
    }
  });
  return pathsRef.current;
};

if (process.env.NODE_ENV !== 'production') ;

var uuid = 0;
/** Is client side and not jsdom */
var isBrowserClient = process.env.NODE_ENV !== 'test' && canUseDom();
/** Get unique id for accessibility usage */
function getUUID() {
  var retId;
  // Test never reach
  /* istanbul ignore if */
  if (isBrowserClient) {
    retId = uuid;
    uuid += 1;
  } else {
    retId = 'TEST_OR_SSR';
  }
  return retId;
}
var useId = (function (id) {
  // Inner id for accessibility usage. Only work in client side
  var _React$useState = React__namespace.useState(),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    innerId = _React$useState2[0],
    setInnerId = _React$useState2[1];
  React__namespace.useEffect(function () {
    setInnerId("rc_progress_".concat(getUUID()));
  }, []);
  return id || innerId;
});

var _excluded$1 = ["id", "prefixCls", "steps", "strokeWidth", "trailWidth", "gapDegree", "gapPosition", "trailColor", "strokeLinecap", "style", "className", "strokeColor", "percent"];
function stripPercentToNumber(percent) {
  return +percent.replace('%', '');
}
function toArray(value) {
  var mergedValue = value !== null && value !== void 0 ? value : [];
  return Array.isArray(mergedValue) ? mergedValue : [mergedValue];
}
var VIEW_BOX_SIZE = 100;
var getCircleStyle = function getCircleStyle(perimeter, perimeterWithoutGap, offset, percent, rotateDeg, gapDegree, gapPosition, strokeColor, strokeLinecap, strokeWidth) {
  var stepSpace = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 0;
  var offsetDeg = offset / 100 * 360 * ((360 - gapDegree) / 360);
  var positionDeg = gapDegree === 0 ? 0 : {
    bottom: 0,
    top: 180,
    left: 90,
    right: -90
  }[gapPosition];
  var strokeDashoffset = (100 - percent) / 100 * perimeterWithoutGap;
  // Fix percent accuracy when strokeLinecap is round
  // https://github.com/ant-design/ant-design/issues/35009
  if (strokeLinecap === 'round' && percent !== 100) {
    strokeDashoffset += strokeWidth / 2;
    // when percent is small enough (<= 1%), keep smallest value to avoid it's disappearance
    if (strokeDashoffset >= perimeterWithoutGap) {
      strokeDashoffset = perimeterWithoutGap - 0.01;
    }
  }
  return {
    stroke: typeof strokeColor === 'string' ? strokeColor : undefined,
    strokeDasharray: "".concat(perimeterWithoutGap, "px ").concat(perimeter),
    strokeDashoffset: strokeDashoffset + stepSpace,
    transform: "rotate(".concat(rotateDeg + offsetDeg + positionDeg, "deg)"),
    transformOrigin: '0 0',
    transition: 'stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s, opacity .3s ease 0s',
    fillOpacity: 0
  };
};
var Circle$2 = function Circle(props) {
  var _defaultProps$props = _objectSpread2$1(_objectSpread2$1({}, defaultProps), props),
    id = _defaultProps$props.id,
    prefixCls = _defaultProps$props.prefixCls,
    steps = _defaultProps$props.steps,
    strokeWidth = _defaultProps$props.strokeWidth,
    trailWidth = _defaultProps$props.trailWidth,
    _defaultProps$props$g = _defaultProps$props.gapDegree,
    gapDegree = _defaultProps$props$g === void 0 ? 0 : _defaultProps$props$g,
    gapPosition = _defaultProps$props.gapPosition,
    trailColor = _defaultProps$props.trailColor,
    strokeLinecap = _defaultProps$props.strokeLinecap,
    style = _defaultProps$props.style,
    className = _defaultProps$props.className,
    strokeColor = _defaultProps$props.strokeColor,
    percent = _defaultProps$props.percent,
    restProps = _objectWithoutProperties(_defaultProps$props, _excluded$1);
  var mergedId = useId(id);
  var gradientId = "".concat(mergedId, "-gradient");
  var radius = VIEW_BOX_SIZE / 2 - strokeWidth / 2;
  var perimeter = Math.PI * 2 * radius;
  var rotateDeg = gapDegree > 0 ? 90 + gapDegree / 2 : -90;
  var perimeterWithoutGap = perimeter * ((360 - gapDegree) / 360);
  var _ref = _typeof$1(steps) === 'object' ? steps : {
      count: steps,
      space: 2
    },
    stepCount = _ref.count,
    stepSpace = _ref.space;
  var circleStyle = getCircleStyle(perimeter, perimeterWithoutGap, 0, 100, rotateDeg, gapDegree, gapPosition, trailColor, strokeLinecap, strokeWidth);
  var percentList = toArray(percent);
  var strokeColorList = toArray(strokeColor);
  var gradient = strokeColorList.find(function (color) {
    return color && _typeof$1(color) === 'object';
  });
  var paths = useTransitionDuration();
  var getStokeList = function getStokeList() {
    var stackPtg = 0;
    return percentList.map(function (ptg, index) {
      var color = strokeColorList[index] || strokeColorList[strokeColorList.length - 1];
      var stroke = color && _typeof$1(color) === 'object' ? "url(#".concat(gradientId, ")") : undefined;
      var circleStyleForStack = getCircleStyle(perimeter, perimeterWithoutGap, stackPtg, ptg, rotateDeg, gapDegree, gapPosition, color, strokeLinecap, strokeWidth);
      stackPtg += ptg;
      return /*#__PURE__*/React__namespace.createElement("circle", {
        key: index,
        className: "".concat(prefixCls, "-circle-path"),
        r: radius,
        cx: 0,
        cy: 0,
        stroke: stroke,
        strokeLinecap: strokeLinecap,
        strokeWidth: strokeWidth,
        opacity: ptg === 0 ? 0 : 1,
        style: circleStyleForStack,
        ref: function ref(elem) {
          // https://reactjs.org/docs/refs-and-the-dom.html#callback-refs
          // React will call the ref callback with the DOM element when the component mounts,
          // and call it with `null` when it unmounts.
          // Refs are guaranteed to be up-to-date before componentDidMount or componentDidUpdate fires.
          paths[index] = elem;
        }
      });
    }).reverse();
  };
  var getStepStokeList = function getStepStokeList() {
    // only show the first percent when pass steps
    var current = Math.round(stepCount * (percentList[0] / 100));
    var stepPtg = 100 / stepCount;
    var stackPtg = 0;
    return new Array(stepCount).fill(null).map(function (_, index) {
      var color = index <= current - 1 ? strokeColorList[0] : trailColor;
      var stroke = color && _typeof$1(color) === 'object' ? "url(#".concat(gradientId, ")") : undefined;
      var circleStyleForStack = getCircleStyle(perimeter, perimeterWithoutGap, stackPtg, stepPtg, rotateDeg, gapDegree, gapPosition, color, 'butt', strokeWidth, stepSpace);
      stackPtg += (perimeterWithoutGap - circleStyleForStack.strokeDashoffset + stepSpace) * 100 / perimeterWithoutGap;
      return /*#__PURE__*/React__namespace.createElement("circle", {
        key: index,
        className: "".concat(prefixCls, "-circle-path"),
        r: radius,
        cx: 0,
        cy: 0,
        stroke: stroke
        // strokeLinecap={strokeLinecap}
        ,
        strokeWidth: strokeWidth,
        opacity: 1,
        style: circleStyleForStack,
        ref: function ref(elem) {
          paths[index] = elem;
        }
      });
    });
  };
  return /*#__PURE__*/React__namespace.createElement("svg", _extends({
    className: classNames("".concat(prefixCls, "-circle"), className),
    viewBox: "".concat(-VIEW_BOX_SIZE / 2, " ").concat(-VIEW_BOX_SIZE / 2, " ").concat(VIEW_BOX_SIZE, " ").concat(VIEW_BOX_SIZE),
    style: style,
    id: id,
    role: "presentation"
  }, restProps), gradient && /*#__PURE__*/React__namespace.createElement("defs", null, /*#__PURE__*/React__namespace.createElement("linearGradient", {
    id: gradientId,
    x1: "100%",
    y1: "0%",
    x2: "0%",
    y2: "0%"
  }, Object.keys(gradient).sort(function (a, b) {
    return stripPercentToNumber(a) - stripPercentToNumber(b);
  }).map(function (key, index) {
    return /*#__PURE__*/React__namespace.createElement("stop", {
      key: index,
      offset: key,
      stopColor: gradient[key]
    });
  }))), !stepCount && /*#__PURE__*/React__namespace.createElement("circle", {
    className: "".concat(prefixCls, "-circle-trail"),
    r: radius,
    cx: 0,
    cy: 0,
    stroke: trailColor,
    strokeLinecap: strokeLinecap,
    strokeWidth: trailWidth || strokeWidth,
    style: circleStyle
  }), stepCount ? getStepStokeList() : getStokeList());
};
if (process.env.NODE_ENV !== 'production') {
  Circle$2.displayName = 'Circle';
}

function validProgress(progress) {
  if (!progress || progress < 0) {
    return 0;
  }
  if (progress > 100) {
    return 100;
  }
  return progress;
}
function getSuccessPercent(_ref) {
  var success = _ref.success,
    successPercent = _ref.successPercent;
  var percent = successPercent;
  /** @deprecated Use `percent` instead */
  if (success && 'progress' in success) {
    process.env.NODE_ENV !== "production" ? warning$2(false, 'Progress', '`success.progress` is deprecated. Please use `success.percent` instead.') : void 0;
    percent = success.progress;
  }
  if (success && 'percent' in success) {
    percent = success.percent;
  }
  return percent;
}

function getPercentage(_ref) {
  var percent = _ref.percent,
    success = _ref.success,
    successPercent = _ref.successPercent;
  var realSuccessPercent = validProgress(getSuccessPercent({
    success: success,
    successPercent: successPercent
  }));
  return [realSuccessPercent, validProgress(validProgress(percent) - realSuccessPercent)];
}
function getStrokeColor(_ref2) {
  var _ref2$success = _ref2.success,
    success = _ref2$success === void 0 ? {} : _ref2$success,
    strokeColor = _ref2.strokeColor;
  var successColor = success.strokeColor;
  return [successColor || presetPrimaryColors.green, strokeColor || null];
}
var Circle = function Circle(props) {
  var prefixCls = props.prefixCls,
    width = props.width,
    strokeWidth = props.strokeWidth,
    _props$trailColor = props.trailColor,
    trailColor = _props$trailColor === void 0 ? null : _props$trailColor,
    _props$strokeLinecap = props.strokeLinecap,
    strokeLinecap = _props$strokeLinecap === void 0 ? 'round' : _props$strokeLinecap,
    gapPosition = props.gapPosition,
    gapDegree = props.gapDegree,
    type = props.type,
    children = props.children,
    success = props.success;
  var circleSize = width || 120;
  var circleStyle = {
    width: circleSize,
    height: circleSize,
    fontSize: circleSize * 0.15 + 6
  };
  var circleWidth = strokeWidth || 6;
  var gapPos = gapPosition || type === 'dashboard' && 'bottom' || undefined;
  var getGapDegree = function getGapDegree() {
    // Support gapDeg = 0 when type = 'dashboard'
    if (gapDegree || gapDegree === 0) {
      return gapDegree;
    }
    if (type === 'dashboard') {
      return 75;
    }
    return undefined;
  };
  // using className to style stroke color
  var isGradient = Object.prototype.toString.call(props.strokeColor) === '[object Object]';
  var strokeColor = getStrokeColor({
    success: success,
    strokeColor: props.strokeColor
  });
  var wrapperClassName = classNames("".concat(prefixCls, "-inner"), _defineProperty$1({}, "".concat(prefixCls, "-circle-gradient"), isGradient));
  return /*#__PURE__*/React__namespace.createElement("div", {
    className: wrapperClassName,
    style: circleStyle
  }, /*#__PURE__*/React__namespace.createElement(Circle$2, {
    percent: getPercentage(props),
    strokeWidth: circleWidth,
    trailWidth: circleWidth,
    strokeColor: strokeColor,
    strokeLinecap: strokeLinecap,
    trailColor: trailColor,
    prefixCls: prefixCls,
    gapDegree: getGapDegree(),
    gapPosition: gapPos
  }), children);
};
var Circle$1 = Circle;

var __rest$4 = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
/**
 * @example
 *   {
 *     "0%": "#afc163",
 *     "75%": "#009900",
 *     "50%": "green", // ====> '#afc163 0%, #66FF00 25%, #00CC00 50%, #009900 75%, #ffffff 100%'
 *     "25%": "#66FF00",
 *     "100%": "#ffffff"
 *   }
 */
var sortGradient = function sortGradient(gradients) {
  var tempArr = [];
  Object.keys(gradients).forEach(function (key) {
    var formattedKey = parseFloat(key.replace(/%/g, ''));
    if (!isNaN(formattedKey)) {
      tempArr.push({
        key: formattedKey,
        value: gradients[key]
      });
    }
  });
  tempArr = tempArr.sort(function (a, b) {
    return a.key - b.key;
  });
  return tempArr.map(function (_ref) {
    var key = _ref.key,
      value = _ref.value;
    return "".concat(value, " ").concat(key, "%");
  }).join(', ');
};
/**
 * Then this man came to realize the truth: Besides six pence, there is the moon. Besides bread and
 * butter, there is the bug. And... Besides women, there is the code.
 *
 * @example
 *   {
 *     "0%": "#afc163",
 *     "25%": "#66FF00",
 *     "50%": "#00CC00", // ====>  linear-gradient(to right, #afc163 0%, #66FF00 25%,
 *     "75%": "#009900", //        #00CC00 50%, #009900 75%, #ffffff 100%)
 *     "100%": "#ffffff"
 *   }
 */
var handleGradient = function handleGradient(strokeColor, directionConfig) {
  var _strokeColor$from = strokeColor.from,
    from = _strokeColor$from === void 0 ? presetPrimaryColors.blue : _strokeColor$from,
    _strokeColor$to = strokeColor.to,
    to = _strokeColor$to === void 0 ? presetPrimaryColors.blue : _strokeColor$to,
    _strokeColor$directio = strokeColor.direction,
    direction = _strokeColor$directio === void 0 ? directionConfig === 'rtl' ? 'to left' : 'to right' : _strokeColor$directio,
    rest = __rest$4(strokeColor, ["from", "to", "direction"]);
  if (Object.keys(rest).length !== 0) {
    var sortedGradients = sortGradient(rest);
    return {
      backgroundImage: "linear-gradient(".concat(direction, ", ").concat(sortedGradients, ")")
    };
  }
  return {
    backgroundImage: "linear-gradient(".concat(direction, ", ").concat(from, ", ").concat(to, ")")
  };
};
var Line = function Line(props) {
  var prefixCls = props.prefixCls,
    directionConfig = props.direction,
    percent = props.percent,
    strokeWidth = props.strokeWidth,
    size = props.size,
    strokeColor = props.strokeColor,
    _props$strokeLinecap = props.strokeLinecap,
    strokeLinecap = _props$strokeLinecap === void 0 ? 'round' : _props$strokeLinecap,
    children = props.children,
    _props$trailColor = props.trailColor,
    trailColor = _props$trailColor === void 0 ? null : _props$trailColor,
    success = props.success;
  var backgroundProps = strokeColor && typeof strokeColor !== 'string' ? handleGradient(strokeColor, directionConfig) : {
    background: strokeColor
  };
  var borderRadius = strokeLinecap === 'square' || strokeLinecap === 'butt' ? 0 : undefined;
  var trailStyle = {
    backgroundColor: trailColor || undefined,
    borderRadius: borderRadius
  };
  var percentStyle = _extends({
    width: "".concat(validProgress(percent), "%"),
    height: strokeWidth || (size === 'small' ? 6 : 8),
    borderRadius: borderRadius
  }, backgroundProps);
  var successPercent = getSuccessPercent(props);
  var successPercentStyle = {
    width: "".concat(validProgress(successPercent), "%"),
    height: strokeWidth || (size === 'small' ? 6 : 8),
    borderRadius: borderRadius,
    backgroundColor: success === null || success === void 0 ? void 0 : success.strokeColor
  };
  var successSegment = successPercent !== undefined ? /*#__PURE__*/React__namespace.createElement("div", {
    className: "".concat(prefixCls, "-success-bg"),
    style: successPercentStyle
  }) : null;
  return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement("div", {
    className: "".concat(prefixCls, "-outer")
  }, /*#__PURE__*/React__namespace.createElement("div", {
    className: "".concat(prefixCls, "-inner"),
    style: trailStyle
  }, /*#__PURE__*/React__namespace.createElement("div", {
    className: "".concat(prefixCls, "-bg"),
    style: percentStyle
  }), successSegment)), children);
};
var Line$1 = Line;

var Steps = function Steps(props) {
  var size = props.size,
    steps = props.steps,
    _props$percent = props.percent,
    percent = _props$percent === void 0 ? 0 : _props$percent,
    _props$strokeWidth = props.strokeWidth,
    strokeWidth = _props$strokeWidth === void 0 ? 8 : _props$strokeWidth,
    strokeColor = props.strokeColor,
    _props$trailColor = props.trailColor,
    trailColor = _props$trailColor === void 0 ? null : _props$trailColor,
    prefixCls = props.prefixCls,
    children = props.children;
  var current = Math.round(steps * (percent / 100));
  var stepWidth = size === 'small' ? 2 : 14;
  var styledSteps = new Array(steps);
  for (var i = 0; i < steps; i++) {
    var color = Array.isArray(strokeColor) ? strokeColor[i] : strokeColor;
    styledSteps[i] = /*#__PURE__*/React__namespace.createElement("div", {
      key: i,
      className: classNames("".concat(prefixCls, "-steps-item"), _defineProperty$1({}, "".concat(prefixCls, "-steps-item-active"), i <= current - 1)),
      style: {
        backgroundColor: i <= current - 1 ? color : trailColor,
        width: stepWidth,
        height: strokeWidth
      }
    });
  }
  return /*#__PURE__*/React__namespace.createElement("div", {
    className: "".concat(prefixCls, "-steps-outer")
  }, styledSteps, children);
};
var Steps$1 = Steps;

var __rest$3 = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
tuple('line', 'circle', 'dashboard');
var ProgressStatuses = tuple('normal', 'exception', 'active', 'success');
var Progress = function Progress(props) {
  var _classNames;
  var customizePrefixCls = props.prefixCls,
    className = props.className,
    steps = props.steps,
    strokeColor = props.strokeColor,
    _props$percent = props.percent,
    percent = _props$percent === void 0 ? 0 : _props$percent,
    _props$size = props.size,
    size = _props$size === void 0 ? 'default' : _props$size,
    _props$showInfo = props.showInfo,
    showInfo = _props$showInfo === void 0 ? true : _props$showInfo,
    _props$type = props.type,
    type = _props$type === void 0 ? 'line' : _props$type,
    restProps = __rest$3(props, ["prefixCls", "className", "steps", "strokeColor", "percent", "size", "showInfo", "type"]);
  function getPercentNumber() {
    var successPercent = getSuccessPercent(props);
    return parseInt(successPercent !== undefined ? successPercent.toString() : percent.toString(), 10);
  }
  function getProgressStatus() {
    var status = props.status;
    if (!ProgressStatuses.includes(status) && getPercentNumber() >= 100) {
      return 'success';
    }
    return status || 'normal';
  }
  function renderProcessInfo(prefixCls, progressStatus) {
    var format = props.format;
    var successPercent = getSuccessPercent(props);
    if (!showInfo) {
      return null;
    }
    var text;
    var textFormatter = format || function (percentNumber) {
      return "".concat(percentNumber, "%");
    };
    var isLineType = type === 'line';
    if (format || progressStatus !== 'exception' && progressStatus !== 'success') {
      text = textFormatter(validProgress(percent), validProgress(successPercent));
    } else if (progressStatus === 'exception') {
      text = isLineType ? /*#__PURE__*/React__namespace.createElement(CloseCircleFilled$1, null) : /*#__PURE__*/React__namespace.createElement(CloseOutlined$1, null);
    } else if (progressStatus === 'success') {
      text = isLineType ? /*#__PURE__*/React__namespace.createElement(CheckCircleFilled$1, null) : /*#__PURE__*/React__namespace.createElement(CheckOutlined$1, null);
    }
    return /*#__PURE__*/React__namespace.createElement("span", {
      className: "".concat(prefixCls, "-text"),
      title: typeof text === 'string' ? text : undefined
    }, text);
  }
  var _React$useContext = React__namespace.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction;
  var prefixCls = getPrefixCls('progress', customizePrefixCls);
  var progressStatus = getProgressStatus();
  var progressInfo = renderProcessInfo(prefixCls, progressStatus);
  process.env.NODE_ENV !== "production" ? warning$2(!('successPercent' in props), 'Progress', '`successPercent` is deprecated. Please use `success.percent` instead.') : void 0;
  var strokeColorNotArray = Array.isArray(strokeColor) ? strokeColor[0] : strokeColor;
  var strokeColorNotGradient = typeof strokeColor === 'string' || Array.isArray(strokeColor) ? strokeColor : undefined;
  var progress;
  // Render progress shape
  if (type === 'line') {
    progress = steps ? /*#__PURE__*/React__namespace.createElement(Steps$1, _extends({}, props, {
      strokeColor: strokeColorNotGradient,
      prefixCls: prefixCls,
      steps: steps
    }), progressInfo) : /*#__PURE__*/React__namespace.createElement(Line$1, _extends({}, props, {
      strokeColor: strokeColorNotArray,
      prefixCls: prefixCls,
      direction: direction
    }), progressInfo);
  } else if (type === 'circle' || type === 'dashboard') {
    progress = /*#__PURE__*/React__namespace.createElement(Circle$1, _extends({}, props, {
      strokeColor: strokeColorNotArray,
      prefixCls: prefixCls,
      progressStatus: progressStatus
    }), progressInfo);
  }
  var classString = classNames(prefixCls, (_classNames = {}, _defineProperty$1(_classNames, "".concat(prefixCls, "-").concat(type === 'dashboard' && 'circle' || steps && 'steps' || type), true), _defineProperty$1(_classNames, "".concat(prefixCls, "-status-").concat(progressStatus), true), _defineProperty$1(_classNames, "".concat(prefixCls, "-show-info"), showInfo), _defineProperty$1(_classNames, "".concat(prefixCls, "-").concat(size), size), _defineProperty$1(_classNames, "".concat(prefixCls, "-rtl"), direction === 'rtl'), _classNames), className);
  return /*#__PURE__*/React__namespace.createElement("div", _extends({}, omit(restProps, ['status', 'format', 'trailColor', 'strokeWidth', 'width', 'gapDegree', 'gapPosition', 'strokeLinecap', 'success', 'successPercent']), {
    className: classString,
    role: "progressbar"
  }), progress);
};
var Progress$1 = Progress;

// This icon file is generated automatically.
var DeleteOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M360 184h-8c4.4 0 8-3.6 8-8v8h304v-8c0 4.4 3.6 8 8 8h-8v72h72v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80h72v-72zm504 72H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32zM731.3 840H292.7l-24.2-512h487l-24.2 512z" } }] }, "name": "delete", "theme": "outlined" };
var DeleteOutlinedSvg = DeleteOutlined$2;

var DeleteOutlined = function DeleteOutlined(props, ref) {
  return /*#__PURE__*/React__namespace.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref: ref,
    icon: DeleteOutlinedSvg
  }));
};
DeleteOutlined.displayName = 'DeleteOutlined';
var DeleteOutlined$1 = /*#__PURE__*/React__namespace.forwardRef(DeleteOutlined);

function getError(option, xhr) {
  var msg = "cannot ".concat(option.method, " ").concat(option.action, " ").concat(xhr.status, "'");
  var err = new Error(msg);
  err.status = xhr.status;
  err.method = option.method;
  err.url = option.action;
  return err;
}

function getBody(xhr) {
  var text = xhr.responseText || xhr.response;

  if (!text) {
    return text;
  }

  try {
    return JSON.parse(text);
  } catch (e) {
    return text;
  }
}

function upload(option) {
  // eslint-disable-next-line no-undef
  var xhr = new XMLHttpRequest();

  if (option.onProgress && xhr.upload) {
    xhr.upload.onprogress = function progress(e) {
      if (e.total > 0) {
        e.percent = e.loaded / e.total * 100;
      }

      option.onProgress(e);
    };
  } // eslint-disable-next-line no-undef


  var formData = new FormData();

  if (option.data) {
    Object.keys(option.data).forEach(function (key) {
      var value = option.data[key]; // support key-value array data

      if (Array.isArray(value)) {
        value.forEach(function (item) {
          // { list: [ 11, 22 ] }
          // formData.append('list[]', 11);
          formData.append("".concat(key, "[]"), item);
        });
        return;
      }

      formData.append(key, value);
    });
  } // eslint-disable-next-line no-undef


  if (option.file instanceof Blob) {
    formData.append(option.filename, option.file, option.file.name);
  } else {
    formData.append(option.filename, option.file);
  }

  xhr.onerror = function error(e) {
    option.onError(e);
  };

  xhr.onload = function onload() {
    // allow success when 2xx status
    // see https://github.com/react-component/upload/issues/34
    if (xhr.status < 200 || xhr.status >= 300) {
      return option.onError(getError(option, xhr), getBody(xhr));
    }

    return option.onSuccess(getBody(xhr), xhr);
  };

  xhr.open(option.method, option.action, true); // Has to be after `.open()`. See https://github.com/enyo/dropzone/issues/179

  if (option.withCredentials && 'withCredentials' in xhr) {
    xhr.withCredentials = true;
  }

  var headers = option.headers || {}; // when set headers['X-Requested-With'] = null , can close default XHR header
  // see https://github.com/react-component/upload/issues/33

  if (headers['X-Requested-With'] !== null) {
    xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
  }

  Object.keys(headers).forEach(function (h) {
    if (headers[h] !== null) {
      xhr.setRequestHeader(h, headers[h]);
    }
  });
  xhr.send(formData);
  return {
    abort: function abort() {
      xhr.abort();
    }
  };
}

var now = +new Date();
var index = 0;
function uid() {
  // eslint-disable-next-line no-plusplus
  return "rc-upload-".concat(now, "-").concat(++index);
}

var attrAccept = (function (file, acceptedFiles) {
  if (file && acceptedFiles) {
    var acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(',');
    var fileName = file.name || '';
    var mimeType = file.type || '';
    var baseMimeType = mimeType.replace(/\/.*$/, '');
    return acceptedFilesArray.some(function (type) {
      var validType = type.trim(); // This is something like */*,*  allow all files

      if (/^\*(\/\*)?$/.test(type)) {
        return true;
      } // like .jpg, .png


      if (validType.charAt(0) === '.') {
        var lowerFileName = fileName.toLowerCase();
        var lowerType = validType.toLowerCase();
        var affixList = [lowerType];

        if (lowerType === '.jpg' || lowerType === '.jpeg') {
          affixList = ['.jpg', '.jpeg'];
        }

        return affixList.some(function (affix) {
          return lowerFileName.endsWith(affix);
        });
      } // This is something like a image/* mime type


      if (/\/\*$/.test(validType)) {
        return baseMimeType === validType.replace(/\/.*$/, '');
      } // Full match


      if (mimeType === validType) {
        return true;
      } // Invalidate type should skip


      if (/^\w+$/.test(validType)) {
        warningOnce(false, "Upload takes an invalidate 'accept' type '".concat(validType, "'.Skip for check."));
        return true;
      }

      return false;
    });
  }

  return true;
});

function loopFiles(item, callback) {
  var dirReader = item.createReader();
  var fileList = [];

  function sequence() {
    dirReader.readEntries(function (entries) {
      var entryList = Array.prototype.slice.apply(entries);
      fileList = fileList.concat(entryList); // Check if all the file has been viewed

      var isFinished = !entryList.length;

      if (isFinished) {
        callback(fileList);
      } else {
        sequence();
      }
    });
  }

  sequence();
}

var traverseFileTree = function traverseFileTree(files, callback, isAccepted) {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  var _traverseFileTree = function _traverseFileTree(item, path) {
    // eslint-disable-next-line no-param-reassign
    item.path = path || '';

    if (item.isFile) {
      item.file(function (file) {
        if (isAccepted(file)) {
          // https://github.com/ant-design/ant-design/issues/16426
          if (item.fullPath && !file.webkitRelativePath) {
            Object.defineProperties(file, {
              webkitRelativePath: {
                writable: true
              }
            }); // eslint-disable-next-line no-param-reassign

            file.webkitRelativePath = item.fullPath.replace(/^\//, '');
            Object.defineProperties(file, {
              webkitRelativePath: {
                writable: false
              }
            });
          }

          callback([file]);
        }
      });
    } else if (item.isDirectory) {
      loopFiles(item, function (entries) {
        entries.forEach(function (entryItem) {
          _traverseFileTree(entryItem, "".concat(path).concat(item.name, "/"));
        });
      });
    }
  };

  files.forEach(function (file) {
    _traverseFileTree(file.webkitGetAsEntry());
  });
};

var _excluded = ["component", "prefixCls", "className", "disabled", "id", "style", "multiple", "accept", "capture", "children", "directory", "openFileDialogOnClick", "onMouseEnter", "onMouseLeave"];

var AjaxUploader = /*#__PURE__*/function (_Component) {
  _inherits(AjaxUploader, _Component);

  var _super = _createSuper(AjaxUploader);

  function AjaxUploader() {
    var _this;

    _classCallCheck(this, AjaxUploader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.state = {
      uid: uid()
    };
    _this.reqs = {};
    _this.fileInput = void 0;
    _this._isMounted = void 0;

    _this.onChange = function (e) {
      var _this$props = _this.props,
          accept = _this$props.accept,
          directory = _this$props.directory;
      var files = e.target.files;

      var acceptedFiles = _toConsumableArray(files).filter(function (file) {
        return !directory || attrAccept(file, accept);
      });

      _this.uploadFiles(acceptedFiles);

      _this.reset();
    };

    _this.onClick = function (e) {
      var el = _this.fileInput;

      if (!el) {
        return;
      }

      var _this$props2 = _this.props,
          children = _this$props2.children,
          onClick = _this$props2.onClick;

      if (children && children.type === 'button') {
        var parent = el.parentNode;
        parent.focus();
        parent.querySelector('button').blur();
      }

      el.click();

      if (onClick) {
        onClick(e);
      }
    };

    _this.onKeyDown = function (e) {
      if (e.key === 'Enter') {
        _this.onClick(e);
      }
    };

    _this.onFileDrop = function (e) {
      var multiple = _this.props.multiple;
      e.preventDefault();

      if (e.type === 'dragover') {
        return;
      }

      if (_this.props.directory) {
        traverseFileTree(Array.prototype.slice.call(e.dataTransfer.items), _this.uploadFiles, function (_file) {
          return attrAccept(_file, _this.props.accept);
        });
      } else {
        var files = _toConsumableArray(e.dataTransfer.files).filter(function (file) {
          return attrAccept(file, _this.props.accept);
        });

        if (multiple === false) {
          files = files.slice(0, 1);
        }

        _this.uploadFiles(files);
      }
    };

    _this.uploadFiles = function (files) {
      var originFiles = _toConsumableArray(files);

      var postFiles = originFiles.map(function (file) {
        // eslint-disable-next-line no-param-reassign
        file.uid = uid();
        return _this.processFile(file, originFiles);
      }); // Batch upload files

      Promise.all(postFiles).then(function (fileList) {
        var onBatchStart = _this.props.onBatchStart;
        onBatchStart === null || onBatchStart === void 0 ? void 0 : onBatchStart(fileList.map(function (_ref) {
          var origin = _ref.origin,
              parsedFile = _ref.parsedFile;
          return {
            file: origin,
            parsedFile: parsedFile
          };
        }));
        fileList.filter(function (file) {
          return file.parsedFile !== null;
        }).forEach(function (file) {
          _this.post(file);
        });
      });
    };

    _this.processFile = /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(file, fileList) {
        var beforeUpload, transformedFile, action, mergedAction, data, mergedData, parsedData, parsedFile, mergedParsedFile;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                beforeUpload = _this.props.beforeUpload;
                transformedFile = file;

                if (!beforeUpload) {
                  _context.next = 14;
                  break;
                }

                _context.prev = 3;
                _context.next = 6;
                return beforeUpload(file, fileList);

              case 6:
                transformedFile = _context.sent;
                _context.next = 12;
                break;

              case 9:
                _context.prev = 9;
                _context.t0 = _context["catch"](3);
                // Rejection will also trade as false
                transformedFile = false;

              case 12:
                if (!(transformedFile === false)) {
                  _context.next = 14;
                  break;
                }

                return _context.abrupt("return", {
                  origin: file,
                  parsedFile: null,
                  action: null,
                  data: null
                });

              case 14:
                // Get latest action
                action = _this.props.action;

                if (!(typeof action === 'function')) {
                  _context.next = 21;
                  break;
                }

                _context.next = 18;
                return action(file);

              case 18:
                mergedAction = _context.sent;
                _context.next = 22;
                break;

              case 21:
                mergedAction = action;

              case 22:
                // Get latest data
                data = _this.props.data;

                if (!(typeof data === 'function')) {
                  _context.next = 29;
                  break;
                }

                _context.next = 26;
                return data(file);

              case 26:
                mergedData = _context.sent;
                _context.next = 30;
                break;

              case 29:
                mergedData = data;

              case 30:
                parsedData = // string type is from legacy `transformFile`.
                // Not sure if this will work since no related test case works with it
                (_typeof$1(transformedFile) === 'object' || typeof transformedFile === 'string') && transformedFile ? transformedFile : file;

                if (parsedData instanceof File) {
                  parsedFile = parsedData;
                } else {
                  parsedFile = new File([parsedData], file.name, {
                    type: file.type
                  });
                }

                mergedParsedFile = parsedFile;
                mergedParsedFile.uid = file.uid;
                return _context.abrupt("return", {
                  origin: file,
                  data: mergedData,
                  parsedFile: mergedParsedFile,
                  action: mergedAction
                });

              case 35:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[3, 9]]);
      }));

      return function (_x, _x2) {
        return _ref2.apply(this, arguments);
      };
    }();

    _this.saveFileInput = function (node) {
      _this.fileInput = node;
    };

    return _this;
  }

  _createClass(AjaxUploader, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this._isMounted = true;
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this._isMounted = false;
      this.abort();
    }
  }, {
    key: "post",
    value: function post(_ref3) {
      var _this2 = this;

      var data = _ref3.data,
          origin = _ref3.origin,
          action = _ref3.action,
          parsedFile = _ref3.parsedFile;

      if (!this._isMounted) {
        return;
      }

      var _this$props3 = this.props,
          onStart = _this$props3.onStart,
          customRequest = _this$props3.customRequest,
          name = _this$props3.name,
          headers = _this$props3.headers,
          withCredentials = _this$props3.withCredentials,
          method = _this$props3.method;
      var uid = origin.uid;
      var request = customRequest || upload;
      var requestOption = {
        action: action,
        filename: name,
        data: data,
        file: parsedFile,
        headers: headers,
        withCredentials: withCredentials,
        method: method || 'post',
        onProgress: function onProgress(e) {
          var onProgress = _this2.props.onProgress;
          onProgress === null || onProgress === void 0 ? void 0 : onProgress(e, parsedFile);
        },
        onSuccess: function onSuccess(ret, xhr) {
          var onSuccess = _this2.props.onSuccess;
          onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(ret, parsedFile, xhr);
          delete _this2.reqs[uid];
        },
        onError: function onError(err, ret) {
          var onError = _this2.props.onError;
          onError === null || onError === void 0 ? void 0 : onError(err, ret, parsedFile);
          delete _this2.reqs[uid];
        }
      };
      onStart(origin);
      this.reqs[uid] = request(requestOption);
    }
  }, {
    key: "reset",
    value: function reset() {
      this.setState({
        uid: uid()
      });
    }
  }, {
    key: "abort",
    value: function abort(file) {
      var reqs = this.reqs;

      if (file) {
        var uid = file.uid ? file.uid : file;

        if (reqs[uid] && reqs[uid].abort) {
          reqs[uid].abort();
        }

        delete reqs[uid];
      } else {
        Object.keys(reqs).forEach(function (uid) {
          if (reqs[uid] && reqs[uid].abort) {
            reqs[uid].abort();
          }

          delete reqs[uid];
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _classNames;

      var _this$props4 = this.props,
          Tag = _this$props4.component,
          prefixCls = _this$props4.prefixCls,
          className = _this$props4.className,
          disabled = _this$props4.disabled,
          id = _this$props4.id,
          style = _this$props4.style,
          multiple = _this$props4.multiple,
          accept = _this$props4.accept,
          capture = _this$props4.capture,
          children = _this$props4.children,
          directory = _this$props4.directory,
          openFileDialogOnClick = _this$props4.openFileDialogOnClick,
          onMouseEnter = _this$props4.onMouseEnter,
          onMouseLeave = _this$props4.onMouseLeave,
          otherProps = _objectWithoutProperties(_this$props4, _excluded);

      var cls = classNames((_classNames = {}, _defineProperty$1(_classNames, prefixCls, true), _defineProperty$1(_classNames, "".concat(prefixCls, "-disabled"), disabled), _defineProperty$1(_classNames, className, className), _classNames)); // because input don't have directory/webkitdirectory type declaration

      var dirProps = directory ? {
        directory: 'directory',
        webkitdirectory: 'webkitdirectory'
      } : {};
      var events = disabled ? {} : {
        onClick: openFileDialogOnClick ? this.onClick : function () {},
        onKeyDown: openFileDialogOnClick ? this.onKeyDown : function () {},
        onMouseEnter: onMouseEnter,
        onMouseLeave: onMouseLeave,
        onDrop: this.onFileDrop,
        onDragOver: this.onFileDrop,
        tabIndex: '0'
      };
      return /*#__PURE__*/React.createElement(Tag, _extends({}, events, {
        className: cls,
        role: "button",
        style: style
      }), /*#__PURE__*/React.createElement("input", _extends({}, pickAttrs(otherProps, {
        aria: true,
        data: true
      }), {
        id: id,
        type: "file",
        ref: this.saveFileInput,
        onClick: function onClick(e) {
          return e.stopPropagation();
        } // https://github.com/ant-design/ant-design/issues/19948
        ,
        key: this.state.uid,
        style: {
          display: 'none'
        },
        accept: accept
      }, dirProps, {
        multiple: multiple,
        onChange: this.onChange
      }, capture != null ? {
        capture: capture
      } : {})), children);
    }
  }]);

  return AjaxUploader;
}(React.Component);

function empty() {}

var Upload$3 = /*#__PURE__*/function (_Component) {
  _inherits(Upload, _Component);

  var _super = _createSuper(Upload);

  function Upload() {
    var _this;

    _classCallCheck(this, Upload);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.uploader = void 0;

    _this.saveUploader = function (node) {
      _this.uploader = node;
    };

    return _this;
  }

  _createClass(Upload, [{
    key: "abort",
    value: function abort(file) {
      this.uploader.abort(file);
    }
  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/React.createElement(AjaxUploader, _extends({}, this.props, {
        ref: this.saveUploader
      }));
    }
  }]);

  return Upload;
}(React.Component);

Upload$3.defaultProps = {
  component: 'span',
  prefixCls: 'rc-upload',
  data: {},
  headers: {},
  name: 'file',
  multipart: false,
  onStart: empty,
  onError: empty,
  onSuccess: empty,
  multiple: false,
  beforeUpload: null,
  customRequest: null,
  withCredentials: false,
  openFileDialogOnClick: true
};

// This icon file is generated automatically.
var FileTwoTone$2 = { "icon": function render(primaryColor, secondaryColor) { return { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M534 352V136H232v752h560V394H576a42 42 0 01-42-42z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM602 137.8L790.2 326H602V137.8zM792 888H232V136h302v216a42 42 0 0042 42h216v494z", "fill": primaryColor } }] }; }, "name": "file", "theme": "twotone" };
var FileTwoToneSvg = FileTwoTone$2;

var FileTwoTone = function FileTwoTone(props, ref) {
  return /*#__PURE__*/React__namespace.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref: ref,
    icon: FileTwoToneSvg
  }));
};
FileTwoTone.displayName = 'FileTwoTone';
var FileTwoTone$1 = /*#__PURE__*/React__namespace.forwardRef(FileTwoTone);

// This icon file is generated automatically.
var PaperClipOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M779.3 196.6c-94.2-94.2-247.6-94.2-341.7 0l-261 260.8c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l261-260.8c32.4-32.4 75.5-50.2 121.3-50.2s88.9 17.8 121.2 50.2c32.4 32.4 50.2 75.5 50.2 121.2 0 45.8-17.8 88.8-50.2 121.2l-266 265.9-43.1 43.1c-40.3 40.3-105.8 40.3-146.1 0-19.5-19.5-30.2-45.4-30.2-73s10.7-53.5 30.2-73l263.9-263.8c6.7-6.6 15.5-10.3 24.9-10.3h.1c9.4 0 18.1 3.7 24.7 10.3 6.7 6.7 10.3 15.5 10.3 24.9 0 9.3-3.7 18.1-10.3 24.7L372.4 653c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l215.6-215.6c19.9-19.9 30.8-46.3 30.8-74.4s-11-54.6-30.8-74.4c-41.1-41.1-107.9-41-149 0L463 364 224.8 602.1A172.22 172.22 0 00174 724.8c0 46.3 18.1 89.8 50.8 122.5 33.9 33.8 78.3 50.7 122.7 50.7 44.4 0 88.8-16.9 122.6-50.7l309.2-309C824.8 492.7 850 432 850 367.5c.1-64.6-25.1-125.3-70.7-170.9z" } }] }, "name": "paper-clip", "theme": "outlined" };
var PaperClipOutlinedSvg = PaperClipOutlined$2;

var PaperClipOutlined = function PaperClipOutlined(props, ref) {
  return /*#__PURE__*/React__namespace.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref: ref,
    icon: PaperClipOutlinedSvg
  }));
};
PaperClipOutlined.displayName = 'PaperClipOutlined';
var PaperClipOutlined$1 = /*#__PURE__*/React__namespace.forwardRef(PaperClipOutlined);

// This icon file is generated automatically.
var PictureTwoTone$2 = { "icon": function render(primaryColor, secondaryColor) { return { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 632H136v-39.9l138.5-164.3 150.1 178L658.1 489 888 761.6V792zm0-129.8L664.2 396.8c-3.2-3.8-9-3.8-12.2 0L424.6 666.4l-144-170.7c-3.2-3.8-9-3.8-12.2 0L136 652.7V232h752v430.2z", "fill": primaryColor } }, { "tag": "path", "attrs": { "d": "M424.6 765.8l-150.1-178L136 752.1V792h752v-30.4L658.1 489z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M136 652.7l132.4-157c3.2-3.8 9-3.8 12.2 0l144 170.7L652 396.8c3.2-3.8 9-3.8 12.2 0L888 662.2V232H136v420.7zM304 280a88 88 0 110 176 88 88 0 010-176z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M276 368a28 28 0 1056 0 28 28 0 10-56 0z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M304 456a88 88 0 100-176 88 88 0 000 176zm0-116c15.5 0 28 12.5 28 28s-12.5 28-28 28-28-12.5-28-28 12.5-28 28-28z", "fill": primaryColor } }] }; }, "name": "picture", "theme": "twotone" };
var PictureTwoToneSvg = PictureTwoTone$2;

var PictureTwoTone = function PictureTwoTone(props, ref) {
  return /*#__PURE__*/React__namespace.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref: ref,
    icon: PictureTwoToneSvg
  }));
};
PictureTwoTone.displayName = 'PictureTwoTone';
var PictureTwoTone$1 = /*#__PURE__*/React__namespace.forwardRef(PictureTwoTone);

function file2Obj(file) {
  return _extends(_extends({}, file), {
    lastModified: file.lastModified,
    lastModifiedDate: file.lastModifiedDate,
    name: file.name,
    size: file.size,
    type: file.type,
    uid: file.uid,
    percent: 0,
    originFileObj: file
  });
}
/** Upload fileList. Replace file if exist or just push into it. */
function updateFileList(file, fileList) {
  var nextFileList = _toConsumableArray(fileList);
  var fileIndex = nextFileList.findIndex(function (_ref) {
    var uid = _ref.uid;
    return uid === file.uid;
  });
  if (fileIndex === -1) {
    nextFileList.push(file);
  } else {
    nextFileList[fileIndex] = file;
  }
  return nextFileList;
}
function getFileItem(file, fileList) {
  var matchKey = file.uid !== undefined ? 'uid' : 'name';
  return fileList.filter(function (item) {
    return item[matchKey] === file[matchKey];
  })[0];
}
function removeFileItem(file, fileList) {
  var matchKey = file.uid !== undefined ? 'uid' : 'name';
  var removed = fileList.filter(function (item) {
    return item[matchKey] !== file[matchKey];
  });
  if (removed.length === fileList.length) {
    return null;
  }
  return removed;
}
// ==================== Default Image Preview ====================
var extname = function extname() {
  var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var temp = url.split('/');
  var filename = temp[temp.length - 1];
  var filenameWithoutSuffix = filename.split(/#|\?/)[0];
  return (/\.[^./\\]*$/.exec(filenameWithoutSuffix) || [''])[0];
};
var isImageFileType = function isImageFileType(type) {
  return type.indexOf('image/') === 0;
};
var isImageUrl = function isImageUrl(file) {
  if (file.type && !file.thumbUrl) {
    return isImageFileType(file.type);
  }
  var url = file.thumbUrl || file.url || '';
  var extension = extname(url);
  if (/^data:image\//.test(url) || /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico|heic|heif)$/i.test(extension)) {
    return true;
  }
  if (/^data:/.test(url)) {
    // other file types of base64
    return false;
  }
  if (extension) {
    // other file types which have extension
    return false;
  }
  return true;
};
var MEASURE_SIZE = 200;
function previewImage(file) {
  return new Promise(function (resolve) {
    if (!file.type || !isImageFileType(file.type)) {
      resolve('');
      return;
    }
    var canvas = document.createElement('canvas');
    canvas.width = MEASURE_SIZE;
    canvas.height = MEASURE_SIZE;
    canvas.style.cssText = "position: fixed; left: 0; top: 0; width: ".concat(MEASURE_SIZE, "px; height: ").concat(MEASURE_SIZE, "px; z-index: 9999; display: none;");
    document.body.appendChild(canvas);
    var ctx = canvas.getContext('2d');
    var img = new Image();
    img.onload = function () {
      var width = img.width,
        height = img.height;
      var drawWidth = MEASURE_SIZE;
      var drawHeight = MEASURE_SIZE;
      var offsetX = 0;
      var offsetY = 0;
      if (width > height) {
        drawHeight = height * (MEASURE_SIZE / width);
        offsetY = -(drawHeight - drawWidth) / 2;
      } else {
        drawWidth = width * (MEASURE_SIZE / height);
        offsetX = -(drawWidth - drawHeight) / 2;
      }
      ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
      var dataURL = canvas.toDataURL();
      document.body.removeChild(canvas);
      resolve(dataURL);
    };
    img.crossOrigin = 'anonymous';
    if (file.type.startsWith('image/svg+xml')) {
      var reader = new FileReader();
      reader.addEventListener('load', function () {
        if (reader.result) img.src = reader.result;
      });
      reader.readAsDataURL(file);
    } else {
      img.src = window.URL.createObjectURL(file);
    }
  });
}

// This icon file is generated automatically.
var DownloadOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M505.7 661a8 8 0 0012.6 0l112-141.7c4.1-5.2.4-12.9-6.3-12.9h-74.1V168c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v338.3H400c-6.7 0-10.4 7.7-6.3 12.9l112 141.8zM878 626h-60c-4.4 0-8 3.6-8 8v154H214V634c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v198c0 17.7 14.3 32 32 32h684c17.7 0 32-14.3 32-32V634c0-4.4-3.6-8-8-8z" } }] }, "name": "download", "theme": "outlined" };
var DownloadOutlinedSvg = DownloadOutlined$2;

var DownloadOutlined = function DownloadOutlined(props, ref) {
  return /*#__PURE__*/React__namespace.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref: ref,
    icon: DownloadOutlinedSvg
  }));
};
DownloadOutlined.displayName = 'DownloadOutlined';
var DownloadOutlined$1 = /*#__PURE__*/React__namespace.forwardRef(DownloadOutlined);

var ListItem = /*#__PURE__*/React__namespace.forwardRef(function (_ref, ref) {
  var _classNames3;
  var prefixCls = _ref.prefixCls,
    className = _ref.className,
    style = _ref.style,
    locale = _ref.locale,
    listType = _ref.listType,
    file = _ref.file,
    items = _ref.items,
    progressProps = _ref.progress,
    iconRender = _ref.iconRender,
    actionIconRender = _ref.actionIconRender,
    itemRender = _ref.itemRender,
    isImgUrl = _ref.isImgUrl,
    showPreviewIcon = _ref.showPreviewIcon,
    showRemoveIcon = _ref.showRemoveIcon,
    showDownloadIcon = _ref.showDownloadIcon,
    customPreviewIcon = _ref.previewIcon,
    customRemoveIcon = _ref.removeIcon,
    customDownloadIcon = _ref.downloadIcon,
    onPreview = _ref.onPreview,
    onDownload = _ref.onDownload,
    onClose = _ref.onClose;
  var _a, _b;
  // Status: which will ignore `removed` status
  var status = file.status;
  var _React$useState = React__namespace.useState(status),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    mergedStatus = _React$useState2[0],
    setMergedStatus = _React$useState2[1];
  React__namespace.useEffect(function () {
    if (status !== 'removed') {
      setMergedStatus(status);
    }
  }, [status]);
  // Delay to show the progress bar
  var _React$useState3 = React__namespace.useState(false),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    showProgress = _React$useState4[0],
    setShowProgress = _React$useState4[1];
  var progressRafRef = React__namespace.useRef(null);
  React__namespace.useEffect(function () {
    progressRafRef.current = setTimeout(function () {
      setShowProgress(true);
    }, 300);
    return function () {
      if (progressRafRef.current) {
        clearTimeout(progressRafRef.current);
      }
    };
  }, []);
  // This is used for legacy span make scrollHeight the wrong value.
  // We will force these to be `display: block` with non `picture-card`
  var spanClassName = "".concat(prefixCls, "-span");
  var iconNode = iconRender(file);
  var icon = /*#__PURE__*/React__namespace.createElement("div", {
    className: "".concat(prefixCls, "-text-icon")
  }, iconNode);
  if (listType === 'picture' || listType === 'picture-card') {
    if (mergedStatus === 'uploading' || !file.thumbUrl && !file.url) {
      var _classNames;
      var uploadingClassName = classNames((_classNames = {}, _defineProperty$1(_classNames, "".concat(prefixCls, "-list-item-thumbnail"), true), _defineProperty$1(_classNames, "".concat(prefixCls, "-list-item-file"), mergedStatus !== 'uploading'), _classNames));
      icon = /*#__PURE__*/React__namespace.createElement("div", {
        className: uploadingClassName
      }, iconNode);
    } else {
      var _classNames2;
      var thumbnail = (isImgUrl === null || isImgUrl === void 0 ? void 0 : isImgUrl(file)) ? /*#__PURE__*/React__namespace.createElement("img", {
        src: file.thumbUrl || file.url,
        alt: file.name,
        className: "".concat(prefixCls, "-list-item-image"),
        crossOrigin: file.crossOrigin
      }) : iconNode;
      var aClassName = classNames((_classNames2 = {}, _defineProperty$1(_classNames2, "".concat(prefixCls, "-list-item-thumbnail"), true), _defineProperty$1(_classNames2, "".concat(prefixCls, "-list-item-file"), isImgUrl && !isImgUrl(file)), _classNames2));
      icon = /*#__PURE__*/React__namespace.createElement("a", {
        className: aClassName,
        onClick: function onClick(e) {
          return onPreview(file, e);
        },
        href: file.url || file.thumbUrl,
        target: "_blank",
        rel: "noopener noreferrer"
      }, thumbnail);
    }
  }
  var infoUploadingClass = classNames((_classNames3 = {}, _defineProperty$1(_classNames3, "".concat(prefixCls, "-list-item"), true), _defineProperty$1(_classNames3, "".concat(prefixCls, "-list-item-").concat(mergedStatus), true), _defineProperty$1(_classNames3, "".concat(prefixCls, "-list-item-list-type-").concat(listType), true), _classNames3));
  var linkProps = typeof file.linkProps === 'string' ? JSON.parse(file.linkProps) : file.linkProps;
  var removeIcon = showRemoveIcon ? actionIconRender((typeof customRemoveIcon === 'function' ? customRemoveIcon(file) : customRemoveIcon) || /*#__PURE__*/React__namespace.createElement(DeleteOutlined$1, null), function () {
    return onClose(file);
  }, prefixCls, locale.removeFile) : null;
  var downloadIcon = showDownloadIcon && mergedStatus === 'done' ? actionIconRender((typeof customDownloadIcon === 'function' ? customDownloadIcon(file) : customDownloadIcon) || /*#__PURE__*/React__namespace.createElement(DownloadOutlined$1, null), function () {
    return onDownload(file);
  }, prefixCls, locale.downloadFile) : null;
  var downloadOrDelete = listType !== 'picture-card' && /*#__PURE__*/React__namespace.createElement("span", {
    key: "download-delete",
    className: classNames("".concat(prefixCls, "-list-item-card-actions"), {
      picture: listType === 'picture'
    })
  }, downloadIcon, removeIcon);
  var listItemNameClass = classNames("".concat(prefixCls, "-list-item-name"));
  var preview = file.url ? [/*#__PURE__*/React__namespace.createElement("a", _extends({
    key: "view",
    target: "_blank",
    rel: "noopener noreferrer",
    className: listItemNameClass,
    title: file.name
  }, linkProps, {
    href: file.url,
    onClick: function onClick(e) {
      return onPreview(file, e);
    }
  }), file.name), downloadOrDelete] : [/*#__PURE__*/React__namespace.createElement("span", {
    key: "view",
    className: listItemNameClass,
    onClick: function onClick(e) {
      return onPreview(file, e);
    },
    title: file.name
  }, file.name), downloadOrDelete];
  var previewStyle = {
    pointerEvents: 'none',
    opacity: 0.5
  };
  var previewIcon = showPreviewIcon ? /*#__PURE__*/React__namespace.createElement("a", {
    href: file.url || file.thumbUrl,
    target: "_blank",
    rel: "noopener noreferrer",
    style: file.url || file.thumbUrl ? undefined : previewStyle,
    onClick: function onClick(e) {
      return onPreview(file, e);
    },
    title: locale.previewFile
  }, typeof customPreviewIcon === 'function' ? customPreviewIcon(file) : customPreviewIcon || /*#__PURE__*/React__namespace.createElement(EyeOutlined$1, null)) : null;
  var actions = listType === 'picture-card' && mergedStatus !== 'uploading' && /*#__PURE__*/React__namespace.createElement("span", {
    className: "".concat(prefixCls, "-list-item-actions")
  }, previewIcon, mergedStatus === 'done' && downloadIcon, removeIcon);
  var message;
  if (file.response && typeof file.response === 'string') {
    message = file.response;
  } else {
    message = ((_a = file.error) === null || _a === void 0 ? void 0 : _a.statusText) || ((_b = file.error) === null || _b === void 0 ? void 0 : _b.message) || locale.uploadError;
  }
  var iconAndPreview = /*#__PURE__*/React__namespace.createElement("span", {
    className: spanClassName
  }, icon, preview);
  var _React$useContext = React__namespace.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls;
  var rootPrefixCls = getPrefixCls();
  var dom = /*#__PURE__*/React__namespace.createElement("div", {
    className: infoUploadingClass
  }, /*#__PURE__*/React__namespace.createElement("div", {
    className: "".concat(prefixCls, "-list-item-info")
  }, iconAndPreview), actions, showProgress && /*#__PURE__*/React__namespace.createElement(CSSMotion, {
    motionName: "".concat(rootPrefixCls, "-fade"),
    visible: mergedStatus === 'uploading',
    motionDeadline: 2000
  }, function (_ref2) {
    var motionClassName = _ref2.className;
    // show loading icon if upload progress listener is disabled
    var loadingProgress = 'percent' in file ? /*#__PURE__*/React__namespace.createElement(Progress$1, _extends({}, progressProps, {
      type: "line",
      percent: file.percent
    })) : null;
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: classNames("".concat(prefixCls, "-list-item-progress"), motionClassName)
    }, loadingProgress);
  }));
  var listContainerNameClass = classNames("".concat(prefixCls, "-list-").concat(listType, "-container"), className);
  var item = mergedStatus === 'error' ? /*#__PURE__*/React__namespace.createElement(Tooltip$1, {
    title: message,
    getPopupContainer: function getPopupContainer(node) {
      return node.parentNode;
    }
  }, dom) : dom;
  return /*#__PURE__*/React__namespace.createElement("div", {
    className: listContainerNameClass,
    style: style,
    ref: ref
  }, itemRender ? itemRender(item, file, items, {
    download: onDownload.bind(null, file),
    preview: onPreview.bind(null, file),
    remove: onClose.bind(null, file)
  }) : item);
});
var ListItem$1 = ListItem;

var listItemMotion = _extends({}, collapseMotion$1);
delete listItemMotion.onAppearEnd;
delete listItemMotion.onEnterEnd;
delete listItemMotion.onLeaveEnd;
var InternalUploadList = function InternalUploadList(props, ref) {
  var _classNames;
  var _props$listType = props.listType,
    listType = _props$listType === void 0 ? 'text' : _props$listType,
    _props$previewFile = props.previewFile,
    previewFile = _props$previewFile === void 0 ? previewImage : _props$previewFile,
    onPreview = props.onPreview,
    onDownload = props.onDownload,
    onRemove = props.onRemove,
    locale = props.locale,
    iconRender = props.iconRender,
    _props$isImageUrl = props.isImageUrl,
    isImgUrl = _props$isImageUrl === void 0 ? isImageUrl : _props$isImageUrl,
    customizePrefixCls = props.prefixCls,
    _props$items = props.items,
    items = _props$items === void 0 ? [] : _props$items,
    _props$showPreviewIco = props.showPreviewIcon,
    showPreviewIcon = _props$showPreviewIco === void 0 ? true : _props$showPreviewIco,
    _props$showRemoveIcon = props.showRemoveIcon,
    showRemoveIcon = _props$showRemoveIcon === void 0 ? true : _props$showRemoveIcon,
    _props$showDownloadIc = props.showDownloadIcon,
    showDownloadIcon = _props$showDownloadIc === void 0 ? false : _props$showDownloadIc,
    removeIcon = props.removeIcon,
    previewIcon = props.previewIcon,
    downloadIcon = props.downloadIcon,
    _props$progress = props.progress,
    progress = _props$progress === void 0 ? {
      strokeWidth: 2,
      showInfo: false
    } : _props$progress,
    appendAction = props.appendAction,
    _props$appendActionVi = props.appendActionVisible,
    appendActionVisible = _props$appendActionVi === void 0 ? true : _props$appendActionVi,
    itemRender = props.itemRender,
    disabled = props.disabled;
  var forceUpdate = useForceUpdate();
  var _React$useState = React__namespace.useState(false),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    motionAppear = _React$useState2[0],
    setMotionAppear = _React$useState2[1];
  // ============================= Effect =============================
  React__namespace.useEffect(function () {
    if (listType !== 'picture' && listType !== 'picture-card') {
      return;
    }
    (items || []).forEach(function (file) {
      if (typeof document === 'undefined' || typeof window === 'undefined' || !window.FileReader || !window.File || !(file.originFileObj instanceof File || file.originFileObj instanceof Blob) || file.thumbUrl !== undefined) {
        return;
      }
      file.thumbUrl = '';
      if (previewFile) {
        previewFile(file.originFileObj).then(function (previewDataUrl) {
          // Need append '' to avoid dead loop
          file.thumbUrl = previewDataUrl || '';
          forceUpdate();
        });
      }
    });
  }, [listType, items, previewFile]);
  React__namespace.useEffect(function () {
    setMotionAppear(true);
  }, []);
  // ============================= Events =============================
  var onInternalPreview = function onInternalPreview(file, e) {
    if (!onPreview) {
      return;
    }
    e === null || e === void 0 ? void 0 : e.preventDefault();
    return onPreview(file);
  };
  var onInternalDownload = function onInternalDownload(file) {
    if (typeof onDownload === 'function') {
      onDownload(file);
    } else if (file.url) {
      window.open(file.url);
    }
  };
  var onInternalClose = function onInternalClose(file) {
    onRemove === null || onRemove === void 0 ? void 0 : onRemove(file);
  };
  var internalIconRender = function internalIconRender(file) {
    if (iconRender) {
      return iconRender(file, listType);
    }
    var isLoading = file.status === 'uploading';
    var fileIcon = isImgUrl && isImgUrl(file) ? /*#__PURE__*/React__namespace.createElement(PictureTwoTone$1, null) : /*#__PURE__*/React__namespace.createElement(FileTwoTone$1, null);
    var icon = isLoading ? /*#__PURE__*/React__namespace.createElement(LoadingOutlined$1, null) : /*#__PURE__*/React__namespace.createElement(PaperClipOutlined$1, null);
    if (listType === 'picture') {
      icon = isLoading ? /*#__PURE__*/React__namespace.createElement(LoadingOutlined$1, null) : fileIcon;
    } else if (listType === 'picture-card') {
      icon = isLoading ? locale.uploading : fileIcon;
    }
    return icon;
  };
  var actionIconRender = function actionIconRender(customIcon, callback, prefixCls, title) {
    var btnProps = {
      type: 'text',
      size: 'small',
      title: title,
      disabled: disabled,
      onClick: function onClick(e) {
        callback();
        if (isValidElement(customIcon) && customIcon.props.onClick) {
          customIcon.props.onClick(e);
        }
      },
      className: "".concat(prefixCls, "-list-item-card-actions-btn")
    };
    if (isValidElement(customIcon)) {
      var btnIcon = cloneElement(customIcon, _extends(_extends({}, customIcon.props), {
        onClick: function onClick() {}
      }));
      return /*#__PURE__*/React__namespace.createElement(Button$1, _extends({}, btnProps, {
        icon: btnIcon
      }));
    }
    return /*#__PURE__*/React__namespace.createElement(Button$1, _extends({}, btnProps), /*#__PURE__*/React__namespace.createElement("span", null, customIcon));
  };
  // ============================== Ref ===============================
  // Test needs
  React__namespace.useImperativeHandle(ref, function () {
    return {
      handlePreview: onInternalPreview,
      handleDownload: onInternalDownload
    };
  });
  var _React$useContext = React__namespace.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction;
  // ============================= Render =============================
  var prefixCls = getPrefixCls('upload', customizePrefixCls);
  var listClassNames = classNames((_classNames = {}, _defineProperty$1(_classNames, "".concat(prefixCls, "-list"), true), _defineProperty$1(_classNames, "".concat(prefixCls, "-list-").concat(listType), true), _defineProperty$1(_classNames, "".concat(prefixCls, "-list-rtl"), direction === 'rtl'), _classNames));
  // >>> Motion config
  var motionKeyList = _toConsumableArray(items.map(function (file) {
    return {
      key: file.uid,
      file: file
    };
  }));
  var animationDirection = listType === 'picture-card' ? 'animate-inline' : 'animate';
  // const transitionName = list.length === 0 ? '' : `${prefixCls}-${animationDirection}`;
  var motionConfig = {
    motionDeadline: 2000,
    motionName: "".concat(prefixCls, "-").concat(animationDirection),
    keys: motionKeyList,
    motionAppear: motionAppear
  };
  if (listType !== 'picture-card') {
    motionConfig = _extends(_extends({}, listItemMotion), motionConfig);
  }
  return /*#__PURE__*/React__namespace.createElement("div", {
    className: listClassNames
  }, /*#__PURE__*/React__namespace.createElement(CSSMotionList, _extends({}, motionConfig, {
    component: false
  }), function (_ref) {
    var key = _ref.key,
      file = _ref.file,
      motionClassName = _ref.className,
      motionStyle = _ref.style;
    return /*#__PURE__*/React__namespace.createElement(ListItem$1, {
      key: key,
      locale: locale,
      prefixCls: prefixCls,
      className: motionClassName,
      style: motionStyle,
      file: file,
      items: items,
      progress: progress,
      listType: listType,
      isImgUrl: isImgUrl,
      showPreviewIcon: showPreviewIcon,
      showRemoveIcon: showRemoveIcon,
      showDownloadIcon: showDownloadIcon,
      removeIcon: removeIcon,
      previewIcon: previewIcon,
      downloadIcon: downloadIcon,
      iconRender: internalIconRender,
      actionIconRender: actionIconRender,
      itemRender: itemRender,
      onPreview: onInternalPreview,
      onDownload: onInternalDownload,
      onClose: onInternalClose
    });
  }), appendAction && /*#__PURE__*/React__namespace.createElement(CSSMotion, _extends({}, motionConfig, {
    visible: appendActionVisible,
    forceRender: true
  }), function (_ref2) {
    var motionClassName = _ref2.className,
      motionStyle = _ref2.style;
    return cloneElement(appendAction, function (oriProps) {
      return {
        className: classNames(oriProps.className, motionClassName),
        style: _extends(_extends(_extends({}, motionStyle), {
          // prevent the element has hover css pseudo-class that may cause animation to end prematurely.
          pointerEvents: motionClassName ? 'none' : undefined
        }), oriProps.style)
      };
    });
  }));
};
var UploadList = /*#__PURE__*/React__namespace.forwardRef(InternalUploadList);
if (process.env.NODE_ENV !== 'production') {
  UploadList.displayName = 'UploadList';
}
var UploadList$1 = UploadList;

var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var LIST_IGNORE = "__LIST_IGNORE_".concat(Date.now(), "__");
var InternalUpload = function InternalUpload(props, ref) {
  var _classNames2;
  var fileList = props.fileList,
    defaultFileList = props.defaultFileList,
    onRemove = props.onRemove,
    _props$showUploadList = props.showUploadList,
    showUploadList = _props$showUploadList === void 0 ? true : _props$showUploadList,
    _props$listType = props.listType,
    listType = _props$listType === void 0 ? 'text' : _props$listType,
    onPreview = props.onPreview,
    onDownload = props.onDownload,
    onChange = props.onChange,
    onDrop = props.onDrop,
    previewFile = props.previewFile,
    customDisabled = props.disabled,
    propLocale = props.locale,
    iconRender = props.iconRender,
    isImageUrl = props.isImageUrl,
    progress = props.progress,
    customizePrefixCls = props.prefixCls,
    className = props.className,
    _props$type = props.type,
    type = _props$type === void 0 ? 'select' : _props$type,
    children = props.children,
    style = props.style,
    itemRender = props.itemRender,
    maxCount = props.maxCount,
    _props$data = props.data,
    data = _props$data === void 0 ? {} : _props$data,
    _props$multiple = props.multiple,
    multiple = _props$multiple === void 0 ? false : _props$multiple,
    _props$action = props.action,
    action = _props$action === void 0 ? '' : _props$action,
    _props$accept = props.accept,
    accept = _props$accept === void 0 ? '' : _props$accept,
    _props$supportServerR = props.supportServerRender,
    supportServerRender = _props$supportServerR === void 0 ? true : _props$supportServerR;
  // ===================== Disabled =====================
  var disabled = React__namespace.useContext(DisabledContext$1);
  var mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
  var _useMergedState = useMergedState(defaultFileList || [], {
      value: fileList,
      postState: function postState(list) {
        return list !== null && list !== void 0 ? list : [];
      }
    }),
    _useMergedState2 = _slicedToArray(_useMergedState, 2),
    mergedFileList = _useMergedState2[0],
    setMergedFileList = _useMergedState2[1];
  var _React$useState = React__namespace.useState('drop'),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    dragState = _React$useState2[0],
    setDragState = _React$useState2[1];
  var upload = React__namespace.useRef(null);
  process.env.NODE_ENV !== "production" ? warning$2('fileList' in props || !('value' in props), 'Upload', '`value` is not a valid prop, do you mean `fileList`?') : void 0;
  process.env.NODE_ENV !== "production" ? warning$2(!('transformFile' in props), 'Upload', '`transformFile` is deprecated. Please use `beforeUpload` directly.') : void 0;
  // Control mode will auto fill file uid if not provided
  React__namespace.useMemo(function () {
    var timestamp = Date.now();
    (fileList || []).forEach(function (file, index) {
      if (!file.uid && !Object.isFrozen(file)) {
        file.uid = "__AUTO__".concat(timestamp, "_").concat(index, "__");
      }
    });
  }, [fileList]);
  var onInternalChange = function onInternalChange(file, changedFileList, event) {
    var cloneList = _toConsumableArray(changedFileList);
    // Cut to match count
    if (maxCount === 1) {
      cloneList = cloneList.slice(-1);
    } else if (maxCount) {
      cloneList = cloneList.slice(0, maxCount);
    }
    // Prevent React18 auto batch since input[upload] trigger process at same time
    // which makes fileList closure problem
    ReactDOM.flushSync(function () {
      setMergedFileList(cloneList);
    });
    var changeInfo = {
      file: file,
      fileList: cloneList
    };
    if (event) {
      changeInfo.event = event;
    }
    ReactDOM.flushSync(function () {
      onChange === null || onChange === void 0 ? void 0 : onChange(changeInfo);
    });
  };
  var mergedBeforeUpload = function mergedBeforeUpload(file, fileListArgs) {
    return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var beforeUpload, transformFile, parsedFile, result;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            beforeUpload = props.beforeUpload, transformFile = props.transformFile;
            parsedFile = file;
            if (!beforeUpload) {
              _context.next = 13;
              break;
            }
            _context.next = 5;
            return beforeUpload(file, fileListArgs);
          case 5:
            result = _context.sent;
            if (!(result === false)) {
              _context.next = 8;
              break;
            }
            return _context.abrupt("return", false);
          case 8:
            // Hack for LIST_IGNORE, we add additional info to remove from the list
            delete file[LIST_IGNORE];
            if (!(result === LIST_IGNORE)) {
              _context.next = 12;
              break;
            }
            Object.defineProperty(file, LIST_IGNORE, {
              value: true,
              configurable: true
            });
            return _context.abrupt("return", false);
          case 12:
            if (_typeof$1(result) === 'object' && result) {
              parsedFile = result;
            }
          case 13:
            if (!transformFile) {
              _context.next = 17;
              break;
            }
            _context.next = 16;
            return transformFile(parsedFile);
          case 16:
            parsedFile = _context.sent;
          case 17:
            return _context.abrupt("return", parsedFile);
          case 18:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
  };
  var onBatchStart = function onBatchStart(batchFileInfoList) {
    // Skip file which marked as `LIST_IGNORE`, these file will not add to file list
    var filteredFileInfoList = batchFileInfoList.filter(function (info) {
      return !info.file[LIST_IGNORE];
    });
    // Nothing to do since no file need upload
    if (!filteredFileInfoList.length) {
      return;
    }
    var objectFileList = filteredFileInfoList.map(function (info) {
      return file2Obj(info.file);
    });
    // Concat new files with prev files
    var newFileList = _toConsumableArray(mergedFileList);
    objectFileList.forEach(function (fileObj) {
      // Replace file if exist
      newFileList = updateFileList(fileObj, newFileList);
    });
    objectFileList.forEach(function (fileObj, index) {
      // Repeat trigger `onChange` event for compatible
      var triggerFileObj = fileObj;
      if (!filteredFileInfoList[index].parsedFile) {
        // `beforeUpload` return false
        var originFileObj = fileObj.originFileObj;
        var clone;
        try {
          clone = new File([originFileObj], originFileObj.name, {
            type: originFileObj.type
          });
        } catch (e) {
          clone = new Blob([originFileObj], {
            type: originFileObj.type
          });
          clone.name = originFileObj.name;
          clone.lastModifiedDate = new Date();
          clone.lastModified = new Date().getTime();
        }
        clone.uid = fileObj.uid;
        triggerFileObj = clone;
      } else {
        // Inject `uploading` status
        fileObj.status = 'uploading';
      }
      onInternalChange(triggerFileObj, newFileList);
    });
  };
  var onSuccess = function onSuccess(response, file, xhr) {
    try {
      if (typeof response === 'string') {
        response = JSON.parse(response);
      }
    } catch (e) {
      /* do nothing */
    }
    // removed
    if (!getFileItem(file, mergedFileList)) {
      return;
    }
    var targetItem = file2Obj(file);
    targetItem.status = 'done';
    targetItem.percent = 100;
    targetItem.response = response;
    targetItem.xhr = xhr;
    var nextFileList = updateFileList(targetItem, mergedFileList);
    onInternalChange(targetItem, nextFileList);
  };
  var onProgress = function onProgress(e, file) {
    // removed
    if (!getFileItem(file, mergedFileList)) {
      return;
    }
    var targetItem = file2Obj(file);
    targetItem.status = 'uploading';
    targetItem.percent = e.percent;
    var nextFileList = updateFileList(targetItem, mergedFileList);
    onInternalChange(targetItem, nextFileList, e);
  };
  var onError = function onError(error, response, file) {
    // removed
    if (!getFileItem(file, mergedFileList)) {
      return;
    }
    var targetItem = file2Obj(file);
    targetItem.error = error;
    targetItem.response = response;
    targetItem.status = 'error';
    var nextFileList = updateFileList(targetItem, mergedFileList);
    onInternalChange(targetItem, nextFileList);
  };
  var handleRemove = function handleRemove(file) {
    var currentFile;
    Promise.resolve(typeof onRemove === 'function' ? onRemove(file) : onRemove).then(function (ret) {
      var _a;
      // Prevent removing file
      if (ret === false) {
        return;
      }
      var removedFileList = removeFileItem(file, mergedFileList);
      if (removedFileList) {
        currentFile = _extends(_extends({}, file), {
          status: 'removed'
        });
        mergedFileList === null || mergedFileList === void 0 ? void 0 : mergedFileList.forEach(function (item) {
          var matchKey = currentFile.uid !== undefined ? 'uid' : 'name';
          if (item[matchKey] === currentFile[matchKey] && !Object.isFrozen(item)) {
            item.status = 'removed';
          }
        });
        (_a = upload.current) === null || _a === void 0 ? void 0 : _a.abort(currentFile);
        onInternalChange(currentFile, removedFileList);
      }
    });
  };
  var onFileDrop = function onFileDrop(e) {
    setDragState(e.type);
    if (e.type === 'drop') {
      onDrop === null || onDrop === void 0 ? void 0 : onDrop(e);
    }
  };
  // Test needs
  React__namespace.useImperativeHandle(ref, function () {
    return {
      onBatchStart: onBatchStart,
      onSuccess: onSuccess,
      onProgress: onProgress,
      onError: onError,
      fileList: mergedFileList,
      upload: upload.current
    };
  });
  var _React$useContext = React__namespace.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction;
  var prefixCls = getPrefixCls('upload', customizePrefixCls);
  var rcUploadProps = _extends(_extends({
    onBatchStart: onBatchStart,
    onError: onError,
    onProgress: onProgress,
    onSuccess: onSuccess
  }, props), {
    data: data,
    multiple: multiple,
    action: action,
    accept: accept,
    supportServerRender: supportServerRender,
    prefixCls: prefixCls,
    disabled: mergedDisabled,
    beforeUpload: mergedBeforeUpload,
    onChange: undefined
  });
  delete rcUploadProps.className;
  delete rcUploadProps.style;
  // Remove id to avoid open by label when trigger is hidden
  // !children: https://github.com/ant-design/ant-design/issues/14298
  // disabled: https://github.com/ant-design/ant-design/issues/16478
  //           https://github.com/ant-design/ant-design/issues/24197
  if (!children || mergedDisabled) {
    delete rcUploadProps.id;
  }
  var renderUploadList = function renderUploadList(button, buttonVisible) {
    return showUploadList ? /*#__PURE__*/React__namespace.createElement(LocaleReceiver$1, {
      componentName: 'Upload',
      defaultLocale: defaultLocale.Upload
    }, function (contextLocale) {
      var _ref = typeof showUploadList === 'boolean' ? {} : showUploadList,
        showRemoveIcon = _ref.showRemoveIcon,
        showPreviewIcon = _ref.showPreviewIcon,
        showDownloadIcon = _ref.showDownloadIcon,
        removeIcon = _ref.removeIcon,
        previewIcon = _ref.previewIcon,
        downloadIcon = _ref.downloadIcon;
      return /*#__PURE__*/React__namespace.createElement(UploadList$1, {
        prefixCls: prefixCls,
        listType: listType,
        items: mergedFileList,
        previewFile: previewFile,
        onPreview: onPreview,
        onDownload: onDownload,
        onRemove: handleRemove,
        showRemoveIcon: !mergedDisabled && showRemoveIcon,
        showPreviewIcon: showPreviewIcon,
        showDownloadIcon: showDownloadIcon,
        removeIcon: removeIcon,
        previewIcon: previewIcon,
        downloadIcon: downloadIcon,
        iconRender: iconRender,
        locale: _extends(_extends({}, contextLocale), propLocale),
        isImageUrl: isImageUrl,
        progress: progress,
        appendAction: button,
        appendActionVisible: buttonVisible,
        itemRender: itemRender,
        disabled: mergedDisabled
      });
    }) : button;
  };
  if (type === 'drag') {
    var _classNames;
    var dragCls = classNames(prefixCls, (_classNames = {}, _defineProperty$1(_classNames, "".concat(prefixCls, "-drag"), true), _defineProperty$1(_classNames, "".concat(prefixCls, "-drag-uploading"), mergedFileList.some(function (file) {
      return file.status === 'uploading';
    })), _defineProperty$1(_classNames, "".concat(prefixCls, "-drag-hover"), dragState === 'dragover'), _defineProperty$1(_classNames, "".concat(prefixCls, "-disabled"), mergedDisabled), _defineProperty$1(_classNames, "".concat(prefixCls, "-rtl"), direction === 'rtl'), _classNames), className);
    return /*#__PURE__*/React__namespace.createElement("span", null, /*#__PURE__*/React__namespace.createElement("div", {
      className: dragCls,
      onDrop: onFileDrop,
      onDragOver: onFileDrop,
      onDragLeave: onFileDrop,
      style: style
    }, /*#__PURE__*/React__namespace.createElement(Upload$3, _extends({}, rcUploadProps, {
      ref: upload,
      className: "".concat(prefixCls, "-btn")
    }), /*#__PURE__*/React__namespace.createElement("div", {
      className: "".concat(prefixCls, "-drag-container")
    }, children))), renderUploadList());
  }
  var uploadButtonCls = classNames(prefixCls, (_classNames2 = {}, _defineProperty$1(_classNames2, "".concat(prefixCls, "-select"), true), _defineProperty$1(_classNames2, "".concat(prefixCls, "-select-").concat(listType), true), _defineProperty$1(_classNames2, "".concat(prefixCls, "-disabled"), mergedDisabled), _defineProperty$1(_classNames2, "".concat(prefixCls, "-rtl"), direction === 'rtl'), _classNames2));
  var renderUploadButton = function renderUploadButton(uploadButtonStyle) {
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: uploadButtonCls,
      style: uploadButtonStyle
    }, /*#__PURE__*/React__namespace.createElement(Upload$3, _extends({}, rcUploadProps, {
      ref: upload
    })));
  };
  var uploadButton = renderUploadButton(children ? undefined : {
    display: 'none'
  });
  if (listType === 'picture-card') {
    return /*#__PURE__*/React__namespace.createElement("span", {
      className: classNames("".concat(prefixCls, "-picture-card-wrapper"), className)
    }, renderUploadList(uploadButton, !!children));
  }
  return /*#__PURE__*/React__namespace.createElement("span", {
    className: className
  }, uploadButton, renderUploadList());
};
var Upload$2 = /*#__PURE__*/React__namespace.forwardRef(InternalUpload);
if (process.env.NODE_ENV !== 'production') {
  Upload$2.displayName = 'Upload';
}
var InternalUpload$1 = Upload$2;

var __rest$2 = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var Dragger$1 = /*#__PURE__*/React__namespace.forwardRef(function (_a, ref) {
  var style = _a.style,
    height = _a.height,
    restProps = __rest$2(_a, ["style", "height"]);
  return /*#__PURE__*/React__namespace.createElement(InternalUpload$1, _extends({
    ref: ref
  }, restProps, {
    type: "drag",
    style: _extends(_extends({}, style), {
      height: height
    })
  }));
});
if (process.env.NODE_ENV !== 'production') {
  Dragger$1.displayName = 'Dragger';
}
var Dragger$2 = Dragger$1;

var Upload = InternalUpload$1;
Upload.Dragger = Dragger$2;
Upload.LIST_IGNORE = LIST_IGNORE;
var Upload$1 = Upload;

var DefaultContext = {
  color: undefined,
  size: undefined,
  className: undefined,
  style: undefined,
  attr: undefined
};
var IconContext = React.createContext && React.createContext(DefaultContext);

var __assign$1 = undefined && undefined.__assign || function () {
  __assign$1 = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign$1.apply(this, arguments);
};
var __rest$1 = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
function Tree2Element(tree) {
  return tree && tree.map(function (node, i) {
    return React.createElement(node.tag, __assign$1({
      key: i
    }, node.attr), Tree2Element(node.child));
  });
}
function GenIcon(data) {
  // eslint-disable-next-line react/display-name
  return function (props) {
    return React.createElement(IconBase, __assign$1({
      attr: __assign$1({}, data.attr)
    }, props), Tree2Element(data.child));
  };
}
function IconBase(props) {
  var elem = function (conf) {
    var attr = props.attr,
      size = props.size,
      title = props.title,
      svgProps = __rest$1(props, ["attr", "size", "title"]);
    var computedSize = size || conf.size || "1em";
    var className;
    if (conf.className) className = conf.className;
    if (props.className) className = (className ? className + " " : "") + props.className;
    return React.createElement("svg", __assign$1({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, conf.attr, attr, svgProps, {
      className: className,
      style: __assign$1(__assign$1({
        color: props.color || conf.color
      }, conf.style), props.style),
      height: computedSize,
      width: computedSize,
      xmlns: "http://www.w3.org/2000/svg"
    }), title && React.createElement("title", null, title), props.children);
  };
  return IconContext !== undefined ? React.createElement(IconContext.Consumer, null, function (conf) {
    return elem(conf);
  }) : elem(DefaultContext);
}

// THIS FILE IS AUTO GENERATED
function AiFillCheckCircle (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 1024 1024"},"child":[{"tag":"path","attr":{"d":"M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 0 1-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z"}}]})(props);
}function AiFillCloseCircle (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 1024 1024"},"child":[{"tag":"path","attr":{"d":"M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm165.4 618.2l-66-.3L512 563.4l-99.3 118.4-66.1.3c-4.4 0-8-3.5-8-8 0-1.9.7-3.7 1.9-5.2l130.1-155L340.5 359a8.32 8.32 0 0 1-1.9-5.2c0-4.4 3.6-8 8-8l66.1.3L512 464.6l99.3-118.4 66-.3c4.4 0 8 3.5 8 8 0 1.9-.7 3.7-1.9 5.2L553.5 514l130 155c1.2 1.5 1.9 3.3 1.9 5.2 0 4.4-3.6 8-8 8z"}}]})(props);
}function AiFillFileAdd (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 1024 1024"},"child":[{"tag":"path","attr":{"d":"M480 580H372a8 8 0 0 0-8 8v48a8 8 0 0 0 8 8h108v108a8 8 0 0 0 8 8h48a8 8 0 0 0 8-8V644h108a8 8 0 0 0 8-8v-48a8 8 0 0 0-8-8H544V472a8 8 0 0 0-8-8h-48a8 8 0 0 0-8 8v108zm374.6-291.3c6 6 9.4 14.1 9.4 22.6V928c0 17.7-14.3 32-32 32H192c-17.7 0-32-14.3-32-32V96c0-17.7 14.3-32 32-32h424.7c8.5 0 16.7 3.4 22.7 9.4l215.2 215.3zM790.2 326L602 137.8V326h188.2z"}}]})(props);
}function AiOutlineMinus (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 1024 1024"},"child":[{"tag":"path","attr":{"d":"M872 474H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h720c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z"}}]})(props);
}function AiOutlinePlus (props) {
  return GenIcon({"tag":"svg","attr":{"t":"1551322312294","style":"","viewBox":"0 0 1024 1024","version":"1.1"},"child":[{"tag":"defs","attr":{},"child":[]},{"tag":"path","attr":{"d":"M474 152m8 0l60 0q8 0 8 8l0 704q0 8-8 8l-60 0q-8 0-8-8l0-704q0-8 8-8Z"}},{"tag":"path","attr":{"d":"M168 474m8 0l672 0q8 0 8 8l0 60q0 8-8 8l-672 0q-8 0-8-8l0-60q0-8 8-8Z"}}]})(props);
}

async function postImage(data, config) {
    try {
        const res = axios.post("https://api.escuelajs.co/api/v1/files/upload", data, config);
        return res;
    }
    catch (error) {
        throw error;
    }
}

// THIS FILE IS AUTO GENERATED
function BiX (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24"},"child":[{"tag":"path","attr":{"d":"m16.192 6.344-4.243 4.242-4.242-4.242-1.414 1.414L10.535 12l-4.242 4.242 1.414 1.414 4.242-4.242 4.243 4.242 1.414-1.414L13.364 12l4.242-4.242z"}}]})(props);
}

const Dragger = Upload$1.Dragger;
function UploadDragger({ allowMultiple = false, spacingLeft = 0, editor }) {
    const [fileList, setFileList] = React.useState([]);
    const imImageListRef = React.useRef([]);
    const imageList = Recoil_index_20(imageListAtom);
    const setShowUploadDragger = Recoil_index_24(showUploadDraggerAtom);
    const props = ({
        name: 'file',
        multiple: allowMultiple,
        maxCount: allowMultiple ? Infinity : 1,
        customRequest: async (options) => {
            const { onSuccess, onError, file, onProgress } = options;
            const fmData = new FormData();
            const config = {
                headers: { "content-type": "multipart/form-data" },
                onUploadProgress: (event) => {
                    const percent = Math.floor((event.loaded / event.total) * 100);
                    onProgress && onProgress({ percent });
                }
            };
            fmData.append("file", file);
            try {
                const res = await postImage(fmData, config);
                imImageListRef.current = [...imImageListRef.current, { src: res.data.location, id: uuidv4(), name: res.data.originalname }];
                onSuccess && onSuccess("Ok");
            }
            catch (err) {
                console.log("Eroor: ", err);
                onError && onError({ err });
            }
        },
        itemRender: (originNode, file, currFileList, actions) => {
            setFileList(currFileList);
            const percent = file.percent;
            const status = file.status;
            return (jsxRuntimeExports.jsx("div", { className: `item ${status === "done" && "success"} ${status === "error" && "error"} ${status === "uploading" && "progress"}`, children: jsxRuntimeExports.jsxs("div", { className: "content", children: [jsxRuntimeExports.jsxs("div", { className: "meta", children: [jsxRuntimeExports.jsx("span", { children: file.name }), ["uploading"].includes(status) && jsxRuntimeExports.jsxs("span", { children: [percent, "%"] }), status === "error" && jsxRuntimeExports.jsx(AiFillCloseCircle, { cursor: "pointer", onClick: () => actions.remove(), size: 20 }), status === "done" && jsxRuntimeExports.jsx(AiFillCheckCircle, { size: 20 })] }), ["uploading"].includes(status) && jsxRuntimeExports.jsx(Progress$1, { percent: percent, strokeColor: 'rgb(66, 72, 255)', trailColor: "white", showInfo: false })] }) }));
        }
    });
    const handleSubmit = (e) => {
        e.stopPropagation();
        if (isUploading || !isSuccess)
            return;
        const editorState = allowMultiple ? imImageListRef.current.map(imImage => ({ image: imImage, boxes: [] })) : [{ image: imImageListRef.current.at(-1), boxes: [] }];
        editor.importEditorState(editorState).then(() => {
            editor.loadImage(editor.images[0]);
        });
        setShowUploadDragger(false);
    };
    const handleClose = (e) => {
        e.stopPropagation();
        setShowUploadDragger(false);
    };
    const isUploading = fileList.find(file => file.status === 'uploading');
    const isSuccess = fileList.find(file => file.status === "done");
    return (jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsx("div", { className: "upload-dragger", style: { width: `calc(100% - ${spacingLeft}px)`, left: spacingLeft }, children: jsxRuntimeExports.jsx("div", { className: "container", children: jsxRuntimeExports.jsxs(Dragger, { ...props, children: [jsxRuntimeExports.jsxs("div", { className: `inner-container ${fileList.length && "mini"}`, children: [imageList.length ? jsxRuntimeExports.jsx(BiX, { cursor: 'pointer', className: "close", size: 25, onClick: handleClose }) : "", jsxRuntimeExports.jsx(AiFillFileAdd, { color: "rgb(66, 72, 255)", size: 50 }), allowMultiple ? jsxRuntimeExports.jsx("span", { children: "Select Files to Upload" }) : jsxRuntimeExports.jsx("span", { children: "Select a File to Upload" }), allowMultiple ? jsxRuntimeExports.jsx("p", { children: "or Drag and Drop, Copy and Paste Files here" }) : jsxRuntimeExports.jsx("p", { children: "or Drag and Drop, Copy and Pase a File here" })] }), fileList.length ? jsxRuntimeExports.jsxs("div", { className: `submit`, children: [" ", jsxRuntimeExports.jsx("button", { className: `save  ${(isUploading || !isSuccess) ? 'disable' : ""}`, onClick: handleSubmit, children: "Submit " }), " "] }) : jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {})] }) }) }) }));
}

// THIS FILE IS AUTO GENERATED
function BsArrowRight (props) {
  return GenIcon({"tag":"svg","attr":{"fill":"currentColor","viewBox":"0 0 16 16"},"child":[{"tag":"path","attr":{"fillRule":"evenodd","d":"M1 8a.5.5 0 0 1 .5-.5h11.793l-3.147-3.146a.5.5 0 0 1 .708-.708l4 4a.5.5 0 0 1 0 .708l-4 4a.5.5 0 0 1-.708-.708L13.293 8.5H1.5A.5.5 0 0 1 1 8z"}}]})(props);
}function BsBoundingBox (props) {
  return GenIcon({"tag":"svg","attr":{"fill":"currentColor","viewBox":"0 0 16 16"},"child":[{"tag":"path","attr":{"d":"M5 2V0H0v5h2v6H0v5h5v-2h6v2h5v-5h-2V5h2V0h-5v2H5zm6 1v2h2v6h-2v2H5v-2H3V5h2V3h6zm1-2h3v3h-3V1zm3 11v3h-3v-3h3zM4 15H1v-3h3v3zM1 4V1h3v3H1z"}}]})(props);
}function BsBrightnessHigh (props) {
  return GenIcon({"tag":"svg","attr":{"fill":"currentColor","viewBox":"0 0 16 16"},"child":[{"tag":"path","attr":{"d":"M8 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0 1a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"}}]})(props);
}function BsChevronLeft (props) {
  return GenIcon({"tag":"svg","attr":{"fill":"currentColor","viewBox":"0 0 16 16"},"child":[{"tag":"path","attr":{"fillRule":"evenodd","d":"M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"}}]})(props);
}function BsChevronRight (props) {
  return GenIcon({"tag":"svg","attr":{"fill":"currentColor","viewBox":"0 0 16 16"},"child":[{"tag":"path","attr":{"fillRule":"evenodd","d":"M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"}}]})(props);
}

function TopActionBar({ editor, step, onContinue, onSave }) {
    const activeImage = Recoil_index_20(activeImageAtom);
    const handlePagination = (action) => () => {
        if (!activeImage)
            return;
        const currentIndex = editor.images.findIndex(image => image.id() === activeImage.id());
        let image = null;
        if (action === "prev")
            image = editor.images[(currentIndex - 1 + editor.images.length) % editor.images.length];
        else if (action === "next")
            image = editor.images[(currentIndex + 1) % editor.images.length];
        console.log(image, "MAGE");
        if (image) {
            editor.loadImage(image);
        }
    };
    const handleContinue = async () => {
        await onSave();
        onContinue();
    };
    const heading = step.split("_").join(" ");
    return (jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsxs("div", { className: "top-action-bar", children: [jsxRuntimeExports.jsx("span", { className: "heading", children: heading }), jsxRuntimeExports.jsx("div", { className: "pagination", children: activeImage?.name() ? (jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(BsChevronLeft, { cursor: "pointer", onClick: handlePagination("prev") }), activeImage.name().length > 25 ? activeImage.name().slice(0, 23) + "..." : activeImage.name(), jsxRuntimeExports.jsx(BsChevronRight, { cursor: "pointer", onClick: handlePagination("next") })] })) : "" }), jsxRuntimeExports.jsxs("div", { className: "button-group", children: [jsxRuntimeExports.jsx("button", { className: `outline`, onClick: onSave, children: "Save " }), jsxRuntimeExports.jsxs("button", { className: `primary`, onClick: handleContinue, children: ["Continue ", jsxRuntimeExports.jsx(BsArrowRight, { style: { fontWeight: 700 } }), " "] })] })] }) }));
}

function CircularCheckbox({ size = 20, style, checked = false }) {
    return (jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsx("div", { className: "circular-checkbox checked", style: { ...style, width: size, height: size }, children: checked && jsxRuntimeExports.jsx("div", { className: "checked", style: { width: size - 4, height: size - 4 } }) }) }));
}

function LeftSidebar({ editor }) {
    const imageList = Recoil_index_20(imageListAtom);
    const [showUploadDragger, setShowUploadDragger] = Recoil_index_22(showUploadDraggerAtom);
    const [searchKey, setSearchKey] = React.useState("");
    const activeImage = Recoil_index_20(activeImageAtom);
    const loadImage = (image) => () => {
        editor.loadImage(image);
    };
    console.log(imageList, "***");
    const filteredImages = imageList.filter(image => image.name().includes(searchKey));
    return (jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsxs("div", { className: "left-side-bar", children: [jsxRuntimeExports.jsx("span", { className: "heading", children: "Files" }), jsxRuntimeExports.jsxs("div", { className: "input-group", children: [jsxRuntimeExports.jsx("svg", { className: "icon", "aria-hidden": "true", viewBox: "0 0 24 24", children: jsxRuntimeExports.jsx("g", { children: jsxRuntimeExports.jsx("path", { d: "M21.53 20.47l-3.66-3.66C19.195 15.24 20 13.214 20 11c0-4.97-4.03-9-9-9s-9 4.03-9 9 4.03 9 9 9c2.215 0 4.24-.804 5.808-2.13l3.66 3.66c.147.146.34.22.53.22s.385-.073.53-.22c.295-.293.295-.767.002-1.06zM3.5 11c0-4.135 3.365-7.5 7.5-7.5s7.5 3.365 7.5 7.5-3.365 7.5-7.5 7.5-7.5-3.365-7.5-7.5z" }) }) }), jsxRuntimeExports.jsx("input", { placeholder: "Search File", value: searchKey, onChange: e => setSearchKey(e.target.value), type: "search", className: "input", autoFocus: true })] }), jsxRuntimeExports.jsx("div", { className: "button-group", children: jsxRuntimeExports.jsxs("button", { className: `search`, onClick: () => setShowUploadDragger(!showUploadDragger), children: [showUploadDragger && imageList.length !== 0 ? "Close" : "Upload", " "] }) }), jsxRuntimeExports.jsxs("div", { className: "converted-images-container", children: [jsxRuntimeExports.jsxs("div", { className: "item heading", children: [jsxRuntimeExports.jsx("div", { children: jsxRuntimeExports.jsx(CircularCheckbox, { size: 17 }) }), jsxRuntimeExports.jsx("span", { children: "Image" }), jsxRuntimeExports.jsx("span", { children: "Name" })] }), filteredImages.map(image => (jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsxs("div", { className: `item ${activeImage?.id() === image.id() ? "active" : ""}`, onClick: loadImage(image), children: [jsxRuntimeExports.jsx("div", { children: jsxRuntimeExports.jsx(CircularCheckbox, { checked: activeImage?.id() === image.id(), size: 15 }) }), jsxRuntimeExports.jsx("img", { src: image.src, width: 50, height: 40 }), jsxRuntimeExports.jsx("span", { children: image.name() })] }) }))), filteredImages.length === 0 ? (jsxRuntimeExports.jsx("div", { className: "no-item", children: "No Items" })) : ""] })] }) }));
}

// THIS FILE IS AUTO GENERATED
function IoMdReturnLeft (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 512 512"},"child":[{"tag":"path","attr":{"d":"M432.8 136v96H122.3l84.4-86.2-33.2-33.8L32 256l141.5 144 33.2-33.8-84.4-86.2H480V136h-47.2z"}}]})(props);
}

const padding = 10;
const modalWidthHeight = 320;
function AnnotationPopup({ editor, labelList, matchEmptyString = false, allowCustomLabels = false }) {
    const appMode = Recoil_index_20(appModeAtom);
    const [labelSearch, setLabelSearch] = React.useState({ key: "", allowFilter: true });
    const [position, setPosition] = React.useState(null);
    const [selectedLabel, setSelectedLabel] = React.useState(null);
    const [matchLables, setMatchLables] = React.useState([]);
    const inputRef = React.useRef(null);
    const listRef = React.useRef(null);
    const activeRef = React.useRef(null);
    React.useEffect(() => {
        if (!labelSearch.allowFilter)
            return;
        const matchClasses = ((labelSearch.key) === "" && !matchEmptyString) ? [] : labelList.filter(label => (textToHumanReadable(label || "")).includes(labelSearch.key.toUpperCase()));
        setMatchLables(matchClasses);
        setSelectedLabel(matchClasses.length ? 0 : null);
    }, [labelSearch]);
    React.useEffect(() => {
        if (!appMode || appMode.mode !== "EDIT_MODE")
            return;
        if (!appMode.visible) {
            setPosition(null);
            return;
        }
        const boxPosition = appMode.boxInEditMode.getClientRect();
        const boxWidth = appMode.boxInEditMode.getClientRect().width + padding;
        const x = boxPosition.x + boxWidth + modalWidthHeight > window.innerWidth ? boxPosition.x - modalWidthHeight : boxPosition.x + boxWidth;
        const y = (boxPosition.y + modalWidthHeight) > window.innerHeight ? boxPosition.y - ((boxPosition.y + modalWidthHeight) - window.innerHeight) : boxPosition.y;
        setPosition({ x, y });
    }, [appMode]);
    React.useEffect(() => {
        if (appMode.mode === "EDIT_MODE" && inputRef.current) {
            setLabelSearch({ key: textToHumanReadable(appMode.boxInEditMode.label), allowFilter: false });
            inputRef.current.select();
        }
    }, [appMode]);
    const updateLabel = (label) => {
        if (appMode.mode !== "EDIT_MODE")
            return;
        appMode.boxInEditMode.updateLabel(label);
        handleClose();
    };
    React.useEffect(() => {
        function keyDownEventHandler(event) {
            if (!inputRef.current)
                return;
            inputRef.current.focus();
            if (event.key === 'Enter') {
                handleSave();
            }
            else if (event.key === "ArrowDown" && selectedLabel !== null) {
                event.preventDefault();
                const newSelectedLabel = (selectedLabel + 1) % matchLables.length;
                setSelectedLabel(newSelectedLabel);
                setLabelSearch({ key: textToHumanReadable(matchLables[newSelectedLabel]), allowFilter: false });
            }
            else if (event.key === "ArrowUp" && selectedLabel !== null) {
                event.preventDefault();
                const newSelectedLabel = selectedLabel === 0 ? matchLables.length - 1 : selectedLabel - 1;
                setSelectedLabel(newSelectedLabel);
                setLabelSearch({ key: textToHumanReadable(matchLables[newSelectedLabel]), allowFilter: false });
            }
            else if (event.key === 'Escape') {
                handleClose();
            }
        }
        document.addEventListener('keydown', keyDownEventHandler);
        return () => document.removeEventListener('keydown', keyDownEventHandler);
    }, [appMode, selectedLabel, matchLables]);
    const scrollElementIntoViewWithinDiv = (element, div) => {
        const rect = element.getBoundingClientRect();
        const divRect = div.getBoundingClientRect();
        if (rect.top < divRect.top ||
            rect.bottom > divRect.bottom) {
            element.scrollIntoView({
                block: 'nearest'
            });
        }
    };
    React.useEffect(() => {
        if (selectedLabel === null)
            return;
        const span = activeRef.current;
        const parent = listRef.current;
        if (!span || !parent)
            return;
        scrollElementIntoViewWithinDiv(span, parent);
    }, [selectedLabel]);
    const textToHumanReadable = (text) => {
        return text.replaceAll("_", " ").toUpperCase();
    };
    if (appMode.mode !== 'EDIT_MODE' || !editor)
        return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
    const handleClose = () => {
        editor.setMode({ mode: "DRAWING_MODE" });
        setLabelSearch({ key: '', allowFilter: true });
        setSelectedLabel(null);
        setPosition(null);
    };
    const handleDelete = async () => {
        await new RemoveBoxAction({ box: appMode.boxInEditMode, actionsStore: appMode.boxInEditMode.image?.actionStore }).directExecute();
        handleClose();
    };
    const handleSave = () => {
        if (allowCustomLabels) {
            updateLabel(labelSearch.key);
        }
        else {
            selectedLabel !== null && updateLabel(matchLables[selectedLabel]);
        }
    };
    return (jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsxs("div", { className: "annotation-popup", style: position ? { top: position.y, left: position.x } : { display: 'none' }, children: [jsxRuntimeExports.jsxs("div", { className: "header", children: [jsxRuntimeExports.jsx("span", { children: "Annotation Editor" }), jsxRuntimeExports.jsx(BiX, { cursor: 'pointer', size: 22, onClick: handleClose })] }), jsxRuntimeExports.jsxs("div", { className: "content-container", children: [jsxRuntimeExports.jsxs("div", { className: "input-group", children: [jsxRuntimeExports.jsx("svg", { className: "icon", "aria-hidden": "true", viewBox: "0 0 24 24", children: jsxRuntimeExports.jsx("g", { children: jsxRuntimeExports.jsx("path", { d: "M21.53 20.47l-3.66-3.66C19.195 15.24 20 13.214 20 11c0-4.97-4.03-9-9-9s-9 4.03-9 9 4.03 9 9 9c2.215 0 4.24-.804 5.808-2.13l3.66 3.66c.147.146.34.22.53.22s.385-.073.53-.22c.295-.293.295-.767.002-1.06zM3.5 11c0-4.135 3.365-7.5 7.5-7.5s7.5 3.365 7.5 7.5-3.365 7.5-7.5 7.5-7.5-3.365-7.5-7.5z" }) }) }), jsxRuntimeExports.jsx("input", { ref: inputRef, placeholder: "Label", value: labelSearch.key, onChange: (e) => setLabelSearch({ key: e.target.value, allowFilter: true }), type: "text", className: "input", autoFocus: true })] }), jsxRuntimeExports.jsxs("div", { className: "button-group", children: [jsxRuntimeExports.jsx("button", { className: "delete", onClick: handleDelete, children: "Delete" }), jsxRuntimeExports.jsxs("button", { className: "save", onClick: handleSave, children: ["Save ", jsxRuntimeExports.jsx(IoMdReturnLeft, { size: 18 })] })] }), jsxRuntimeExports.jsx("div", { className: "divider" }), jsxRuntimeExports.jsx("div", { className: "list-options", ref: listRef, children: matchLables.length !== 0 ? (jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: matchLables.map((label, index) => (jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsx("span", { ref: (() => selectedLabel === index ? activeRef : null)(), onClick: () => { setSelectedLabel(index); updateLabel(label); }, className: `${selectedLabel === index ? "active" : ""}`, children: textToHumanReadable(label) }, `${label}_${index}`) }))) })) : (jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: !allowCustomLabels ? jsxRuntimeExports.jsx("p", { children: labelSearch.key === "" ? "Type a lable for this box." : "Try using different search key." }) : jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsxs("p", { style: { cursor: "pointer" }, onClick: handleSave, children: ["Create a new label \"", labelSearch.key, "\" "] }) }) })) })] })] }) }));
}

// THIS FILE IS AUTO GENERATED
function MdOutlineFitScreen (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24"},"child":[{"tag":"path","attr":{"fill":"none","d":"M0 0h24v24H0V0z"}},{"tag":"path","attr":{"d":"M6 16h12V8H6v8zm2-6h8v4H8v-4zm-4 5H2v3c0 1.1.9 2 2 2h3v-2H4v-3zm0-9h3V4H4c-1.1 0-2 .9-2 2v3h2V6zm16-2h-3v2h3v3h2V6c0-1.1-.9-2-2-2zm0 14h-3v2h3c1.1 0 2-.9 2-2v-3h-2v3z"}}]})(props);
}

// THIS FILE IS AUTO GENERATED
function LiaHandPaperSolid (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 32 32"},"child":[{"tag":"path","attr":{"d":"M 16 2 C 14.617188 2 13.46875 2.96875 13.125 4.25 C 12.773438 4.105469 12.402344 4 12 4 C 10.355469 4 9 5.355469 9 7 L 9 17.75 L 8.125 16.875 C 6.960938 15.710938 5.039063 15.710938 3.875 16.875 C 2.710938 18.039063 2.710938 19.960938 3.875 21.125 L 10.65625 27.90625 C 11.832031 29.078125 13.457031 30 15.375 30 L 20 30 C 23.855469 30 27 26.855469 27 23 L 27 11 C 27 9.355469 25.644531 8 24 8 C 23.648438 8 23.316406 8.074219 23 8.1875 L 23 7 C 23 5.355469 21.644531 4 20 4 C 19.597656 4 19.226563 4.105469 18.875 4.25 C 18.53125 2.96875 17.382813 2 16 2 Z M 16 4 C 16.566406 4 17 4.433594 17 5 L 17 15 L 19 15 L 19 7 C 19 6.433594 19.433594 6 20 6 C 20.566406 6 21 6.433594 21 7 L 21 15 L 23 15 L 23 11 C 23 10.433594 23.433594 10 24 10 C 24.566406 10 25 10.433594 25 11 L 25 23 C 25 25.773438 22.773438 28 20 28 L 15.375 28 C 14.101563 28 13.007813 27.378906 12.09375 26.46875 L 5.28125 19.71875 C 4.882813 19.320313 4.882813 18.679688 5.28125 18.28125 C 5.679688 17.882813 6.320313 17.882813 6.71875 18.28125 L 9.28125 20.875 L 11 22.59375 L 11 7 C 11 6.433594 11.433594 6 12 6 C 12.566406 6 13 6.433594 13 7 L 13 15 L 15 15 L 15 5 C 15 4.433594 15.433594 4 16 4 Z"}}]})(props);
}function LiaRedoAltSolid (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 32 32"},"child":[{"tag":"path","attr":{"d":"M 16 3 C 8.832031 3 3 8.832031 3 16 C 3 23.167969 8.832031 29 16 29 C 23.167969 29 29 23.167969 29 16 L 27 16 C 27 22.085938 22.085938 27 16 27 C 9.914063 27 5 22.085938 5 16 C 5 9.914063 9.914063 5 16 5 C 19.875 5 23.261719 6.984375 25.21875 10 L 20 10 L 20 12 L 28 12 L 28 4 L 26 4 L 26 7.71875 C 23.617188 4.84375 20.019531 3 16 3 Z"}}]})(props);
}function LiaUndoAltSolid (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 32 32"},"child":[{"tag":"path","attr":{"d":"M 16 3 C 12 3 8.4 4.7992187 6 7.6992188 L 6 4 L 4 4 L 4 12 L 12 12 L 12 10 L 6.8007812 10 C 8.8007812 7 12.1 5 16 5 C 22.1 5 27 9.9 27 16 C 27 22.1 22.1 27 16 27 C 9.9 27 5 22.1 5 16 L 3 16 C 3 23.2 8.8 29 16 29 C 23.2 29 29 23.2 29 16 C 29 8.8 23.2 3 16 3 z"}}]})(props);
}

function Toolbar({ editor }) {
    const appMode = Recoil_index_20(appModeAtom);
    const setMode = (mode) => () => {
        if (!editor || appMode.mode === "EDIT_MODE")
            return;
        editor.setMode(mode);
    };
    const zoomInOut = (deltaY) => () => {
        if (!editor)
            return;
        const centerPos = { x: (editor.width() - 300) / 2 + 300, y: (editor.height() - 55) / 2 + 55 };
        editor.zoomInOutStage({ deltaY, preventDefault: () => { }, ctrlKey: true }, centerPos, centerPos);
    };
    if (!editor)
        return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
    return (jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsxs("div", { className: "toolbar", children: [jsxRuntimeExports.jsx("div", { className: `item ${appMode.mode === 'DRAG_SELECTION_MODE' && "active"}`, onClick: setMode({ mode: "DRAG_SELECTION_MODE" }), children: jsxRuntimeExports.jsx(LiaHandPaperSolid, {}) }), jsxRuntimeExports.jsx("div", { className: `item ${appMode.mode === 'DRAWING_MODE' && "active"}`, onClick: setMode({ mode: "DRAWING_MODE" }), children: jsxRuntimeExports.jsx(BsBoundingBox, {}) }), jsxRuntimeExports.jsx("div", { className: "divider" }), jsxRuntimeExports.jsx("div", { className: "item", onClick: zoomInOut(0), children: jsxRuntimeExports.jsx(AiOutlinePlus, {}) }), jsxRuntimeExports.jsx("div", { className: "item", onClick: () => editor.fitToScreen(), children: jsxRuntimeExports.jsx(MdOutlineFitScreen, {}) }), jsxRuntimeExports.jsx("div", { className: "item", onClick: zoomInOut(1), children: jsxRuntimeExports.jsx(AiOutlineMinus, {}) }), jsxRuntimeExports.jsx("div", { className: "divider" }), jsxRuntimeExports.jsx("div", { className: "item", onClick: () => editor.activeImage?.actionStore.undo().catch((e) => console.log(e)), children: jsxRuntimeExports.jsx(LiaUndoAltSolid, {}) }), jsxRuntimeExports.jsx("div", { className: "item", onClick: () => editor.activeImage?.actionStore.redo().catch((e) => console.log(e)), children: jsxRuntimeExports.jsx(LiaRedoAltSolid, {}) }), jsxRuntimeExports.jsx("div", { className: "divider" }), jsxRuntimeExports.jsx("div", { className: "item", children: jsxRuntimeExports.jsx(BsBrightnessHigh, {}) })] }) }));
}

var cssUnit = {
    cm: true,
    mm: true,
    in: true,
    px: true,
    pt: true,
    pc: true,
    em: true,
    ex: true,
    ch: true,
    rem: true,
    vw: true,
    vh: true,
    vmin: true,
    vmax: true,
    "%": true,
};
/**
 * If size is a number, append px to the value as default unit.
 * If size is a string, validate against list of valid units.
 * If unit is valid, return size as is.
 * If unit is invalid, console warn issue, replace with px as the unit.
 *
 * @param {(number | string)} size
 * @return {LengthObject} LengthObject
 */
function parseLengthAndUnit(size) {
    if (typeof size === "number") {
        return {
            value: size,
            unit: "px",
        };
    }
    var value;
    var valueString = (size.match(/^[0-9.]*/) || "").toString();
    if (valueString.includes(".")) {
        value = parseFloat(valueString);
    }
    else {
        value = parseInt(valueString, 10);
    }
    var unit = (size.match(/[^0-9]*$/) || "").toString();
    if (cssUnit[unit]) {
        return {
            value: value,
            unit: unit,
        };
    }
    console.warn("React Spinners: ".concat(size, " is not a valid css value. Defaulting to ").concat(value, "px."));
    return {
        value: value,
        unit: "px",
    };
}
/**
 * Take value as an input and return valid css value
 *
 * @param {(number | string)} value
 * @return {string} valid css value
 */
function cssValue(value) {
    var lengthWithunit = parseLengthAndUnit(value);
    return "".concat(lengthWithunit.value).concat(lengthWithunit.unit);
}

var createAnimation = function (loaderName, frames, suffix) {
    var animationName = "react-spinners-".concat(loaderName, "-").concat(suffix);
    if (typeof window == "undefined" || !window.document) {
        return animationName;
    }
    var styleEl = document.createElement("style");
    document.head.appendChild(styleEl);
    var styleSheet = styleEl.sheet;
    var keyFrames = "\n    @keyframes ".concat(animationName, " {\n      ").concat(frames, "\n    }\n  ");
    if (styleSheet) {
        styleSheet.insertRule(keyFrames, 0);
    }
    return animationName;
};

var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var clip = createAnimation("ClipLoader", "0% {transform: rotate(0deg) scale(1)} 50% {transform: rotate(180deg) scale(0.8)} 100% {transform: rotate(360deg) scale(1)}", "clip");
function ClipLoader(_a) {
    var _b = _a.loading, loading = _b === void 0 ? true : _b, _c = _a.color, color = _c === void 0 ? "#000000" : _c, _d = _a.speedMultiplier, speedMultiplier = _d === void 0 ? 1 : _d, _e = _a.cssOverride, cssOverride = _e === void 0 ? {} : _e, _f = _a.size, size = _f === void 0 ? 35 : _f, additionalprops = __rest(_a, ["loading", "color", "speedMultiplier", "cssOverride", "size"]);
    var style = __assign({ background: "transparent !important", width: cssValue(size), height: cssValue(size), borderRadius: "100%", border: "2px solid", borderTopColor: color, borderBottomColor: "transparent", borderLeftColor: color, borderRightColor: color, display: "inline-block", animation: "".concat(clip, " ").concat(0.75 / speedMultiplier, "s 0s infinite linear"), animationFillMode: "both" }, cssOverride);
    if (!loading) {
        return null;
    }
    return React__namespace.createElement("span", __assign({ style: style }, additionalprops));
}

function ImageLoader({ spacingLeft = 0 }) {
    const LoaderSpinner = Recoil_index_20(loaderAtom);
    if (!LoaderSpinner.visible)
        return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
    return (jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsxs("div", { className: "image-loader-container", style: { width: `calc(100% - ${spacingLeft}px)`, left: spacingLeft }, children: [jsxRuntimeExports.jsx("span", { className: "title", children: LoaderSpinner.title }), jsxRuntimeExports.jsx("div", { className: "loader", children: jsxRuntimeExports.jsx(ClipLoader, { color: "rgb(66, 72, 255)" }) })] }) }));
}

const entityClassesMaster = [
    {
        "id": 587,
        "pid_entity_class": "air_filter",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 202,
        "pid_entity_class": "bidirectional_cotinuity_arrow",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 203,
        "pid_entity_class": "bio_probe",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 205,
        "pid_entity_class": "calibration_pot",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 590,
        "pid_entity_class": "Table",
        "pid_entity_type": 13,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 591,
        "pid_entity_class": "COMBINED_PRESSURE_VACUUM_RELIEF_VALVE",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 592,
        "pid_entity_class": "COWL",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 593,
        "pid_entity_class": "FLAME_TRAP",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 594,
        "pid_entity_class": "FLOW_NOZZLE",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 595,
        "pid_entity_class": "FLUSH_MOUNTED_VALVE",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 217,
        "pid_entity_class": "flat_bottom_eccentric_reducer",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 596,
        "pid_entity_class": "JACKETTED_VALVE",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 597,
        "pid_entity_class": "MIXING_VALVE",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 598,
        "pid_entity_class": "POSITIVE_DISPLACEMENT_METER",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 224,
        "pid_entity_class": "wafer_check_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 599,
        "pid_entity_class": "PROCESS_CONTINUATION",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 600,
        "pid_entity_class": "RECONFIGURABLE_PIPE",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 601,
        "pid_entity_class": "REMOVABLE_SPOOL",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 602,
        "pid_entity_class": "SEALED_TUNDISH",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 1,
        "pid_entity_class": "process_line",
        "pid_entity_type": 3,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 2,
        "pid_entity_class": "signal_line",
        "pid_entity_type": 4,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 3,
        "pid_entity_class": "main_process_line",
        "pid_entity_type": 3,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 4,
        "pid_entity_class": "secondary_process_line",
        "pid_entity_type": 4,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 5,
        "pid_entity_class": "electrical_signal_line",
        "pid_entity_type": 4,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 6,
        "pid_entity_class": "hydraulic_signal_line",
        "pid_entity_type": 4,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 8,
        "pid_entity_class": "data_signal_line",
        "pid_entity_type": 4,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 603,
        "pid_entity_class": "SIGHT_GLASS_WITH_FLOW_INDICATION",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 604,
        "pid_entity_class": "SPLIT_BUTTERFLY_VALVE",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 605,
        "pid_entity_class": "SPRAY_BALL",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 606,
        "pid_entity_class": "SPRING_LOADED_VALVE_THREE_WAY",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 607,
        "pid_entity_class": "THREE_WAY_VALVE_L_PORT",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 243,
        "pid_entity_class": "alarm_check_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 244,
        "pid_entity_class": "angle_valve_flow_to_close",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 245,
        "pid_entity_class": "angle_valve_flow_to_open",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 246,
        "pid_entity_class": "bellow",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 608,
        "pid_entity_class": "THREE_WAY_VALVE_T_PORT",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 249,
        "pid_entity_class": "box_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 251,
        "pid_entity_class": "cavity_ball_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 252,
        "pid_entity_class": "closed_service_drain",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 609,
        "pid_entity_class": "TURBINE_METER",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 254,
        "pid_entity_class": "foam_pourer",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 255,
        "pid_entity_class": "grade",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 256,
        "pid_entity_class": "hose_reel",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 257,
        "pid_entity_class": "hydrant_without_pumper_connection",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 258,
        "pid_entity_class": "injection_nozzle",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 259,
        "pid_entity_class": "inline_mixer",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 260,
        "pid_entity_class": "inline_sight_glass",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 261,
        "pid_entity_class": "monoblock",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 262,
        "pid_entity_class": "monoflange_dbb_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 263,
        "pid_entity_class": "monolithic_isolation_joint",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 264,
        "pid_entity_class": "oily_water_catch_basin",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 265,
        "pid_entity_class": "post_indicator_valve_in_pit",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 266,
        "pid_entity_class": "pulsation_dampener",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 267,
        "pid_entity_class": "ram_type_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 268,
        "pid_entity_class": "sample_cooler",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 610,
        "pid_entity_class": "UTILITY_STATION",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 611,
        "pid_entity_class": "WEIR",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 612,
        "pid_entity_class": "FLUME",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 632,
        "pid_entity_class": "HORIZONTAL_VESSEL_WITJH_BOOT",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 271,
        "pid_entity_class": "sprinkler",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 273,
        "pid_entity_class": "t_type_strainer",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 274,
        "pid_entity_class": "tie_in_point",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 275,
        "pid_entity_class": "trap_basic_symbol",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 588,
        "pid_entity_class": "off_or_on_page_connector_off_unit",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 307,
        "pid_entity_class": "orifice_plate",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": true
    },
    {
        "id": 280,
        "pid_entity_class": "hydraulic_motor_operated_valve_actuator",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 613,
        "pid_entity_class": "AXIAL_FLOW_FAN",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 614,
        "pid_entity_class": "BAG_FILTER",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 286,
        "pid_entity_class": "average",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 287,
        "pid_entity_class": "averaging_pitot_tube",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 288,
        "pid_entity_class": "bias",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 29,
        "pid_entity_class": "flexible_hose",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 33,
        "pid_entity_class": "quick_release_end_closure",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 34,
        "pid_entity_class": "steam_heat_traced_line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 36,
        "pid_entity_class": "spring_loaded_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 289,
        "pid_entity_class": "coriolis",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 290,
        "pid_entity_class": "diesel_motor",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 291,
        "pid_entity_class": "difference",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 292,
        "pid_entity_class": "divide",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 293,
        "pid_entity_class": "double_acting_actuator",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 615,
        "pid_entity_class": "BAYONET_HEATER",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 295,
        "pid_entity_class": "flow_instrument_general",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 296,
        "pid_entity_class": "function_logic_emergency_shutdown_system",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 297,
        "pid_entity_class": "high_limit",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 298,
        "pid_entity_class": "high_selection",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 299,
        "pid_entity_class": "instrument_function_on_local_panel",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 300,
        "pid_entity_class": "instrument_located_rear_of_local_panel",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 301,
        "pid_entity_class": "lamp_mounted_in_auxiliary_room",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 302,
        "pid_entity_class": "local_panel_mounted_lamp",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 303,
        "pid_entity_class": "low_limit",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 304,
        "pid_entity_class": "low_selection",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 305,
        "pid_entity_class": "motor_actuator",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 306,
        "pid_entity_class": "multiply",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 308,
        "pid_entity_class": "pneumatic_motor",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 309,
        "pid_entity_class": "positive_displacement_flow_totalizing_indicator",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 310,
        "pid_entity_class": "proportional",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 311,
        "pid_entity_class": "relief_rupture_disc",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 313,
        "pid_entity_class": "sum",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 314,
        "pid_entity_class": "target_type_sensor",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 315,
        "pid_entity_class": "ultrasonic_flow_meter",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 316,
        "pid_entity_class": "unit_control_panel",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 318,
        "pid_entity_class": "vortex_sensor",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": null,
        "isValve": null,
        "isReducer": null
    },
    {
        "id": 317,
        "pid_entity_class": "variable_area_meter",
        "pid_entity_type": 7,
        "dexpi_simple_label": "ProcessInstrumentationFunction",
        "dexpi_node_type": "ProcessInstrumentationFunction",
        "component_class": "ProcessInstrumentationFunction",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/ProcessInstrumentationFunction",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 276,
        "pid_entity_class": "valve_with_blind_or_plug",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 272,
        "pid_entity_class": "stope_check_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": true
    },
    {
        "id": 270,
        "pid_entity_class": "spring_loaded_quick_closing_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 269,
        "pid_entity_class": "slide_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 616,
        "pid_entity_class": "DOUBLE_TUBESHEET_EXCHANGER",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 617,
        "pid_entity_class": "FLAT_BLADE_TURBINE",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 618,
        "pid_entity_class": "HAND_TRUCK",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 619,
        "pid_entity_class": "INCLINED_TURBINE",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 620,
        "pid_entity_class": "JACKETED_CENTRIFUGAL_PUMP",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 621,
        "pid_entity_class": "MESH_FILTER",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 622,
        "pid_entity_class": "OIL_WATER_SEPARATOR",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 623,
        "pid_entity_class": "POSITIVE_DISPLACEMENT_COMPRESSOR",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 624,
        "pid_entity_class": "RECIPROCATING_PUMP_DIAPHRAGM",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 625,
        "pid_entity_class": "RECIPROCATING_PUMP_PISTON",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 626,
        "pid_entity_class": "SPIRAL_HEAT_EXCHANGER",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 627,
        "pid_entity_class": "STACK",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 628,
        "pid_entity_class": "VANE_PUMP",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 320,
        "pid_entity_class": "calibration_pot",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 322,
        "pid_entity_class": "eq",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 323,
        "pid_entity_class": "vertical_turbine_pump",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 589,
        "pid_entity_class": "scada_instrument",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 629,
        "pid_entity_class": "PROPELLER_FAN",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 630,
        "pid_entity_class": "AIR_DRIVEN_MOTOR",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 321,
        "pid_entity_class": "diaphgram_actuator",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 324,
        "pid_entity_class": "vertical_turbine_pump_enclosed_shaft_",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 49,
        "pid_entity_class": "angle_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": "AngleValve",
        "dexpi_node_type": "PipingComponent",
        "component_class": "AngleValve",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS5789384",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 325,
        "pid_entity_class": "rotary_pump",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 326,
        "pid_entity_class": "proportioning_pump",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 319,
        "pid_entity_class": "end_cap",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 327,
        "pid_entity_class": "well_pump",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 328,
        "pid_entity_class": "sump_pump",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 329,
        "pid_entity_class": "proportioning_pump_deuplex",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 330,
        "pid_entity_class": "progressive_cavity_pump",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 104,
        "pid_entity_class": "manifold_three_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": "PipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "Manifold",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS903171211",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 105,
        "pid_entity_class": "manifold_four_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 106,
        "pid_entity_class": "manifold_five_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 107,
        "pid_entity_class": "multiport_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 331,
        "pid_entity_class": "submersible_pump",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 332,
        "pid_entity_class": "screw_pump",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 333,
        "pid_entity_class": "peristaltic_pump",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 334,
        "pid_entity_class": "travelling_water_screen",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 335,
        "pid_entity_class": "belt_conveyor",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 336,
        "pid_entity_class": "screw_conveyor",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 337,
        "pid_entity_class": "barminutor",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 162,
        "pid_entity_class": "column",
        "pid_entity_type": 1,
        "dexpi_simple_label": "Equipment",
        "dexpi_node_type": "Equipment",
        "component_class": "Column",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS288179",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 338,
        "pid_entity_class": "fixed_screen",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 339,
        "pid_entity_class": "cyclone",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 340,
        "pid_entity_class": "centrifuge",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 11,
        "pid_entity_class": "off_or_on_page_connector",
        "pid_entity_type": 11,
        "dexpi_simple_label": "PipeConnectorSymbol",
        "dexpi_node_type": "PipeConnectorSymbol",
        "component_class": "PipeConnectorSymbol",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/PipeConnectorSymbol",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 12,
        "pid_entity_class": "junction",
        "pid_entity_type": 13,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 15,
        "pid_entity_class": "null_node",
        "pid_entity_type": 13,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 7,
        "pid_entity_class": "pneumatic_signal_line",
        "pid_entity_type": 4,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 9,
        "pid_entity_class": "electromagnetic_sonic_signal_line",
        "pid_entity_type": 4,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 10,
        "pid_entity_class": "capillary_signal_line",
        "pid_entity_type": 4,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 341,
        "pid_entity_class": "impactor",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 342,
        "pid_entity_class": "comminutor",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 343,
        "pid_entity_class": "rotary_feeder",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 76,
        "pid_entity_class": "four_way_hydrant",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 344,
        "pid_entity_class": "jet_mixer_eductor_ejector",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 345,
        "pid_entity_class": "injection_quill",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 346,
        "pid_entity_class": "flocculator_mixer",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 70,
        "pid_entity_class": "spool_piece",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 347,
        "pid_entity_class": "tank_mixer",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 348,
        "pid_entity_class": "engine",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 89,
        "pid_entity_class": "corrosion_coupon",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 90,
        "pid_entity_class": "corrosion_probe",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 349,
        "pid_entity_class": "air_driven_pump",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 98,
        "pid_entity_class": "typical_jacketed_pipe_fitting",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 97,
        "pid_entity_class": "typical_jacketed_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 99,
        "pid_entity_class": "typical_jacketed_check_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 350,
        "pid_entity_class": "gear_drive",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 118,
        "pid_entity_class": "actuator_with_mechanical_max_stop",
        "pid_entity_type": 9,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 119,
        "pid_entity_class": "actuator_with_mechanical_min_stop",
        "pid_entity_type": 9,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 351,
        "pid_entity_class": "in-line_mixer",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 352,
        "pid_entity_class": "hopper_silo_bin",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 353,
        "pid_entity_class": "closed_storage_tank",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 354,
        "pid_entity_class": "contactor",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 147,
        "pid_entity_class": "conical_top_tank",
        "pid_entity_type": 1,
        "dexpi_simple_label": "Tank",
        "dexpi_node_type": "Equipment",
        "component_class": "Tank",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS445139",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 355,
        "pid_entity_class": "pulsation_damper",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 356,
        "pid_entity_class": "centrifugal_fan",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 357,
        "pid_entity_class": "rotary_compressor",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 358,
        "pid_entity_class": "centrifugal_compressor",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 174,
        "pid_entity_class": "drip_tray",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 359,
        "pid_entity_class": "Air_Relief_Valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 360,
        "pid_entity_class": "Air_Vaccum_Valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 362,
        "pid_entity_class": "Automatic_Drain",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 363,
        "pid_entity_class": "Backflow_Preventor",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 364,
        "pid_entity_class": "Backflow_Preventor_Anti_Siphon",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 361,
        "pid_entity_class": "Anti-Sophon_Valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 365,
        "pid_entity_class": "Back_Pressure_Valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 367,
        "pid_entity_class": "Bellmouth_Deg_Intake",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 190,
        "pid_entity_class": "detail",
        "pid_entity_type": 13,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 24,
        "pid_entity_class": "gray_lock_coupling",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 25,
        "pid_entity_class": "flanged_end",
        "pid_entity_type": 6,
        "dexpi_simple_label": "PipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "FlangedEnd",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS429434",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 26,
        "pid_entity_class": "cap_end",
        "pid_entity_type": 6,
        "dexpi_simple_label": "PipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "PipeCap",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS421649",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 27,
        "pid_entity_class": "cap_end_screwed",
        "pid_entity_type": 6,
        "dexpi_simple_label": "PipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "PipeCap",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS421649",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 368,
        "pid_entity_class": "Bellmouth_Intake",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 366,
        "pid_entity_class": "Ball_Check_Valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 370,
        "pid_entity_class": "Combination_Line_Filter_Regulator_Lubricator",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 371,
        "pid_entity_class": "Combination_Regulator_Line_Filter",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 369,
        "pid_entity_class": "Block_Bleed_Valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 372,
        "pid_entity_class": "Combinator_Air_Relief_Vacuum_Valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 374,
        "pid_entity_class": "Desiccent_Dryer",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 375,
        "pid_entity_class": "Diffuser",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 373,
        "pid_entity_class": "Cylinder_Operated_Valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 377,
        "pid_entity_class": "Electrohydraulic",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 376,
        "pid_entity_class": "Drain_Valve_On_Main_Valve_Body",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 379,
        "pid_entity_class": "Expansion_Joint",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 380,
        "pid_entity_class": "Eye_Wash",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 381,
        "pid_entity_class": "Flap_Gate",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 378,
        "pid_entity_class": "Equalizing_Valve_On_Main_Valve_Body",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 382,
        "pid_entity_class": "Flow_Straightening_Valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 384,
        "pid_entity_class": "Hand_Well_Operator",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 385,
        "pid_entity_class": "Harnessed_Compression_Coupling",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 386,
        "pid_entity_class": "Heat_Trace_Electric",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 387,
        "pid_entity_class": "Inline_Pressure_Sensor",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 383,
        "pid_entity_class": "Foot_Valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 389,
        "pid_entity_class": "Insulation_Heat_Trace_Glycol",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 390,
        "pid_entity_class": "Insulation_Heat_Trace_Steam",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 391,
        "pid_entity_class": "Line_Filter",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 388,
        "pid_entity_class": "Inline_Pressure_Sensor_Needle_Valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 393,
        "pid_entity_class": "Mushroom_Vent",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 392,
        "pid_entity_class": "Mud_Valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 395,
        "pid_entity_class": "Pitot_Tube",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 394,
        "pid_entity_class": "Pinch_Valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 396,
        "pid_entity_class": "Positive_Displacement_Type_Flow_Totalizing_Indicator",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 398,
        "pid_entity_class": "Pre_Filter",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 399,
        "pid_entity_class": "Refrigerated_Dryer",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 397,
        "pid_entity_class": "Post_Indicator_Valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 35,
        "pid_entity_class": "emergency_shower_eye_wash",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 401,
        "pid_entity_class": "Rupture_Disk",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 402,
        "pid_entity_class": "Safety_Shower",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 403,
        "pid_entity_class": "Signal_Interlock_Logic",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 404,
        "pid_entity_class": "Silencer_Muffler",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 405,
        "pid_entity_class": "Slide_Gate",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 406,
        "pid_entity_class": "Sluice_Gate",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 407,
        "pid_entity_class": "Solenoid",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 408,
        "pid_entity_class": "Sonic_Flowmeter",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 409,
        "pid_entity_class": "Spade_Blind",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 410,
        "pid_entity_class": "Spray_Bar",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 411,
        "pid_entity_class": "Spring_Operator",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 412,
        "pid_entity_class": "Strainer_Basket_Type",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 413,
        "pid_entity_class": "Strainer_Basket_Type_Duplex",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 414,
        "pid_entity_class": "Target_Or_Mass_Flow_Meter",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 400,
        "pid_entity_class": "Rotary_Valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 416,
        "pid_entity_class": "Threaded_Square_Head_Pipe_Plug",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 417,
        "pid_entity_class": "Ultrasonic_Level_Transmitter",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 418,
        "pid_entity_class": "Vaccum_Breaker",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 419,
        "pid_entity_class": "Water_Cooler",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 420,
        "pid_entity_class": "Coriolis_mass_flowmeter",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 421,
        "pid_entity_class": "flexible_connection",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 422,
        "pid_entity_class": "Threaded_Square_Head_Pipe_Plug",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 423,
        "pid_entity_class": "Bell_And_Spigot_Mechanical_Join_Double_Joint",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 424,
        "pid_entity_class": "Bell_And_Spigot_Mechanical_Join_Single_Joint",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 425,
        "pid_entity_class": "Blind_Flange_Or_Capped_Double_Line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 426,
        "pid_entity_class": "Flanged_Flexible_Coupling_Double_Line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 427,
        "pid_entity_class": "Flanged_Flexible_Coupling_Single_Line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 428,
        "pid_entity_class": "Flange_To_Flange_Slip_On_Double_Line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 429,
        "pid_entity_class": "Flange_To_Flange_Slip_On_Single_Line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 430,
        "pid_entity_class": "Flange_To_Flange_Weld_Neck_Double_Line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 431,
        "pid_entity_class": "Flange_To_Flange_Weld_Neck_Single_Line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 432,
        "pid_entity_class": "Flexible_Coupling_Double_Boot",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 433,
        "pid_entity_class": "Flexible_Coupling_Double_Line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 434,
        "pid_entity_class": "Flexible_Coupling_Single_Boot",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 435,
        "pid_entity_class": "Flexible_Coupling_Single_Line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 436,
        "pid_entity_class": "Insulating_Flange_Double_Line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 437,
        "pid_entity_class": "Insulating_Flange_Single_Line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 438,
        "pid_entity_class": "Pipe_To_Pipe_Screwed_Connection_Double_Line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 439,
        "pid_entity_class": "Pipe_To_Pipe_Screwed_Connection_Single_Line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 440,
        "pid_entity_class": "Pipe_To_Pipe_Welded_Double_Line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 441,
        "pid_entity_class": "Slip_On_Flange_Double_Line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 442,
        "pid_entity_class": "Threaded_Double_Line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 443,
        "pid_entity_class": "Union_Double_Line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 444,
        "pid_entity_class": "Union_Single_Line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 445,
        "pid_entity_class": "Victaulic_Coupling_Double_Line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 446,
        "pid_entity_class": "Victaulic_Coupling_Single_Line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 447,
        "pid_entity_class": "Victaulic_Double_Line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 448,
        "pid_entity_class": "Victaulic_Flange_Adapter_Double_Line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 449,
        "pid_entity_class": "Victaulic_Flange_Adapter_Single_Line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 450,
        "pid_entity_class": "Victaulic_Single_Line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 451,
        "pid_entity_class": "Welded_Double_Line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 452,
        "pid_entity_class": "Welded_Single_Line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 453,
        "pid_entity_class": "Weld_Neck_Flange_Double_Line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 454,
        "pid_entity_class": "Weld_Neck_Flange_Single_Line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 415,
        "pid_entity_class": "Thermal_Valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 455,
        "pid_entity_class": "closed_storage_tank",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 456,
        "pid_entity_class": "contactor",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 457,
        "pid_entity_class": "gear_drive",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 458,
        "pid_entity_class": "pressure_tank",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 459,
        "pid_entity_class": "adsorber_vessel",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 460,
        "pid_entity_class": "air_cooler_forced_draft_induced_fan",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 461,
        "pid_entity_class": "belt_driven_skimmer",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 462,
        "pid_entity_class": "blower",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 463,
        "pid_entity_class": "bund_wall",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 464,
        "pid_entity_class": "burn_pit",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 465,
        "pid_entity_class": "centrifugal_compressor",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 466,
        "pid_entity_class": "centrifugal_pump",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 467,
        "pid_entity_class": "chiller_with_three_streams",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 468,
        "pid_entity_class": "chiller_with_two_streams",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 469,
        "pid_entity_class": "coalescer",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 470,
        "pid_entity_class": "electric_heater",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 471,
        "pid_entity_class": "expander",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 472,
        "pid_entity_class": "filter",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 473,
        "pid_entity_class": "filter_2",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 474,
        "pid_entity_class": "horizontal_vessel",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 512,
        "pid_entity_class": "diaphgram_seal",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 476,
        "pid_entity_class": "kettle_type_reboiler",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 477,
        "pid_entity_class": "metering_pump",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 478,
        "pid_entity_class": "oil_skimmer",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 479,
        "pid_entity_class": "pig_launcher_and_receiver",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 480,
        "pid_entity_class": "reciprocating_compressor",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 481,
        "pid_entity_class": "rotary_compressor",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 482,
        "pid_entity_class": "ro_unit",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 483,
        "pid_entity_class": "shell_tube_exchanger",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 484,
        "pid_entity_class": "slug_catcher_filter",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 485,
        "pid_entity_class": "sphere",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 487,
        "pid_entity_class": "storage_tank_with_dome_roof",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 488,
        "pid_entity_class": "storage_tank_with_floating_roof",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 489,
        "pid_entity_class": "submersible_pump",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 490,
        "pid_entity_class": "sump",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 491,
        "pid_entity_class": "tilted_plate_interceptor",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 492,
        "pid_entity_class": "tower",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 493,
        "pid_entity_class": "vertical_pump",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 494,
        "pid_entity_class": "vertical_vessel",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 513,
        "pid_entity_class": "double_block_bleed",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 498,
        "pid_entity_class": "pig_launcher",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 506,
        "pid_entity_class": "block",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 475,
        "pid_entity_class": "horizontal_vessel_witjboot",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 486,
        "pid_entity_class": "storage_tank_witcone_roof",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 507,
        "pid_entity_class": "piping_to_instrument_line",
        "pid_entity_type": 3,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 508,
        "pid_entity_class": "horn",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 509,
        "pid_entity_class": "bleed_ring",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 510,
        "pid_entity_class": "characterize",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 511,
        "pid_entity_class": "clamp_connection",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 514,
        "pid_entity_class": "emergency_shower",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 515,
        "pid_entity_class": "square_root",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 516,
        "pid_entity_class": "fabric_filter",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 517,
        "pid_entity_class": "filter_regulator",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 518,
        "pid_entity_class": "fire_hydrant",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 519,
        "pid_entity_class": "five_way_manifold",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 520,
        "pid_entity_class": "flow_meter",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 521,
        "pid_entity_class": "flow_straightening_wanes",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 522,
        "pid_entity_class": "four_way_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 523,
        "pid_entity_class": "fusible_link",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 524,
        "pid_entity_class": "gain",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 525,
        "pid_entity_class": "hand_control",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 526,
        "pid_entity_class": "insulated_line",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 527,
        "pid_entity_class": "interlock_device",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 528,
        "pid_entity_class": "liquid_trap",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 529,
        "pid_entity_class": "locking_device",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 530,
        "pid_entity_class": "magnetic_flowmeter",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 531,
        "pid_entity_class": "plug_check_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 532,
        "pid_entity_class": "pneumatic_operator",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 533,
        "pid_entity_class": "positive_choke_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 534,
        "pid_entity_class": "pressure_temperature_test",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 535,
        "pid_entity_class": "quick_disconnect",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 536,
        "pid_entity_class": "rotameter",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 499,
        "pid_entity_class": "open_storage_tank",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 537,
        "pid_entity_class": "sampler",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 538,
        "pid_entity_class": "sampling_connection",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 539,
        "pid_entity_class": "signal_esd_function",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 540,
        "pid_entity_class": "speciality_item",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 541,
        "pid_entity_class": "subtract",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 542,
        "pid_entity_class": "temperature_element",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 543,
        "pid_entity_class": "ucp_control",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 544,
        "pid_entity_class": "union",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 545,
        "pid_entity_class": "utility",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 546,
        "pid_entity_class": "vcom_flowmeter",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 547,
        "pid_entity_class": "vent_diffuser",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 548,
        "pid_entity_class": "vent_with_hood",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 549,
        "pid_entity_class": "water_cut_meter",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 550,
        "pid_entity_class": "weld_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 495,
        "pid_entity_class": "flow_sight_glass",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 496,
        "pid_entity_class": "level_bulbs",
        "pid_entity_type": 2,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 500,
        "pid_entity_class": "knife_gate_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 551,
        "pid_entity_class": "ccr_panel_mounted_instrument",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 189,
        "pid_entity_class": "text",
        "pid_entity_type": 12,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 552,
        "pid_entity_class": "ccr_back_panel_mounted_instrument",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 553,
        "pid_entity_class": "local_ucp_control",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 554,
        "pid_entity_class": "pcs_logic",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 555,
        "pid_entity_class": "plc_function_system",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 556,
        "pid_entity_class": "plc_function_local",
        "pid_entity_type": 7,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 501,
        "pid_entity_class": "solenoid_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 557,
        "pid_entity_class": "air_cooler",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 558,
        "pid_entity_class": "axial_compressor",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 559,
        "pid_entity_class": "barrel_pump",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 80,
        "pid_entity_class": "gas_trap_vent",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 560,
        "pid_entity_class": "coil_in_box",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 561,
        "pid_entity_class": "diaphragm_pump",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 562,
        "pid_entity_class": "double_casing_proportioning_pump",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 563,
        "pid_entity_class": "double_diaphragm_pump",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 564,
        "pid_entity_class": "double_pipe_heat_exchange",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 565,
        "pid_entity_class": "eccentric_pump",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 566,
        "pid_entity_class": "filter_coalescer_with_boot",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 567,
        "pid_entity_class": "flat_top_vessel",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 568,
        "pid_entity_class": "gear_pump",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 569,
        "pid_entity_class": "hand_pump",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 570,
        "pid_entity_class": "plate_frame_type",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 571,
        "pid_entity_class": "printed_circuit_heat_exchanger",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 572,
        "pid_entity_class": "reaction_furnace",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 573,
        "pid_entity_class": "reactor",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 574,
        "pid_entity_class": "rectangular_tank",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 575,
        "pid_entity_class": "reciprocating_positive_displacement_pump",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 576,
        "pid_entity_class": "scale",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 577,
        "pid_entity_class": "screw_compressor",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 578,
        "pid_entity_class": "spherical_tank",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 579,
        "pid_entity_class": "steam_boiler",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 580,
        "pid_entity_class": "storage_silo",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 581,
        "pid_entity_class": "sulphur_lock",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 582,
        "pid_entity_class": "thermal_oxidiser",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 583,
        "pid_entity_class": "tote_tank",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 584,
        "pid_entity_class": "ufire_tube",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 585,
        "pid_entity_class": "vaccum_pump",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 586,
        "pid_entity_class": "vertical_vessel_with_drum",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 502,
        "pid_entity_class": "vacuum_relief_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 503,
        "pid_entity_class": "solenoid_valve_3_way",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 109,
        "pid_entity_class": "hand_operated_actuator",
        "pid_entity_type": 9,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 13,
        "pid_entity_class": "tilde_line_break",
        "pid_entity_type": 13,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 504,
        "pid_entity_class": "solenoid_valve_4_way",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 121,
        "pid_entity_class": "well",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 505,
        "pid_entity_class": "valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 114,
        "pid_entity_class": "hand_operated_actuator_without_motor",
        "pid_entity_type": 9,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 184,
        "pid_entity_class": "local_dcs_function",
        "pid_entity_type": 8,
        "dexpi_simple_label": "ProcessInstrumentationFunction",
        "dexpi_node_type": "ProcessInstrumentationFunction",
        "component_class": "ProcessInstrumentationFunction",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/ProcessInstrumentationFunction",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 175,
        "pid_entity_class": "punched_equipment_nozzle",
        "pid_entity_type": 2,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 19,
        "pid_entity_class": "companion_line",
        "pid_entity_type": 13,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 20,
        "pid_entity_class": "visual_tee",
        "pid_entity_type": 13,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 21,
        "pid_entity_class": "data_node",
        "pid_entity_type": 13,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 22,
        "pid_entity_class": "unclassified_line",
        "pid_entity_type": 13,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 187,
        "pid_entity_class": "rtu",
        "pid_entity_type": 8,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 188,
        "pid_entity_class": "generic_control_unit",
        "pid_entity_type": 8,
        "dexpi_simple_label": "ProcessInstrumentationFunction",
        "dexpi_node_type": "ProcessInstrumentationFunction",
        "component_class": "ProcessInstrumentationFunction",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/ProcessInstrumentationFunction",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 14,
        "pid_entity_class": "line_break",
        "pid_entity_type": 13,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 16,
        "pid_entity_class": "null_edge",
        "pid_entity_type": 13,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 17,
        "pid_entity_class": "direction_arrow",
        "pid_entity_type": 13,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 18,
        "pid_entity_class": "control_panel",
        "pid_entity_type": 13,
        "dexpi_simple_label": "ProcessInstrumentationFunction",
        "dexpi_node_type": "ProcessInstrumentationFunction",
        "component_class": "ProcessInstrumentationFunction",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/ProcessInstrumentationFunction",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 23,
        "pid_entity_class": "flanged_joint",
        "pid_entity_type": 6,
        "dexpi_simple_label": "Flange",
        "dexpi_node_type": "PipingComponent",
        "component_class": "Flange",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS13307654",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 73,
        "pid_entity_class": "bug_screen",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 81,
        "pid_entity_class": "basket_strainer",
        "pid_entity_type": 6,
        "dexpi_simple_label": "Strainer",
        "dexpi_node_type": "PipingComponent",
        "component_class": "BasketStrainer",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS426014",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 28,
        "pid_entity_class": "hose_coupling",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 30,
        "pid_entity_class": "insulation",
        "pid_entity_type": 6,
        "dexpi_simple_label": "Insulation",
        "dexpi_node_type": "PipingComponent",
        "component_class": "Insulation",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS328094",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 31,
        "pid_entity_class": "insulating_coupling",
        "pid_entity_type": 6,
        "dexpi_simple_label": "PipeCoupling",
        "dexpi_node_type": "PipingComponent",
        "component_class": "PipeCoupling",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS415664",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 32,
        "pid_entity_class": "insulating_gasket_set",
        "pid_entity_type": 6,
        "dexpi_simple_label": "PipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "Gasket",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS415394",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 37,
        "pid_entity_class": "emergency_relief_hatch",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 38,
        "pid_entity_class": "generic_inline_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": "Valve",
        "dexpi_node_type": "PipingComponent",
        "component_class": "Valve",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS292589",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 40,
        "pid_entity_class": "parallel_slide_gate_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 41,
        "pid_entity_class": "globe_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": "Valve",
        "dexpi_node_type": "PipingComponent",
        "component_class": "GlobeValve",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS416204",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 42,
        "pid_entity_class": "ball_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": "BallValve",
        "dexpi_node_type": "PipingComponent",
        "component_class": "BallValve",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS416654",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 43,
        "pid_entity_class": "check_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CheckValve",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CheckValve",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS292229",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 44,
        "pid_entity_class": "plug_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 45,
        "pid_entity_class": "butterfly_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": "ButterflyValve",
        "dexpi_node_type": "PipingComponent",
        "component_class": "ButterflyValve",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS416609",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 77,
        "pid_entity_class": "two_way_hydrant",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 78,
        "pid_entity_class": "condensate_trap_drain",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 47,
        "pid_entity_class": "diaphragm_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 48,
        "pid_entity_class": "three_way_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": "Valve",
        "dexpi_node_type": "PipingComponent",
        "component_class": "ThreeWayValve",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS6331499",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 50,
        "pid_entity_class": "float_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 51,
        "pid_entity_class": "deluge_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 65,
        "pid_entity_class": "flat_top_eccentric_reducer",
        "pid_entity_type": 6,
        "dexpi_simple_label": "PipeReducer",
        "dexpi_node_type": "PipingComponent",
        "component_class": "PipeReducer",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS416294",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": true
    },
    {
        "id": 58,
        "pid_entity_class": "spade_blind",
        "pid_entity_type": 6,
        "dexpi_simple_label": "PipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "Spade",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS311669",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 61,
        "pid_entity_class": "spectacle_blind_closed",
        "pid_entity_type": 6,
        "dexpi_simple_label": "PipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "SpectacleBlind",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS422324",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 62,
        "pid_entity_class": "spectacle_blind_open",
        "pid_entity_type": 6,
        "dexpi_simple_label": "PipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "SpectacleBlind",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS422324",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 54,
        "pid_entity_class": "buckling_type_pressure_relief_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 57,
        "pid_entity_class": "hammer_blind",
        "pid_entity_type": 6,
        "dexpi_simple_label": "PipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "LineBlind",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS280034",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 59,
        "pid_entity_class": "restriction_orifice",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 60,
        "pid_entity_class": "ring_spacer",
        "pid_entity_type": 6,
        "dexpi_simple_label": "PipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "PipeSpacer",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS13173555",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 56,
        "pid_entity_class": "vacuum_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 67,
        "pid_entity_class": "static_mixer",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 68,
        "pid_entity_class": "conical_strainer",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 69,
        "pid_entity_class": "venturi_type_primary_element",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 71,
        "pid_entity_class": "silencer",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 79,
        "pid_entity_class": "drip_drain",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 83,
        "pid_entity_class": "tundish",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 85,
        "pid_entity_class": "open_vent",
        "pid_entity_type": 6,
        "dexpi_simple_label": "PipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "VentLine",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS905841131",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 86,
        "pid_entity_class": "bursting_disc",
        "pid_entity_type": 6,
        "dexpi_simple_label": "PipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "RuptureDisc",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS8372601",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 87,
        "pid_entity_class": "steam_trap_assembly",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 95,
        "pid_entity_class": "bird_screen",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 120,
        "pid_entity_class": "solenoid_actuator",
        "pid_entity_type": 9,
        "dexpi_simple_label": "ControlledActuator",
        "dexpi_node_type": "ActuatingSystemComponent",
        "component_class": "ControlledActuator",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/ControlledActuator",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 91,
        "pid_entity_class": "gre_spacer",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 93,
        "pid_entity_class": "expansion_contraction_bellows",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 96,
        "pid_entity_class": "spray_device",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 108,
        "pid_entity_class": "tile",
        "pid_entity_type": 6,
        "dexpi_simple_label": "PipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "http://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 100,
        "pid_entity_class": "bucket_type_steam_trap_with_integrated_check_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 103,
        "pid_entity_class": "manifold_two_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": "PipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "Manifold",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS903171211",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 111,
        "pid_entity_class": "diaphragm_actuator",
        "pid_entity_type": 9,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 112,
        "pid_entity_class": "electric_motor",
        "pid_entity_type": 9,
        "dexpi_simple_label": "ControlledActuator",
        "dexpi_node_type": "ActuatingSystemComponent",
        "component_class": "ControlledActuator",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/ControlledActuator",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 115,
        "pid_entity_class": "hydraulic_hand_wheel_operated_actuator",
        "pid_entity_type": 9,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 116,
        "pid_entity_class": "electric_motor_operated_actuator_with_hand_wheel",
        "pid_entity_type": 9,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 117,
        "pid_entity_class": "actuator",
        "pid_entity_type": 9,
        "dexpi_simple_label": "ControlledActuator",
        "dexpi_node_type": "ActuatingSystemComponent",
        "component_class": "ControlledActuator",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/ControlledActuator",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 122,
        "pid_entity_class": "electric_generator",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 123,
        "pid_entity_class": "reciprocating_engine",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 142,
        "pid_entity_class": "vessel",
        "pid_entity_type": 1,
        "dexpi_simple_label": "Vessel",
        "dexpi_node_type": "Equipment",
        "component_class": "Vessel",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS414674",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 125,
        "pid_entity_class": "concentric_pig_launcher_receiver",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 126,
        "pid_entity_class": "flat_bottom_pig_launcher_receiver",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 127,
        "pid_entity_class": "air_cooled_heat_exchanger_forced_draught",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 128,
        "pid_entity_class": "air_cooled_heat_exchanger_forced_draught_pitch_fans",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 135,
        "pid_entity_class": "reciprocating_compressor",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 130,
        "pid_entity_class": "air_cooled_heat_exchanger_induced_draught_pitch_fans",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 132,
        "pid_entity_class": "gear_box",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 133,
        "pid_entity_class": "variable_speed_gear_box",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 134,
        "pid_entity_class": "compressor",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 182,
        "pid_entity_class": "telemetry",
        "pid_entity_type": 7,
        "dexpi_simple_label": "ProcessInstrumentationFunction",
        "dexpi_node_type": "ProcessInstrumentationFunction",
        "component_class": "ProcessInstrumentationFunction",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/ProcessInstrumentationFunction",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 137,
        "pid_entity_class": "blower",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 139,
        "pid_entity_class": "floating_head_heat_exchanger",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 146,
        "pid_entity_class": "open_tank",
        "pid_entity_type": 1,
        "dexpi_simple_label": "Tank",
        "dexpi_node_type": "Equipment",
        "component_class": "Tank",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS445139",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 151,
        "pid_entity_class": "reciprocating_pump",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 143,
        "pid_entity_class": "removable_dish_end_vessel",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 144,
        "pid_entity_class": "removable_flat_end_vessel",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 145,
        "pid_entity_class": "dome_and_sump_vessel",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 183,
        "pid_entity_class": "dcs_function_in_control_room",
        "pid_entity_type": 8,
        "dexpi_simple_label": "ProcessInstrumentationFunction",
        "dexpi_node_type": "ProcessInstrumentationFunction",
        "component_class": "ProcessInstrumentationFunction",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/ProcessInstrumentationFunction",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 149,
        "pid_entity_class": "floating_roof_tank",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 152,
        "pid_entity_class": "centrifugal_pump",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CentrifugalPump",
        "dexpi_node_type": "Equipment",
        "component_class": "CentrifugalPump",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS416834",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 157,
        "pid_entity_class": "basket_filter",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 164,
        "pid_entity_class": "furnace",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 154,
        "pid_entity_class": "propeller_mixer",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 155,
        "pid_entity_class": "cyclone",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 156,
        "pid_entity_class": "cartridge_filter",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 169,
        "pid_entity_class": "pfs_heater",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 193,
        "pid_entity_class": "change_piping_class",
        "pid_entity_type": 15,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 195,
        "pid_entity_class": "change_units_battery_limit",
        "pid_entity_type": 15,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 196,
        "pid_entity_class": "change_in_responsibility",
        "pid_entity_type": 15,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 197,
        "pid_entity_class": "slop_indicator",
        "pid_entity_type": 15,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 198,
        "pid_entity_class": "extended_label",
        "pid_entity_type": 15,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 199,
        "pid_entity_class": "fence_boundary",
        "pid_entity_type": 15,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 63,
        "pid_entity_class": "concentric_reducer",
        "pid_entity_type": 6,
        "dexpi_simple_label": "PipeReducer",
        "dexpi_node_type": "PipingComponent",
        "component_class": "PipeReducerConcentric",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS421514",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": true
    },
    {
        "id": 159,
        "pid_entity_class": "tray_column",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 160,
        "pid_entity_class": "single_pass_counter_flow_exchanger",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 166,
        "pid_entity_class": "filter_bed",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 165,
        "pid_entity_class": "de_superheater",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 168,
        "pid_entity_class": "pfs_air_cooled_heat_exchanger",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 170,
        "pid_entity_class": "pfs_electric_heater",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 181,
        "pid_entity_class": "local_panel_mounted",
        "pid_entity_type": 7,
        "dexpi_simple_label": "ProcessInstrumentationFunction",
        "dexpi_node_type": "ProcessInstrumentationFunction",
        "component_class": "ProcessInstrumentationFunction",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/ProcessInstrumentationFunction",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 176,
        "pid_entity_class": "equipment_nozzle",
        "pid_entity_type": 2,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": null,
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 177,
        "pid_entity_class": "manhole_cover",
        "pid_entity_type": 2,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 178,
        "pid_entity_class": "handhole_cover",
        "pid_entity_type": 2,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 179,
        "pid_entity_class": "locally_mounted_instrument",
        "pid_entity_type": 7,
        "dexpi_simple_label": "ProcessInstrumentationFunction",
        "dexpi_node_type": "ProcessInstrumentationFunction",
        "component_class": "ProcessInstrumentationFunction",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/ProcessInstrumentationFunction",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 180,
        "pid_entity_class": "main_control_room_mounted_instrument",
        "pid_entity_type": 7,
        "dexpi_simple_label": "ProcessInstrumentationFunction",
        "dexpi_node_type": "ProcessInstrumentationFunction",
        "component_class": "ProcessInstrumentationFunction",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/ProcessInstrumentationFunction",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 185,
        "pid_entity_class": "plc_in_control_room",
        "pid_entity_type": 8,
        "dexpi_simple_label": "ProcessInstrumentationFunction",
        "dexpi_node_type": "ProcessInstrumentationFunction",
        "component_class": "ProcessInstrumentationFunction",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/ProcessInstrumentationFunction",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 186,
        "pid_entity_class": "dedicated_computer_function_in_control_room",
        "pid_entity_type": 8,
        "dexpi_simple_label": "ProcessInstrumentationFunction",
        "dexpi_node_type": "ProcessInstrumentationFunction",
        "component_class": "ProcessInstrumentationFunction",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/ProcessInstrumentationFunction",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 191,
        "pid_entity_class": "package",
        "pid_entity_type": 13,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 192,
        "pid_entity_class": "boxed_valve_label",
        "pid_entity_type": 15,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 194,
        "pid_entity_class": "above_below_ground_indicator",
        "pid_entity_type": 15,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 66,
        "pid_entity_class": "y_type_strainer",
        "pid_entity_type": 6,
        "dexpi_simple_label": "Strainer",
        "dexpi_node_type": "PipingComponent",
        "component_class": "YStrainer",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS422279",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 72,
        "pid_entity_class": "strainer",
        "pid_entity_type": 6,
        "dexpi_simple_label": "Strainer",
        "dexpi_node_type": "PipingComponent",
        "component_class": "Strainer",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS422504",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 74,
        "pid_entity_class": "tee",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 75,
        "pid_entity_class": "barred_tee",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 82,
        "pid_entity_class": "fire_monitor",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 84,
        "pid_entity_class": "flame_arrester",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 88,
        "pid_entity_class": "inductor",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 148,
        "pid_entity_class": "removable_flat_top_tank",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 92,
        "pid_entity_class": "duplex_strainer",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 94,
        "pid_entity_class": "flanged_flexible_hose",
        "pid_entity_type": 6,
        "dexpi_simple_label": "PipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "FlexibleHoseFlanged",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS302219",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 102,
        "pid_entity_class": "property_break",
        "pid_entity_type": 6,
        "dexpi_simple_label": "PropertyBreak",
        "dexpi_node_type": "PropertyBreak",
        "component_class": "PropertyBreak",
        "component_class_uri": "http://sandbox.dexpi.org/rdl/PropertyBreak",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 110,
        "pid_entity_class": "piston_actuator",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 124,
        "pid_entity_class": "plate_heat_exchanger",
        "pid_entity_type": 1,
        "dexpi_simple_label": "Equipment",
        "dexpi_node_type": "Equipment",
        "component_class": "HeatExchanger",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS304199",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 129,
        "pid_entity_class": "air_cooled_heat_exchanger_induced_draught",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 131,
        "pid_entity_class": "gas_turbine",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 136,
        "pid_entity_class": "steam_turbine",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 138,
        "pid_entity_class": "fixed_tube_sheet_heat_exchanger",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 140,
        "pid_entity_class": "kettle_type_reboiler",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 141,
        "pid_entity_class": "utube_heat_exchanger",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 150,
        "pid_entity_class": "dome_vessel",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 153,
        "pid_entity_class": "rotary_positive_displacement_pump",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 158,
        "pid_entity_class": "packed_column",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 161,
        "pid_entity_class": "double_sump_vessel",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 163,
        "pid_entity_class": "centrifugal_pump_submerged_suction_motor_driven",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 167,
        "pid_entity_class": "pfs_condenser",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 171,
        "pid_entity_class": "pfs_heat_exchanger",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 172,
        "pid_entity_class": "pfs_clean_out_door",
        "pid_entity_type": 1,
        "dexpi_simple_label": null,
        "dexpi_node_type": null,
        "component_class": null,
        "component_class_uri": "",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 173,
        "pid_entity_class": "pig_signaller",
        "pid_entity_type": 1,
        "dexpi_simple_label": "CustomEquipment",
        "dexpi_node_type": "Equipment",
        "component_class": "CustomEquipment",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomEquipment",
        "map_all_text_inside": false,
        "isValve": false,
        "isReducer": false
    },
    {
        "id": 39,
        "pid_entity_class": "wedge_type_gate_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": "Valve",
        "dexpi_node_type": "PipingComponent",
        "component_class": "WedgeGateValve",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS851579",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 46,
        "pid_entity_class": "needle_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": "Valve",
        "dexpi_node_type": "PipingComponent",
        "component_class": "NeedleValve",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS421064",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 52,
        "pid_entity_class": "foot_valve_with_strainer",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 53,
        "pid_entity_class": "conventional_type_pressure_relief_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": "Valve",
        "dexpi_node_type": "PipingComponent",
        "component_class": "PressureReliefValve",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS7461439",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 55,
        "pid_entity_class": "breather_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": "CustomPipingComponent",
        "dexpi_node_type": "PipingComponent",
        "component_class": "CustomPipingComponent",
        "component_class_uri": "https://sandbox.dexpi.org/rdl/CustomPipingComponent",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    },
    {
        "id": 101,
        "pid_entity_class": "self_actuating_valve",
        "pid_entity_type": 6,
        "dexpi_simple_label": "Valve",
        "dexpi_node_type": "PipingComponent",
        "component_class": "SelfActuatedPressureControValve",
        "component_class_uri": "http://data.posccaesar.org/rdl/RDS446579",
        "map_all_text_inside": true,
        "isValve": true,
        "isReducer": false
    }
];

const ProjectSetupSteps = {
    LEGEND_EXTRACTION: "LEGEND_EXTRACTION",
    DRAWING_AREA_SELECTION: "DRAWING_AREA_SELECTION",
    METADATA_EXTRACTION: "METADATA_EXTRACTION"
};
const labelList = {
    [ProjectSetupSteps.LEGEND_EXTRACTION]: entityClassesMaster.map(e => e.pid_entity_class),
    [ProjectSetupSteps.DRAWING_AREA_SELECTION]: ["drawing_area", "non_drawing_area"],
    [ProjectSetupSteps.METADATA_EXTRACTION]: ["title", "project", "document_no.", "address"]
};
const editorState = [
    {
        "image": {
            "id": "1",
            "src": "https://api.escuelajs.co/api/v1/files/f85d.jpg",
            "name": "AKER LEGEND 1"
        },
        "boxes": [
            {
                "x": 100,
                "y": 100,
                "width": 100,
                "height": 100,
                "label": "air_filter"
            },
            {
                "x": 200,
                "y": 200,
                "width": 200,
                "height": 200,
                "label": "air_filter"
            }
        ]
    },
    {
        "image": {
            "id": "2",
            "src": "https://api.escuelajs.co/api/v1/files/b7be.jpg",
            "name": "AKER LEGEND 2 very long name of file sdf"
        },
        "boxes": [
            {
                "x": 300,
                "y": 300,
                "width": 300,
                "height": 300,
                "label": "air_filter"
            },
            {
                "x": 400,
                "y": 400,
                "width": 400,
                "height": 400,
                "label": "air_filter"
            },
            {
                "x": 1579.816586921851,
                "y": 1623.2615629984052,
                "width": 612.4768740031896,
                "height": 650.3620414673046,
                "label": "air_filter"
            },
            {
                "x": 1430.6926025725238,
                "y": 582.7526946276369,
                "width": 70.4111305479039,
                "height": 53.37617960889486,
                "label": "ball_valve"
            }
        ]
    }
];

const spacingLeft = 300;
function LegendExtraction({ onContinue }) {
    const [editor, setEditor] = React.useState(null);
    const [showUploadDragger, setShowUploadDragger] = Recoil_index_22(showUploadDraggerAtom);
    const setLoader = Recoil_index_24(loaderAtom);
    const setImageList = Recoil_index_24(imageListAtom);
    const setActiveImage = Recoil_index_24(activeImageAtom);
    React.useEffect(() => {
        (async () => {
            const editor = new Editor({
                container: 'legend-editor',
                width: window.innerWidth,
                height: window.innerHeight,
                spacingLeft
            });
            setEditor(editor);
            window.editor = editor;
        })();
    }, []);
    React.useEffect(() => {
        async function initEditor() {
            if (!editor)
                return;
            editor.container().focus();
            setShowUploadDragger(false);
            setLoader({ visible: true, title: "Loading editor..." });
            await new Promise(resolve => setTimeout(resolve, 2000));
            await editor.importEditorState(editorState);
            if (editor.images.length === 0) {
                setShowUploadDragger(true);
            }
            setLoader({ visible: false });
        }
        initEditor();
    }, [editor]);
    const handleContinue = () => {
        setImageList([]);
        setShowUploadDragger(true);
        setActiveImage(null);
        editor?.removeActiveImage();
        editor?.destructor();
        onContinue();
    };
    const handleSave = async () => {
        try {
            setLoader({ visible: true, title: "Saving current state..." });
            await new Promise(resolve => setTimeout(resolve, 2000));
            const editorState = editor?.exportEditorState();
            console.log(editorState, "Editor State");
            setLoader({ visible: true, title: "Uploading legend..." });
            const legend = editor?.extractCutOuts();
            console.log(legend, "Legend");
            await new Promise(resolve => setTimeout(resolve, 2000));
        }
        catch (error) {
        }
        finally {
            setLoader({ visible: false });
        }
    };
    return (jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("div", { id: 'legend-editor' }), editor &&
                jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [showUploadDragger && jsxRuntimeExports.jsx(UploadDragger, { allowMultiple: true, spacingLeft: spacingLeft, editor: editor }), jsxRuntimeExports.jsx(TopActionBar, { editor: editor, step: ProjectSetupSteps.LEGEND_EXTRACTION, onSave: handleSave, onContinue: handleContinue }), jsxRuntimeExports.jsx(LeftSidebar, { editor: editor }), jsxRuntimeExports.jsx(AnnotationPopup, { editor: editor, labelList: labelList[ProjectSetupSteps.LEGEND_EXTRACTION] }), jsxRuntimeExports.jsx(Toolbar, { editor: editor }), jsxRuntimeExports.jsx(ImageLoader, { spacingLeft: spacingLeft })] })] }));
}

function LegendAnnotation({ onContinue }) {
    return (jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsxs(Recoil_index_5, { children: [jsxRuntimeExports.jsx(_default, {}), jsxRuntimeExports.jsx(LegendExtraction, { onContinue: onContinue })] }) }));
}

exports.LegendAnnotation = LegendAnnotation;
//# sourceMappingURL=index.js.map
